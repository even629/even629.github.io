<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>rust language | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="rust笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="rust language">
<meta property="og:url" content="https://even629.com/posts/42871/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="rust笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/rust_cover.webp">
<meta property="article:published_time" content="2025-09-11T14:55:13.000Z">
<meta property="article:modified_time" content="2025-10-19T10:00:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/rust_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/42871/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: even629","link":"链接: ","source":"来源: 常想一二，不思八九","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'rust language',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.gif', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/music.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/rust.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avatar.gif" alt="Logo"><span class="site-name">常想一二，不思八九</span></a><a class="nav-page-title" href="/"><span class="site-name">rust language</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">rust language</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T14:55:13.000Z" title="发表于 2025-09-11 22:55:13">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T10:00:13.000Z" title="更新于 2025-10-19 18:00:13">2025-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/programming/">programming</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">58.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>244分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/42871/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-11</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-19</p>
</div></div><div class='timeline-item-content'><p>modify some format errors</p>
</div></div></div>
<hr>
<h1 id="安装与调试"><a href="#安装与调试" class="headerlink" title="安装与调试"></a>安装与调试</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Linux 情况下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"><span class="comment"># 按照提示进行安装</span></span><br><span class="line">rustc --version</span><br></pre></td></tr></table></figure>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Linux 下使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rust-gdb target/debug/your_program</span><br></pre></td></tr></table></figure>
<h1 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>cargo new 项目名称</p>
<p>帮助信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Create a new cargo package at &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Usage: cargo.exe new [OPTIONS] &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -q, --quiet                Do not <span class="built_in">print</span> cargo <span class="built_in">log</span> messages</span><br><span class="line">      --registry &lt;REGISTRY&gt;  Registry to use</span><br><span class="line">      --vcs &lt;VCS&gt;            Initialize a new repository <span class="keyword">for</span> the given version control system (git, hg, pijul, or fossil) or <span class="keyword">do</span> not initialize any version control at all (none), overriding a global configuration. [possible values: git, hg, pijul, fossil, none]</span><br><span class="line">      --bin                  Use a binary (application) template [default]</span><br><span class="line">  -v, --verbose...           Use verbose output (-vv very verbose/build.rs output)</span><br><span class="line">      --lib                  Use a library template</span><br><span class="line">      --color &lt;WHEN&gt;         Coloring: auto, always, never</span><br><span class="line">      --edition &lt;YEAR&gt;       Edition to <span class="built_in">set</span> <span class="keyword">for</span> the crate generated [possible values: 2015, 2018, 2021]</span><br><span class="line">      --frozen               Require Cargo.lock and cache are up to <span class="built_in">date</span></span><br><span class="line">      --name &lt;NAME&gt;          Set the resulting package name, defaults to the directory name</span><br><span class="line">      --locked               Require Cargo.lock is up to <span class="built_in">date</span></span><br><span class="line">      --offline              Run without accessing the network</span><br><span class="line">      --config &lt;KEY=VALUE&gt;   Override a configuration value</span><br><span class="line">  -Z &lt;FLAG&gt;                  Unstable (nightly-only) flags to Cargo, see <span class="string">&#x27;cargo -Z help&#x27;</span> <span class="keyword">for</span> details</span><br><span class="line">  -h, --<span class="built_in">help</span>                 Print <span class="built_in">help</span> information</span><br><span class="line"></span><br><span class="line">Run `cargo <span class="built_in">help</span> new` <span class="keyword">for</span> more detailed information.</span><br></pre></td></tr></table></figure>
<p><strong>Cargo.toml</strong></p>
<p>TOML(Tom’s Obvious,Minimal Language)格式，是 Cargo 的配置格式</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span><span class="comment">#区域标题，表示一下面是用来配置包package的</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello&quot;</span> <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#项目版本</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;cauchy &lt;731005515@qq.com&gt;&quot;</span>] <span class="comment">#作者</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#使用的Rust版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span><span class="comment">#依赖项</span></span><br></pre></td></tr></table></figure>
<p>在 Rust 中，代码的包叫做<strong>crate</strong></p>
<h2 id="构建-Cargo-项目"><a href="#构建-Cargo-项目" class="headerlink" title="构建 Cargo 项目"></a>构建 Cargo 项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<p>创建可执行文件 target/debug/hello_cargo 或 target\debug\hello_cargo.exe(Windows)</p>
<p>运行.\target\debug\hello_cargo.exe</p>
<p>第一次运行会生成 cargo.lock 文件</p>
<p>该文件负责追踪项目依赖的精确版本，不需要手动修改该文件</p>
<h2 id="构建和运行-Cargo-项目"><a href="#构建和运行-Cargo-项目" class="headerlink" title="构建和运行 Cargo 项目"></a>构建和运行 Cargo 项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>
<p>如果之前编译过且代码没有修改的话会直接执行</p>
<h2 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure>
<p>检查代码，确保能通过编译，但是不产生任何可执行文件</p>
<p>cargo check 比 cargo build 快得多</p>
<h2 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<p>编译时会进行优化，代码运行的更快但是编译时间更长</p>
<p>会在 target/release 而不是 target/debug 生成可执行文件</p>
<h1 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h1><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><p>声明使用<strong>let</strong>关键字</p>
<p>默认情况下，变量是不可变的(immutable)</p>
<p>声明变量时，前面加上<strong>mut</strong>关键字，就可以使变量可变</p>
<p>let mut x = 3;</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><p>类似于不可变变量，<em><strong>常量(constants)</strong></em> 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p>
<p>1.不允许对常量使用 mut。常量不光默认不能变，它总是不能变。</p>
<p>2.声明常量使用 const 关键字而不是 let，并且 <strong><em>必须</em></strong> <strong>注明值的类型</strong>。</p>
<p>3.<strong>常量可以在任何作用域中声明</strong>，包括全局作用域，</p>
<p>4.最后一个区别是，常量只能被设置为<strong>常量表达式</strong>，而<strong>不可以是其他任何只能在运行时计算出的值</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> MAX_POINTS:<span class="type">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure>
<p>命名规范:全部大写，下划线间隔</p>
<h3 id="隐藏-shadow"><a href="#隐藏-shadow" class="headerlink" title="隐藏(shadow)"></a>隐藏(shadow)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以定义一个与之前变量同名的新变量,<strong>新的变量会 shadow 之前声明的同名变量</strong></p>
<p>shadow 和把变量标记为 mut<strong>是不一样的</strong></p>
<ul>
<li>如果不适用 let 关键字，那么给非 mut 的变量赋值会导致编译时错误</li>
<li>使用 let 声明的同名新变量，也是不可变的</li>
<li>使用 let 声明的同名新变量，<strong>他的类型可以与之前不同</strong></li>
</ul>
<h3 id="允许未使用的变量"><a href="#允许未使用的变量" class="headerlink" title="允许未使用的变量"></a>允许未使用的变量</h3><p>两种方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Rust 是<strong>静态编译语言</strong>，编译时必须知道所有变量的类型</p>
<h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><p>Rust 有四种基本的标量类型：<strong>整型</strong>、<strong>浮点型</strong>、<strong>布尔类型</strong>和<strong>字符类型</strong></p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>如果我们没有显式的给予变量一个类型，那编译器会自动帮我们推导一个类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;i32&quot;</span>.<span class="title function_ invoke__">to_string</span>(),<span class="title function_ invoke__">type_of</span>(&amp;x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">type_of</span>&lt;T&gt;(_: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::any::type_name::&lt;T&gt;())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>整数如果不赋予类型默认为 i32 类型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">u16</span> = <span class="number">38_u8</span> <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>长度</strong></th>
<th><strong>有符号</strong></th>
<th><strong>无符号</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
</div>
<p>isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">i8</span>::MAX, <span class="number">127</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>整型字面值</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数字字面值</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Decimal (十进制)</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex (十六进制)</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal (八进制)</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary (二进制)</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte (单字节字符)(仅限于 u8)</td>
<td>b’A’</td>
</tr>
</tbody>
</table>
</div>
<p>Rust 的数字类型默认是 i32。isize 或 usize 主要作为某些集合的索引。</p>
<p><strong>整形溢出</strong></p>
<p>比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 “整型溢出”（<strong>integer overflow</strong> ），这会导致以下两种行为之一的发生。当<strong>在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em></strong>，这个术语被 Rust 用来表明程序因错误而退出。</p>
<p><strong>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码回绕（<em>two’s complement wrapping</em>）的操作</strong>。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 256 变成 0，值 257 变成 1，依此类推。依赖整型回绕被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，Wrapping。 为了显式地处理溢出的可能性，你可以使用标准库在原生数值类型上提供的以下方法:</p>
<ul>
<li>所有模式下都可以使用 <strong>wrapping_* 方法进行回绕</strong>，如 wrapping_add</li>
<li>如果 <strong>checked_* 方法</strong>出现溢出，则返回 None 值</li>
<li>用 <strong>overflowing_* 方法</strong>返回值和一个布尔值，表示是否出现溢出</li>
<li>用 <strong>saturating_* 方法</strong>在值的最小值或最大值处进行饱和处理</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决代码中的错误和 `panic`</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">251_u8</span> + <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">i8</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">251</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">247_u8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">i8</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">119</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">251_u16</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">u16</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">251</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浮点数采用 IEEE-754 标准表示。f32 是单精度浮点数，f64 是双精度浮点数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1_000.000_1</span>; <span class="comment">// f64</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">0.12</span>; <span class="comment">// f32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="number">0.01_f64</span>; <span class="comment">// f64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数值运算</strong></p>
<p>Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会<strong>向下舍入</strong>到最接近的整数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>);<span class="comment">//报错</span></span><br><span class="line"> &#125;</span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>assertion failed: `(left == right)`</span><br><span class="line">  left: `<span class="number">0.30000000000000004</span>`,</span><br><span class="line"> right: `<span class="number">0.3</span>`<span class="string">&#x27;, src<span class="char escape_">\m</span>ain.rs:5:5</span></span><br></pre></td></tr></table></figure>
<p>两种修改方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="number">0.1</span>+<span class="number">0.2</span>&gt;=<span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="number">0.1_f32</span>+<span class="number">0.2_f32</span>==<span class="number">0.3_f32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T &gt;(something:T)</span><br><span class="line"><span class="keyword">where</span> T : Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,something);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 整数加法</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1u32</span> + <span class="number">2</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数减法</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1i32</span> - <span class="number">2</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1i8</span> - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">3</span> * <span class="number">50</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">9</span> / <span class="number">3</span> == <span class="number">3</span>); <span class="comment">// error ! 修改它让代码工作</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">24</span> % <span class="number">5</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑与或非操作</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="literal">true</span> || <span class="literal">false</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(!<span class="literal">true</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 AND 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> &amp; <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 OR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> | <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> ^ <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;</span>, <span class="number">1u32</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;</span>, <span class="number">0x80u32</span> &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> -<span class="number">3</span>..<span class="number">2</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;i is &#123;&#125;&quot;</span>,i);<span class="comment">//-3到1不包括2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,c);<span class="comment">//a-z包括z</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="comment">// 解决代码中的错误和 `panic`</span></span><br><span class="line"><span class="keyword">use</span> std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..<span class="number">5</span>), Range&#123; start: <span class="number">1</span>, end: <span class="number">5</span> &#125;);</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..=<span class="number">5</span>), RangeInclusive::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>Rust 中的布尔类型使用 bool 表示</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span> || <span class="literal">true</span>;<span class="comment">//布尔运算</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(t, f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>Rust 的 char 类型是语言中最原生的字母类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_char</span>(c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_char</span>(c : <span class="type">char</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用单引号声明 char 字面量，而与之相反的是，使用双引号声明字符串字面量。Rust 的 char 类型的大小为<strong>四个字节</strong>(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 char 并不符合。</p>
<p><strong>大小</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;c1),<span class="number">4</span>); <span class="comment">//一个字符4个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;c2),<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v</span>: () = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(_v, <span class="title function_ invoke__">implicitly_ret_unit</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">implicitly_ret_unit</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I will return a ()&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>单元类型所占的内存为 0！！！</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unit</span>: () = ();</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;unit) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组<strong>长度固定</strong>：一旦声明，其长度不会增大或缩小</p>
<p>使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的<strong>类型也不必是相同的</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tup 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用<strong>模式匹配</strong>（pattern matching）来<strong>解构</strong>（destructure）元组值，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    (y,z,x) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(y, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(z, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序首先创建了一个元组并绑定到 tup 变量上。接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。这叫做 <strong>解构</strong>（<strong><em>destructuring</em></strong>），因为它将一个元组拆成了三个部分。</p>
<p>也可以<strong>使用点号（.）后跟值的索引来直接访问它们</strong>。元组的第一个索引值是 0。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<p><strong>过长的元组无法打印</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复代码错误</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">too_long_tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;too long tuple: &#123;:?&#125;&quot;</span>, too_long_tuple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修复</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">too_long_tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;too long tuple: &#123;:?&#125;&quot;</span>, too_long_tuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust 中的数组长度是固定的。</p>
<p><strong>数组的类型是[T; Length]</strong>，<strong>数组的长度是类型签名的一部分，因此数组的长度必须在编译期就已知，</strong></p>
<p>vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。</p>
<p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p>
<p>let a: [i32; 5] = [1, 2, 3, 4, 5];</p>
<p>这里，i32 是每个元素的类型。分号之后，数字 5 表明该数组包含五个元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr0</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">char</span>; <span class="number">3</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间</span></span><br><span class="line">    <span class="comment">// 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符</span></span><br><span class="line">    <span class="built_in">assert!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;arr) == <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个<strong>每个元素都为相同值的数组</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>变量名为 a 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3。这种写法与 let a = [3, 3, 3, 3, 3]; 效果相同，但更简洁。</p>
<p><strong>访问数组元素</strong></p>
<p>数组是可以在栈(stack)上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Sunfei&quot;</span>), <span class="string">&quot;Sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name0</span> = names.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是下标索引就存在越界的风险了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_name1</span> = &amp;names[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无效的数组访问</strong></p>
<p>如果我们访问数组结尾之后的元素，程序在索引操作中使用一个无效的值时导致 <strong>运行时</strong> 错误。程序带着错误信息退出。当<strong>尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em></strong>，这是 Rust 术语，它用于程序因为错误而退出的情况。</p>
<p><strong>这种检查必须在运行时进行</strong>，特别是在某些情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="使用-as-进行基本类型转换"><a href="#使用-as-进行基本类型转换" class="headerlink" title="使用 as 进行基本类型转换"></a>使用 as 进行基本类型转换</h3><p>1.Rust 并<strong>没有为基本类型提供隐式的类型转换( coercion )</strong>，但是我们可以通过 as 来进行显式地转换。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">decimal</span> = <span class="number">97.123_f32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">integer</span>: <span class="type">u8</span> = decimal <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c1</span>: <span class="type">char</span> = decimal <span class="keyword">as</span> <span class="type">u8</span> <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c2</span> = integer <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;c1 is &#123;&#125;&quot;</span>,c1);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(integer, <span class="string">&#x27;b&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<strong>默认情况下, 数值溢出会导致编译错误</strong>，但是我们可以通过添加一行全局注解 <strong>#![allow(overflowing_literals)]</strong> 的方式来避免编译错误(溢出还是会发生)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(overflowing_literals)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">1000</span> <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.当将任何数值转换成无符号整型 T 时，如果当前的数值不在新类型的范围内，我们可以<strong>对当前数值进行加值或减值操作( 增加或减少 T::MAX + 1 )</strong>，直到最新的值在新类型的范围内，假设我们要将 300 转成 u8 类型，由于 u8 最大值是 255，因此 300 不在新类型的范围内并且大于新类型的最大值，因此我们需要减去 T::MAX + 1，也就是 300 - 256 = 44。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(overflowing_literals)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">1000</span> <span class="keyword">as</span> <span class="type">u16</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">1000</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">232</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事实上，之前说的规则对于正整数而言，就是如下的取模</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;1000 mod 256 is : &#123;&#125;&quot;</span>, <span class="number">1000</span> % <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(-<span class="number">1_i8</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从 Rust 1.45 开始，当浮点数超出目标整数的范围时，转化会直接取正整数取值范围的最大或最小值</span></span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">300.1_f32</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(-<span class="number">100.1_f32</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的浮点数转换有一点性能损耗，如果对于某段代码有极致的性能要求，</span></span><br><span class="line">    <span class="comment">// 可以考虑下面的方法，但是这些方法的结果可能会溢出并且返回一些无意义的值</span></span><br><span class="line">    <span class="comment">// 总之，请小心使用</span></span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">      <span class="comment">// 300.0 is 44</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;300.0 is &#123;&#125;&quot;</span>, <span class="number">300.0_f32</span>.to_int_unchecked::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">      <span class="comment">// -100.0 as u8 is 156</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;-100.0 as u8 is &#123;&#125;&quot;</span>, (-<span class="number">100.0_f32</span>).to_int_unchecked::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">      <span class="comment">// nan as u8 is 0</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;nan as u8 is &#123;&#125;&quot;</span>, <span class="type">f32</span>::NAN.to_int_unchecked::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.裸指针可以和代表内存地址的整数互相转换</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">values</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span>: *<span class="keyword">mut</span> <span class="type">i32</span> = values.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_address</span> = p1 <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second_address</span> = first_address + <span class="number">4</span>; <span class="comment">// 4 == std::mem::size_of::&lt;i32&gt;()</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = second_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *p2 += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(values[<span class="number">1</span>], <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> :[<span class="type">u64</span>; <span class="number">13</span>] = [<span class="number">0</span>; <span class="number">13</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;arr), <span class="number">8</span> * <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: *<span class="keyword">const</span> [<span class="type">u64</span>] = &amp;arr;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a <span class="keyword">as</span> *<span class="keyword">const</span> [<span class="type">u8</span>];</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;*b), <span class="number">13</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="From-Into"><a href="#From-Into" class="headerlink" title="From/Into"></a>From/Into</h3><ol>
<li>From 特征允许让一个类型<strong>定义如何基于另一个类型来创建自己</strong>，因此它提供了一个很方便的类型转换的方式。</li>
<li><strong>From 和 Into 是配对的，我们只要实现了前者，那后者就会自动被实现</strong>：只要实现了 impl From<T> for U， 就可以使用以下两个方法: let u: U = U::from(T) 和 let u:U = T.into()，前者由 From 特征提供，而后者由自动实现的 Into 特征提供。</li>
<li>需要注意的是，当使用 into 方法时，需要进行显式地类型标注，因为编译器很可能无法帮我们推导出所需的类型。</li>
</ol>
<p>例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_str</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下三个转换都依赖于一个事实：String 实现了 From&lt;&amp;str&gt; 特征</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(my_str);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = my_str.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="comment">// 这里需要显式地类型标注</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string3</span>: <span class="type">String</span> = my_str.<span class="title function_ invoke__">into</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">     <span class="comment">// impl From&lt;bool&gt; for i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span>:<span class="type">i32</span> = <span class="literal">false</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span>:<span class="type">i32</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, i2);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两种方式修复下面的错误</span></span><br><span class="line">    <span class="comment">// 1. 哪个类型实现 From 特征 : impl From&lt;char&gt; for ? , 我们可以查看一下之前提到的文档，来找到合适的类型</span></span><br><span class="line">    <span class="comment">// 2. 上一章节中介绍过的某个关键字</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i3</span>: <span class="type">i32</span> = <span class="string">&#x27;a&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两种方法来解决错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&#x27;a&#x27;</span> <span class="keyword">as</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// impl From&lt;bool&gt; for i32</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">i1</span>:<span class="type">i32</span> = <span class="literal">false</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">i2</span>:<span class="type">i32</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from</span>(<span class="literal">false</span>);</span><br><span class="line"> <span class="built_in">assert_eq!</span>(i1, i2);</span><br><span class="line"> <span class="built_in">assert_eq!</span>(i1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">i3</span>:<span class="type">u32</span> = <span class="string">&#x27;a&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&#x27;a&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">     <span class="comment">// impl From&lt;bool&gt; for i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span>:<span class="type">i32</span> = <span class="literal">false</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span>:<span class="type">i32</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, i2);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i3</span>: <span class="type">u32</span> = <span class="string">&#x27;a&#x27;</span> <span class="keyword">as</span> <span class="type">u32</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为自定义类型实现-From-特征"><a href="#为自定义类型实现-From-特征" class="headerlink" title="为自定义类型实现 From 特征"></a>为自定义类型实现 From 特征</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From 被包含在 `std::prelude` 中，因此我们没必要手动将其引入到当前作用域来</span></span><br><span class="line"><span class="comment">// use std::convert::From;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 `from` 方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(item: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Number &#123; value: item &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填空</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = Number::<span class="title function_ invoke__">from</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num.value, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: Number = <span class="number">30</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num.value, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行错误处理时，为我们自定义的错误类型实现 From 特征是非常有用。这样就可以<strong>通过 ? 自动将某个错误类型转换成我们自定义的错误类型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">IoError</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">ParseError</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">IoError</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: num::ParseIntError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">ParseError</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">open_and_parse_file</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="comment">// ? automatically converts io::Error to CliError</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(&amp;file_name)?;</span><br><span class="line">    <span class="comment">// num::ParseIntError -&gt; CliError</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TryFrom-TryInto"><a href="#TryFrom-TryInto" class="headerlink" title="TryFrom / TryInto"></a>TryFrom / TryInto</h3><p>类似于 From 和 Into, TryFrom 和 TryInto 也是用于类型转换的泛型特征。</p>
<p>但是又与 From/Into 不同, <strong>TryFrom 和 TryInto 可以对转换后的失败进行处理，然后返回一个 Result</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i16</span> = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Into 特征拥有一个方法`into`,</span></span><br><span class="line">  <span class="comment">// 因此 TryInto 有一个方法是 ?</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">u8</span> = <span class="keyword">match</span> n.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(n) =&gt; n,</span><br><span class="line">      <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">&quot;there is an error when converting: &#123;:?&#125;, but we catch it&quot;</span>, e.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EvenNum</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TryFrom</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">EvenNum</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 `try_from`</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_from</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNum</span>(value))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNum::<span class="title function_ invoke__">try_from</span>(<span class="number">8</span>), <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNum</span>(<span class="number">8</span>)));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNum::<span class="title function_ invoke__">try_from</span>(<span class="number">5</span>), <span class="title function_ invoke__">Err</span>(()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNum, ()&gt; = <span class="number">8i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNum</span>(<span class="number">8</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNum, ()&gt; = <span class="number">5i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result,<span class="title function_ invoke__">Err</span>(()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它转换"><a href="#其它转换" class="headerlink" title="其它转换"></a>其它转换</h3><h4 id="将任何类型转换成-String"><a href="#将任何类型转换成-String" class="headerlink" title="将任何类型转换成 String"></a>将任何类型转换成 String</h4><p>只要为一个类型实现了 ToString，就可以将任何类型转换成 String。事实上，这种方式并不是最好的，可以利用 fmt::Display trait？它可以控制一个类型如何打印，在实现它的时候还会自动实现 ToString。因为 to_string 是基于 fmt::Display 实现的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;The point is (&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(origin.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;The point is (0, 0)&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, origin), <span class="string">&quot;The point is (0, 0)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析-String"><a href="#解析-String" class="headerlink" title="解析 String"></a>解析 String</h4><p>使用 parse 方法可以将一个 String 转换成 i32 数字，这是因为在标准库中为 i32 类型实现了 FromStr: : impl FromStr for i32</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To use `from_str` method, you needs to introduce this trait into the current scope.</span></span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed</span>: <span class="type">i32</span> = <span class="string">&quot;5&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">turbo_parsed</span> = <span class="string">&quot;10&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">from_str</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;20&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = parsed + turbo_parsed + from_str;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义实现-FromStr-特征"><a href="#自定义实现-FromStr-特征" class="headerlink" title="自定义实现 FromStr 特征"></a>自定义实现 FromStr 特征</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FromStr</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 关联类型: 在一个 trait 里定义的、与这个 trait“绑定”的类型参数。</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Err</span> = ParseIntError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_str</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::<span class="literal">Err</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">coords</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">trim_matches</span>(|p| p == <span class="string">&#x27;(&#x27;</span> || p == <span class="string">&#x27;)&#x27;</span> )</span><br><span class="line">                                 .<span class="title function_ invoke__">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                                 .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x_fromstr</span> = coords[<span class="number">0</span>].parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y_fromstr</span> = coords[<span class="number">1</span>].parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Point &#123; x: x_fromstr, y: y_fromstr &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = <span class="string">&quot;(3,4)&quot;</span>.parse::&lt;Point&gt;();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(p.<span class="title function_ invoke__">unwrap</span>(), Point&#123; x: <span class="number">3</span>, y: <span class="number">4</span>&#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="transmute"><a href="#transmute" class="headerlink" title="transmute"></a>transmute</h4><p><strong>std::mem::transmute</strong> 是一个 unsafe 函数，可以<strong>把一个类型按位解释为另一个类型</strong>，其中这两个类型<strong>必须有同样的位数( bits )</strong>。</p>
<p>transmute 相当于将一个类型按位移动到另一个类型，它会将源值的所有位拷贝到目标值中，然后遗忘源值。该函数跟 C 语言中的 memcpy 函数类似。</p>
<p>正因为此，<strong>transmute</strong> <strong>非常非常不安全!</strong> 调用者必须要自己保证代码的安全性，当然这也是 unsafe 的目的。</p>
<p><strong>示例</strong></p>
<p>1.transmute 可以将一个指针转换成一个函数指针，该转换并不具备可移植性，原因是在不同机器上，函数指针和数据指针可能有不同的位数( size )。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pointer</span> = foo <span class="keyword">as</span> *<span class="title function_ invoke__">const</span> ();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">function</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        std::mem::transmute::&lt;*<span class="title function_ invoke__">const</span> (), <span class="title function_ invoke__">fn</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt;(pointer)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">function</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.transmute 还可以扩展或缩短一个不变量的生命周期，即<strong>生命周期的“非法转换</strong>!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// R 是一个包装了引用的结构体。它里面不存放 i32 本身，而是存放对 i32 的引用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">extend_lifetime</span>&lt;<span class="symbol">&#x27;b</span>&gt;(r: R&lt;<span class="symbol">&#x27;b</span>&gt;) <span class="punctuation">-&gt;</span> R&lt;<span class="symbol">&#x27;static</span>&gt; &#123;</span><br><span class="line">    std::mem::transmute::&lt;R&lt;<span class="symbol">&#x27;b</span>&gt;, R&lt;<span class="symbol">&#x27;static</span>&gt;&gt;(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">shorten_invariant_lifetime</span>&lt;<span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;c</span>&gt;(r: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;static</span>&gt;)</span><br><span class="line">                                             <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;c</span>&gt; &#123;</span><br><span class="line">    std::mem::transmute::&lt;&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;static</span>&gt;, &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;c</span>&gt;&gt;(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.事实上我们还可以使用一些安全的方法来替代 transmute.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">/*Turning raw bytes(&amp;[u8]) to u32, f64, etc.: */</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_bytes</span> = [<span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;[<span class="type">u8</span>; <span class="number">4</span>], <span class="type">u32</span>&gt;(raw_bytes) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use `u32::from_ne_bytes` instead</span></span><br><span class="line">    <span class="comment">// 按本机的端序</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_ne_bytes</span>(raw_bytes);</span><br><span class="line">    <span class="comment">// or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness</span></span><br><span class="line">    <span class="comment">// 小端</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_le_bytes</span>(raw_bytes);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num, <span class="number">0x12345678</span>);</span><br><span class="line">    <span class="comment">// 大端</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_be_bytes</span>(raw_bytes);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num, <span class="number">0x78563412</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Turning a pointer into a usize: */</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = &amp;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr_num_transmute</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;&amp;<span class="type">i32</span>, <span class="type">usize</span>&gt;(ptr) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use an `as` cast instead</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr_num_cast</span> = ptr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span> <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Turning an &amp;mut T into an &amp;mut U: */</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = &amp;<span class="keyword">mut</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val_transmuted</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;&amp;<span class="keyword">mut</span> <span class="type">i32</span>, &amp;<span class="keyword">mut</span> <span class="type">u32</span>&gt;(ptr) &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr as *mut i32：把 &amp;mut i32 转成原始指针 *mut i32。</span></span><br><span class="line">    <span class="comment">// as *mut u32：把原始指针再转换成 *mut u32。</span></span><br><span class="line">    <span class="comment">// &amp;mut *(...)：再把原始指针转换回可变引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val_casts</span> = <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(ptr <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Turning an &amp;str into a &amp;[u8]: */</span></span><br><span class="line">    <span class="comment">// this is not a good way to do this.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;&amp;<span class="type">str</span>, &amp;[<span class="type">u8</span>]&gt;(<span class="string">&quot;Rust&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">82</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">116</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You could use `str::as_bytes`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = <span class="string">&quot;Rust&quot;</span>.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">82</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">116</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or, just use a byte string, if you have control over the string</span></span><br><span class="line">    <span class="comment">// literal</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">b&quot;Rust&quot;</span>, &amp;[<span class="number">82</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">116</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Rust 代码中的<strong>函数和变量名</strong>使用 <strong><em>snake case</em></strong> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词</p>
<p>我们在 Rust 中通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>我们可以定义为拥有 <strong>参数</strong>（<em>parameters</em>）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（<em>arguments</em>）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当定义多个参数时，使用逗号分隔</p>
<h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h3><p>函数体由一系列的语句和一个可选的结尾表达式构成。</p>
<p><strong>语句</strong>（<em>Statements</em>）<strong>是执行一些操作但不返回值的指令</strong>。</p>
<p><strong>表达式</strong>（<em>Expressions</em>）<strong>计算并产生一个值</strong>。</p>
<p>语句不返回值，表达式会计算出一个值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x_squared</span> = x * x;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x_cube</span> = x_squared * x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面表达式的值将被赋给 `y`</span></span><br><span class="line">        x_cube + x_squared + x</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = &#123;</span><br><span class="line">        <span class="comment">// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span></span><br><span class="line">        <span class="number">2</span> * x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y is &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;z is &#123;:?&#125;&quot;</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句 let y = 6; 中的 6 是一个表达式，它计算出的值是 6。<strong>函数调用是一个表达式</strong>。<strong>宏调用是一个表达式</strong>。<strong>用大括号创建的一个新的块作用域也是一个表达式</strong>，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是一个代码块，它的值是 4。表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>不对返回值命名，但要在箭头（-&gt;）后声明它的类型</p>
<p>在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回类型为"><a href="#返回类型为" class="headerlink" title="返回类型为()"></a><strong>返回类型为()</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">type_of</span>(&amp;<span class="built_in">println!</span>(<span class="string">&quot;helloworld&quot;</span>)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">type_of</span>&lt;T&gt;(_: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::any::type_name::&lt;T&gt;())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//helloworld</span></span><br><span class="line"><span class="comment">//()</span></span><br></pre></td></tr></table></figure>
<h4 id="返回类型为-never"><a href="#返回类型为-never" class="headerlink" title="返回类型为 never"></a>返回类型为 never</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// implement this function, don&#x27;t modify fn signatures</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I return nothing&quot;</span>);</span><br><span class="line">        <span class="comment">// sleeping for 1 second to avoid exhausting the cpu resource</span></span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">never_return</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发散函数（Diverging-function）"><a href="#发散函数（Diverging-function）" class="headerlink" title="发散函数（Diverging function）"></a>发散函数（Diverging function）</h4><p>发散函数( Diverging function )不会返回任何值，因此它们可以用于替代需要返回任何值的地方</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_option</span>(tp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> tp &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里与其返回一个 None，不如使用发散函数替代</span></span><br><span class="line">    <span class="title function_ invoke__">never_return_fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用三种方法实现以下发散函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_option</span>(tp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> tp &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">never_return_fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPLEMENT this function</span></span><br><span class="line"><span class="comment">// DON&#x27;T change any code else</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">unimplemented!</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IMPLEMENT this function in THREE ways</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPLEMENT this function in THREE ways</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    todo!();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IMPLEMENT this function in THREE ways</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The difference between unimplemented! and [todo] is that while <strong>todo! conveys an intent of implementing the functionality later and the message is “not yet implemented”, unimplemented! makes no such claims. Its message is “not implemented”</strong>. Also some IDEs will mark todo!s.</p>
<p><strong>调用</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">get_option</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_option</span>(tp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> tp &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">never_return_fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPLEMENT this function</span></span><br><span class="line"><span class="comment">// DON&#x27;T change any code else</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 unimplemented!()和 todo!();会报以下错误</p>
<p>thread ‘main’ panicked at ‘not implemented’, src\main.rs:24:5</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_v</span> = <span class="keyword">match</span> b &#123;</span><br><span class="line">        <span class="literal">true</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 发散函数也可以用于 `match` 表达式，用于替代任何类型的值</span></span><br><span class="line">        <span class="literal">false</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;we have no value for `false`, but we can panic&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 表达式中与条件关联的代码块有时被叫做 *arms</p>
<p>if/else 可以用作表达式来进行赋值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">big_n</span> =</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">10</span> &amp;&amp; n &gt; -<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot; 数字太小，先增加 10 倍再说&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="number">10</span> * n</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;数字太大，我们得让它减半&quot;</span>);</span><br><span class="line"></span><br><span class="line">            n / <span class="number">2</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125;&quot;</span>, n, big_n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>1.代码中的<strong>条件必须是 bool</strong> 值。如果条件不是 bool 值，我们将得到一个错误。Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 的条件。</p>
<p>2.如果使用了多于 1 个 else if 最好使用 match 对代码进行重构</p>
<h3 id="在-let-语句中使用-if"><a href="#在-let-语句中使用-if" class="headerlink" title="在 let 语句中使用 if"></a>在 let 语句中使用 if</h3><p>因为 if 是一个表达式，我们可以在 let 语句的右侧使用它</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 的每个分支的可能的返回值都必须是相同类型</p>
<p><strong>注意</strong></p>
<p>if 代码块中的表达式返回一个整数，而 else 代码块中的表达式返回一个字符串。这不可行，因为变量必须只有一个类型。Rust 需要在编译时就确切的知道变量的类型</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="从循环中返回值"><a href="#从循环中返回值" class="headerlink" title="从循环中返回值"></a>从循环中返回值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h5><p>如果存在嵌套循环，break 和 continue 应用于此时最内层的循环。你可以选择在一个循环上指定一个 <strong>循环标签</strong>（<em>loop label</em>），然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环遍历集合元素相较于 while 循环，增强了代码安全性，并消除了可能由于超出数组的结尾或遍历长度不够而缺少一些元素而导致的 bug</p>
<p><strong>对于没有实现 copy 的可迭代对象 for in 会取得所有权</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;liming&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hanmeimei&quot;</span>)];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">name</span> <span class="keyword">in</span> &amp;names &#123;</span><br><span class="line">        <span class="comment">// do something with name...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, names);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// numbers中的元素实现了 Copy，因此无需转移所有权</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="comment">// do something with name...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过索引和值的方式迭代数组"><a href="#通过索引和值的方式迭代数组" class="headerlink" title="通过索引和值的方式迭代数组"></a>通过索引和值的方式迭代数组</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引和值的方式迭代数组 `a`</span></span><br><span class="line">    <span class="keyword">for</span> (i,v) <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>,i+<span class="number">1</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Range</strong></p>
<p>它是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列。(不包括结束的数字)</p>
<p>rev 方法可以反转 range</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="所有权，引用与借用"><a href="#所有权，引用与借用" class="headerlink" title="所有权，引用与借用"></a>所有权，引用与借用</h1><h2 id="栈（Stack）与堆（Heap）"><a href="#栈（Stack）与堆（Heap）" class="headerlink" title="栈（Stack）与堆（Heap）"></a>栈（Stack）与堆（Heap）</h2><p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。</p>
<p>增加数据叫做 <strong>进栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。栈中的所有数据都必须占用已知且固定的大小。</p>
<p><strong>在编译时大小未知或大小可能变化的数据，要存储在堆上</strong>。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。<strong>因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上</strong>，不过当需要实际数据时，必须访问指针。</p>
<p><strong>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。</strong>相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存），出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。</p>
<p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p>
<p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>
<h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ol>
<li><strong>Rust 中的每一个值都有一个 所有者（owner）</strong></li>
<li><strong>值在任一时刻有且只有一个所有者。</strong></li>
<li><strong>当所有者（变量）离开作用域，这个值将被丢弃。</strong></li>
</ol>
<p>所有权的例子：</p>
<p>修改下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">give_ownership</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能修改下面的代码!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">give_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="comment">// convert String to Vec</span></span><br><span class="line">    <span class="comment">// 将 String 转换成 Vec 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_s</span> = s.<span class="title function_ invoke__">into_bytes</span>();<span class="comment">//into_bytes会转移所有权</span></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">give_ownership</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only modify the code below!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">give_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="comment">// convert String to Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_s</span> = s.<span class="title function_ invoke__">as_bytes</span>();<span class="comment">//as_bytes不会转移所有权</span></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">give_ownership</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only modify the code below!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">give_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="当所有权转移时，可变性也可以随之改变。"><a href="#当所有权转移时，可变性也可以随之改变。" class="headerlink" title="当所有权转移时，可变性也可以随之改变。"></a>当所有权转移时，可变性也可以随之改变。</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = s;</span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量与作用域"><a href="#变量与作用域" class="headerlink" title="变量与作用域"></a>变量与作用域</h2><p>作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p>
<p>let s = “hello”;</p>
<p>变量 s 绑定到了一个字符串字面值，这个字符串值是<strong>硬编码</strong>进程序代码中的。这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的。示例 4-1 中的注释标明了变量 s 在何处是有效的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 s<strong>进入作用域</strong> 时，它就是有效的。</li>
<li>这一直持续到它 <strong>离开作用域</strong> 为止。</li>
</ul>
<h2 id="str-和-amp-str"><a href="#str-和-amp-str" class="headerlink" title="str 和&amp;str"></a>str 和&amp;str</h2><p>正常情况下我们无法使用 str 类型，但是可以使用 &amp;str 来替代</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="type">str</span> = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要使用 str 类型，只能配合 Box。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;hello, world&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: <span class="type">Box</span>&lt;<span class="type">str</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>&amp; 可以用来将 Box<str> 转换为 &amp;str 类型</strong> , Rust 的 <strong>Deref coercion</strong> 会把 <code>&amp;Box&lt;str&gt;</code> 自动转换为 <code>&amp;str</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;hello, world&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>String 是定义在标准库中的类型，分配在堆上，可以动态的增长。它的底层存储是动态字节数组的方式( Vec<u8> )，但是与字节数组不同，<strong>String 是 UTF-8 编码</strong>。</p>
<blockquote>
<p><strong>Unicode 和编码方式的区别</strong></p>
<ul>
<li><strong>Unicode</strong><ul>
<li>是一个字符集（character set），规定了每个字符对应一个唯一的 <strong>码点（code point）</strong></li>
<li>码点形式：<code>U+0000</code> ~ <code>U+10FFFF</code></li>
<li>例如：<ul>
<li><code>U+4F60</code> → ‘你’</li>
<li><code>U+1F600</code> → 😀</li>
</ul>
</li>
</ul>
</li>
<li><strong>UTF-8 / UTF-16 / UTF-32</strong><ul>
<li>是把 Unicode 码点转换成 <strong>字节序列</strong> 的具体方法</li>
<li>也就是说，Unicode 是“字符表”，UTF-8 是“如何存储或传输这些字符的编码规则”</li>
</ul>
</li>
</ul>
</blockquote>
<p>String.chars()和 String.bytes()分别以 Unicode 字符和字节遍历。</p>
<ul>
<li><strong>一个 Unicode 字符的长度不是固定的</strong></li>
<li><strong>一个 Unicode 字符并不一定是一个完整显示的字符</strong></li>
</ul>
<p>在 Unicode 和文本处理里，<strong>字符簇（grapheme cluster）</strong> 是一个用户感知的“字符单位”，也就是说，它是用户看到的一个完整字符，但它可能由 <strong>多个 Unicode 标量值（<code>char</code>）组成</strong>。</p>
<p>简单来说：</p>
<ul>
<li>一个字符簇 ≈ “一个完整显示字符”</li>
<li>不同于 Rust 的 <code>char</code>，<code>char</code> 是单个 Unicode 标量值（可能是一个字母、一个汉字、或一个 emoji 的组成部分）</li>
<li>一个字符簇可能包含：<ul>
<li>基础字符 + 组合符号（比如重音符）</li>
<li>emoji 组合（如 👨‍👩‍👧‍👦 家庭表情，由多个 emoji 和零宽连接符组成）</li>
</ul>
</li>
</ul>
<p>要遍历字符簇，需要第三方包，比如：</p>
<div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div>
<p>String 管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>可以</strong> 修改此类字符串 ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></table></figure>
<h2 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a>内存与分配</h2><p>就<strong>字符串字面值</strong>来说，我们在编译时就知道其内容，所以<strong>文本被直接硬编码进最终的可执行文件</strong>中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p>
<p>对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向内存分配器（memory allocator）请求内存。</li>
<li>需要一个当我们处理完 String 时将内存返回给分配器的方法。（某些语言的垃圾回收 GC）</li>
</ul>
<p>Rust 采取了一个不同的策略：<strong>内存在拥有它的变量离开作用域后就被自动释放</strong>。下面是示例 4-1 中作用域例子的一个使用 String 而不是字符串字面值的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的</span><br><span class="line"></span><br><span class="line">        // 使用 s</span><br><span class="line">    &#125;                                  // 此作用域已结束，</span><br><span class="line">                                       // s 不再有效</span><br></pre></td></tr></table></figure>
<p>这是一个将 String 需要的内存返回给分配器的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop">drop</a>，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。</p>
<h2 id="变量与数据交互的方式"><a href="#变量与数据交互的方式" class="headerlink" title="变量与数据交互的方式"></a>变量与数据交互的方式</h2><h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p><strong>栈数据</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>
<p>将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”。现在有了两个变量，x 和 y，都等于 5</p>
<p>因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中。</p>
<p>对于此类数据，移动和克隆没有区别</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>
<p>一个 String 由 3 部分组成：</p>
<ol>
<li>一个指向存放字符串内容的内存的指针</li>
<li>一个长度 len,指存放字符串内容所需的字节数</li>
<li>一个容量 capacity,指 String 从操作系统中总共获得内存的总字节数</li>
</ol>
<p>上面这些<strong>存放在栈上</strong>，存放字符串内容的部分存放在堆上</p>
<p>当我们将 s1 赋值给 s2，如果 String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。</p>
<p>当变量离开时，会调用 drop,导致 double free</p>
<p>为了保证内存安全</p>
<ul>
<li>Rust 没有尝试复制被分配的内存</li>
<li>Rust 让 s1 失效，即变量 s1 离开作用域时不需要释放任何东西（对应所有权规则 2:值在任一时刻有且只有一个所有者）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br><span class="line">warning: unused variable: `s2`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">3</span>:<span class="number">9</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  |         ^^ help: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_s2`</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="meta">#[warn(unused_variables)]</span>` on by default</span><br><span class="line"></span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">5</span>:<span class="number">28</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  |         -- <span class="keyword">move</span> occurs because `s1` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">3</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line"><span class="number">4</span> |</span><br><span class="line"><span class="number">5</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br><span class="line">  |                            ^^ value borrowed here after <span class="keyword">move</span></span><br><span class="line">  |</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` which comes from the expansion of the <span class="keyword">macro</span> `println` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">warning: `loop_test` (bin <span class="string">&quot;loop_test&quot;</span>) generated <span class="number">1</span> warning</span><br><span class="line">error: could not compile `loop_test` due to previous error; <span class="number">1</span> warning emitted</span><br></pre></td></tr></table></figure>
<p>rust 的这种方式不同于浅拷贝，因为<strong>在浅拷贝的同时让被拷贝者失效了</strong>，因此使用新的术语：移动(Move)</p>
<p><strong>隐含的设计原则</strong> : <strong>rust 不会自动创建数据的深拷贝</strong></p>
<p>因为就运行性能而言，任何自动赋值的操作都是廉价的。</p>
<h4 id="部分-move"><a href="#部分-move" class="headerlink" title="部分 move"></a>部分 move</h4><p>当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：<strong>变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。</strong></p>
<p>在这种情况下，<strong>原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用</strong>，也就是之前被引用的那部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        age: <span class="type">Box</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">        age: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">20</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`</span></span><br><span class="line">    <span class="comment">// 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Person</span> &#123; name, <span class="keyword">ref</span> age &#125; = person;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s age is &#123;&#125;&quot;</span>, age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s name is &#123;&#125;&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它</span></span><br><span class="line">    <span class="comment">//println!(&quot;The person struct is &#123;:?&#125;&quot;, person);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;</span>, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>如果相对 heap 的数据进行深拷贝，而不仅仅时 stack 上面的数据，可以使用 clone 方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span>=<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>=s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,s1,s2);</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = (<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s1, s2) = t.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, s1, s2, t); <span class="comment">// -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>Copy trait</strong>,可以用于像整数这样完全放在 stack 上面的类型</p>
<ul>
<li>如果一个类型实现了 Copy trait，那么旧的变量在赋值后仍然可用</li>
<li>如果一个类型或该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了</li>
</ul>
<p><strong>任何简单标量及其组合类型都是 Copy 的</strong></p>
<p><strong>任何需要分配内存或某种资源的都不是 Copy 的</strong></p>
<p>一些拥有 Copy trait 的类型：</p>
<ul>
<li>所有整数类型，比如 u32。</li>
<li>布尔类型，bool，它的值是 true 和 false。</li>
<li>所有浮点数类型，比如 f64。</li>
<li>字符类型，char。</li>
<li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li>
</ul>
<h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">                                    <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure>
<p>当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。</p>
<h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h3><p>返回值也可以转移所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 转移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 会将</span></span><br><span class="line">                                             <span class="comment">// 返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string</span></span><br><span class="line">                                             <span class="comment">// 并移出给调用的函数</span></span><br><span class="line">                                             <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line">                                                      <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量的所有权总是遵循相同的模式：</p>
<ul>
<li><strong>将值赋给另一个变量时移动它</strong>。</li>
<li>当持<strong>有堆中数据值的变量离开作用域</strong>时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</li>
</ul>
<p>如果让函数获得所得值而不获得所有权，需要把传入的参数返回</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() 返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样过于麻烦，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 <strong>引用</strong>（<em>references</em>）。</p>
<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用</strong>（<em>reference</em>）像一个指针，因为<strong>它是一个地址</strong>，我们可以由此访问储存于该地址的属于其他变量的数据。</p>
<p>与指针不同，<strong>引用确保指向某个特定类型的有效值。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">   <span class="comment">// 填写空白处</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">p</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;x 的内存地址是 &#123;:p&#125;&quot;</span>, p); <span class="comment">// output: 0x16fa3ac84</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：与使用 &amp; 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符 “ * “</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br></pre></td></tr></table></figure>
<p>&amp;s1 语法让我们创建一个 <strong>指向</strong> 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以<strong>当引用停止使用时，它所指向的值也不会被丢弃</strong>。</p>
<p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）</p>
<p>正如变量默认是不可变的，引用也一样。<strong>引用（默认）不允许修改引用的值。</strong></p>
<h3 id="rust-会在某些情况下自动解引用"><a href="#rust-会在某些情况下自动解引用" class="headerlink" title="rust 会在某些情况下自动解引用"></a>rust 会在某些情况下自动解引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">    p.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">borrow_object</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">borrow_object</span>(s: &amp;<span class="type">String</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">push_str</span>(&amp;<span class="keyword">mut</span> s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">push_str</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可变引用有一个很大的限制：<strong>某一时刻只能存在一个可变引用</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure>
<p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure>
<p>另外一个限制：<strong>不可以同时拥有一个可变引用和一个不可变的引用</strong></p>
<p>但是<strong>多个不可变的引用是可以的</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure>
<h3 id="悬空引用（悬垂引用-Dangling-References"><a href="#悬空引用（悬垂引用-Dangling-References" class="headerlink" title="悬空引用（悬垂引用 Dangling References)"></a>悬空引用（悬垂引用 Dangling References)</h3><p>在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>让我们尝试创建一个悬垂引用，Rust 会通过一个编译时错误来避免：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//s在函数结束后就drop了</span></span><br><span class="line">    &amp;s<span class="comment">//返回引用，但是函数结束后该地址就被释放掉了</span></span><br><span class="line">&#125;</span><br><span class="line">Compiling loop_test v0.<span class="number">1.0</span> (C:\Users\cauchy\Desktop\rust\loop_test)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">5</span>:<span class="number">16</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> | <span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function<span class="symbol">&#x27;s</span> <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">contains</span> a borrowed value, but there is no value <span class="keyword">for</span> <span class="title class_">it</span> to be borrowed from</span><br><span class="line">help: consider using the `<span class="symbol">&#x27;static</span>` lifetime</span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> | <span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">String</span> &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br><span class="line">error: could not compile `loop_test` due to previous error</span><br></pre></td></tr></table></figure>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 与 &amp; 类似，可以用来获取一个值的引用，但是它们的用法有所不同。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> r2 = c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(*r1, *r2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个内存地址的字符串是否相等</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">get_addr</span>(r1),<span class="title function_ invoke__">get_addr</span>(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取传入引用的内存地址的字符串形式</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_addr</span>(r: &amp;<span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用规则-借用规则-总结"><a href="#引用规则-借用规则-总结" class="headerlink" title="引用规则(借用规则)总结"></a>引用规则(借用规则)总结</h3><ul>
<li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>Ok: 从可变对象借用不可变</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">borrow_object</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">borrow_object</span>(s: &amp;<span class="type">String</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="None-Lexical-Lifetimes-NLL"><a href="#None-Lexical-Lifetimes-NLL" class="headerlink" title="None Lexical Lifetimes(NLL)"></a>None Lexical Lifetimes(NLL)</h3><p><strong>非词法作用域生命周期</strong></p>
<div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div>
<p>例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释掉一行代码让它工作</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,r1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释掉 println 即可</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);<span class="comment">//rust编译器知道这之后r1对s的借用生命周期结束了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//println!(&quot;&#123;&#125;&quot;,r1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = &amp;<span class="keyword">mut</span> x; <span class="comment">// mutable borrow</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">// later used</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码顺利编译，因为编译器知道 x 的可变借用并没有持续到作用域结尾，而是在 x 被再次使用之前就结束了，所以这里不存在冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time</span><br><span class="line">    // 你不能同时使用 r1 和 r2</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入 r1.push_str(“world”);即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">warning: unused variable: `r2`</span><br><span class="line"> --&gt; src/main.rs:5:9</span><br><span class="line">  |</span><br><span class="line">5 |     <span class="built_in">let</span> r2 = &amp;mut s;</span><br><span class="line">  |         ^^ <span class="built_in">help</span>: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_r2`</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_variables)]` on by default</span><br><span class="line"></span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a <span class="keyword">time</span></span><br><span class="line"> --&gt; src/main.rs:5:14</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     <span class="built_in">let</span> r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">...</span><br><span class="line">9 |     r1.push_str(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">  |     -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">warning: `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) generated 1 warning</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to 1 previous error; 1 warning emitted</span><br></pre></td></tr></table></figure>
<h2 id="切片类型-Slice"><a href="#切片类型-Slice" class="headerlink" title="切片类型 Slice"></a>切片类型 Slice</h2><p><strong><em>slice</em></strong> 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数接收一个用空格分隔单词的字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p>
<p>first_word 函数有一个参数 &amp;String。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取 <strong>部分</strong> 字符串的办法。不过，我们可以返回单词结尾的索引，结尾由一个空格表示</p>
<p>因为需要逐个元素的检查 String 中的值是否为空格，需要用 as_bytes 方法将 String 转化为字节数组：</p>
<p>let bytes = s.as_bytes();</p>
<p>接下来，使用 iter 方法在字节数组上创建一个迭代器：</p>
<p>for (i, &amp;item) in bytes.iter().enumerate() {</p>
<p>因为 enumerate 方法返回一个元组，我们可以使用模式来解构，所以在 for 循环中，我们指定了一个模式，其中元组中的 i 是索引而元组中的 &amp;item 是单个字节。因为我们从 .iter().enumerate() 中获取了集合元素的引用，所以模式中使用了 &amp;。</p>
<p>不过这有一个问题。我们返回了一个独立的 usize，不过它只在 &amp;String 的上下文中才是一个有意义的数字。换句话说，因为它是一个与 String 相分离的值，无法保证将来它仍然有效。</p>
<h3 id="字符串切片-string-slice"><a href="#字符串切片-string-slice" class="headerlink" title="字符串切片 string slice"></a>字符串切片 string slice</h3><p><strong>字符串 slice</strong>（<em>string slice</em>）是 String 中一部分值的引用，它看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> hello = &amp;s[0..5];</span><br><span class="line">    <span class="built_in">let</span> world = &amp;s[6..11];</span><br></pre></td></tr></table></figure>
<p><strong>[开始索引..终止索引]</strong></p>
<p><strong>[starting_index..ending_index]</strong></p>
<p>其中 starting_index 是 slice 的第一个位置，ending_index 则是 slice <strong>最后一个位置的后一个值。</strong></p>
<p>如果想要从索引 0 开始，可以不写两个点号之前的值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>如果 slice 包含 String 的最后一个字节，也可以舍弃尾部的数字</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];</span><br></pre></td></tr></table></figure>
<p>也可以同时舍弃这两个值来获取整个字符串的 slice</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<strong>字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，</strong>如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;你好，世界&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,slice);</span><br><span class="line">    <span class="built_in">assert!</span>(slice == <span class="string">&quot;你&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at src/main.rs:3:19:</span><br><span class="line">byte index 2 is not a char boundary; it is inside <span class="string">&#x27;你&#x27;</span> (bytes 0..3) of `你好，世界`</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<p>rust 中 String 索引操作 <code>s[i]</code> 不直接返回字符，因为 UTF-8 是可变长度编码。需要使用 <code>chars()</code> 或 <code>bytes()</code> 来遍历或操作字符串内容。比如 <code>chars()</code> 可以迭代 Unicode 字符，而<code>bytes()</code>单个字节。</p>
<p>重写函数，返回一个 slice(字符串切片返回值可以写成：&amp;str)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误! s需要是一个可变引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 clear 需要清空 String，它尝试获取一个可变引用。在调用 clear 之后的 println! 使用了 word 中的引用，所以这个不可变的引用在此时必须仍然有效。Rust 不允许 clear 中的可变引用和 word 中的不可变引用同时存在，因此编译失败</p>
<h3 id="字符串字面值就是-slice"><a href="#字符串字面值就是-slice" class="headerlink" title="字符串字面值就是 slice"></a>字符串字面值就是 slice</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这里 s 的类型是 &amp;str：<strong>它是一个指向二进制程序特定位置的 slice,</strong>这也就是为什么字符串字面值是不可变的；&amp;str 是一个不可变引用。</p>
<h3 id="字符串-slice-作为参数"><a href="#字符串-slice-作为参数" class="headerlink" title="字符串 slice 作为参数"></a>字符串 slice 作为参数</h3><p>在知道了能够获取字面值和 String 的 slice 后，我们对 first_word 做了改进，这是它的签名：</p>
<p>fn first_word(s: &amp;String) -&gt; &amp;str {</p>
<p>而更有经验的 Rustacean 会编写出如下的签名，因为它使得可以对 &amp;String 值和 &amp;str 值使用相同的函数：</p>
<p>fn first_word(s: &amp;str) -&gt; &amp;str {</p>
<p>如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice 或对 String 的引用。这种灵活性利用了 <em>deref coercions</em> 的优势，定义一个获取字符串 slice 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于 `String`（的 slice），整体或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line">    <span class="comment">// `first_word` 也适用于 `String` 的引用，</span></span><br><span class="line">    <span class="comment">// 这等价于整个 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于字符串字面值，整体或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值已经是字符串 slice 了</span></span><br><span class="line">    <span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>&amp;String 可以被隐式地转换为&amp;str 类型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里, &amp;s 是 `&amp;String` 类型，但是 `first_character` 函数需要的是 `&amp;str` 类型。</span></span><br><span class="line">    <span class="comment">// 尽管两个类型不一样，但是代码仍然可以工作，原因是 `&amp;String` 会被隐式地转换成 `&amp;str` 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ch</span> = <span class="title function_ invoke__">first_character</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first character is: &#123;&#125;&quot;</span>, ch);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_character</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他类型的-slice"><a href="#其他类型的-slice" class="headerlink" title="其他类型的 slice"></a>其他类型的 slice</h3><p>字符串 slice，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p>
<p>let a = [1, 2, 3, 4, 5];</p>
<p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p>这个 slice 的类型是 &amp;[i32]。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。</p>
<p>切片跟数组相似，但是<strong>切片的长度无法在编译期得知</strong>，因此你<strong>无法直接使用切片类型</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复代码中的错误，不要新增代码行!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: [<span class="type">i32</span>] = arr[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: <span class="type">str</span> = <span class="string">&quot;hello, world&quot;</span> <span class="keyword">as</span> <span class="type">str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修复后</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: &amp;[<span class="type">i32</span>] = &amp;arr[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = <span class="string">&quot;hello, world&quot;</span> <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个切片引用占用了<strong>2 个字</strong>大小的内存空间( 从现在开始，为了简洁性考虑，如无特殊原因，我们统一使用切片来特指切片引用 )。 该切片的<strong>第一个字是指向数据的指针，第二个字是切片的长度</strong>。</li>
<li>字的大小取决于处理器架构，例如在 x86-64 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> arr: [char; 3] = [<span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;国&#x27;</span>, <span class="string">&#x27;人&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> slice = &amp;arr[..2];</span><br><span class="line"></span><br><span class="line">    assert!(std::mem::size_of_val(&amp;slice) == 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>切片( 引用 )可以用来<strong>借用数组的某个连续的部分</strong>，对应的签名是 &amp;[T]，可以与数组的签名对比下 [T; Length]。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="built_in">let</span> arr: [i32; 5] = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> slice: &amp;[i32] = &amp;arr[1..4];</span><br><span class="line">  assert_eq!(slice, &amp;[2, 3, 4]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>需要使用 struct 关键字并为整个结构体提供一个名字。</p>
<p>在大括号中，定义每一部分数据的名字和类型，我们称为 <strong>字段</strong>（<em>field</em>）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在实例化一个结构体时将它整体标记为可变的，但是 Rust <strong>不允许我们将结构体的某个字段专门指定为可变的.</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>),</span><br><span class="line">        age,</span><br><span class="line">    &#125;;</span><br><span class="line">    p.age = <span class="number">30</span>;</span><br><span class="line">    p.name = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunfei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的</p>
<h2 id="字段初始化简写"><a href="#字段初始化简写" class="headerlink" title="字段初始化简写"></a>字段初始化简写</h2><p>当字段名与字段值对应的变量名相同时，就可以使用字段初始化简写的方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Struct-更新语法"><a href="#Struct-更新语法" class="headerlink" title="Struct 更新语法"></a>Struct 更新语法</h2><p>基于 现有的 struct 实例创建一个新的实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 struct 更新语法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tuple-Struct-元组结构体"><a href="#Tuple-Struct-元组结构体" class="headerlink" title="Tuple Struct 元组结构体"></a>Tuple Struct 元组结构体</h2><p>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。</p>
<p>适用于给整个元组取一个名字，并使元组成为与其他元组不同的类型时</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问此类结构体，与访问元组相同：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = <span class="title function_ invoke__">Point</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, p.<span class="number">0</span>, p.<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="没有任何字段的类单元结构体（unit-like-structs）"><a href="#没有任何字段的类单元结构体（unit-like-structs）" class="headerlink" title="没有任何字段的类单元结构体（unit-like structs）"></a>没有任何字段的类单元结构体（unit-like structs）</h2><p><strong>没有任何字段的类单元结构体</strong>,它们类似于 ()</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct-中的所有权"><a href="#struct-中的所有权" class="headerlink" title="struct 中的所有权"></a>struct 中的所有权</h2><p>在示例 5-1 中的 User 结构体的定义中，我们使用了自身拥有所有权的 String 类型而不是 &amp;str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要<strong>这个结构体拥有它所有的数据</strong>，<strong>为此只要整个结构体是有效的话其数据也是有效的。</strong></p>
<p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错：缺少生命周期标识符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:3:15</span><br><span class="line">  |</span><br><span class="line">3 |     username: &amp;str,</span><br><span class="line">  |               ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="built_in">help</span>: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">2 |     active: bool,</span></span><br><span class="line"><span class="string">3 ~     username: &amp;&#x27;</span>a str,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:4:12</span><br><span class="line">  |</span><br><span class="line">4 |     email: &amp;str,</span><br><span class="line">  |            ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="built_in">help</span>: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">2 |     active: bool,</span></span><br><span class="line"><span class="string">3 |     username: &amp;str,</span></span><br><span class="line"><span class="string">4 ~     email: &amp;&#x27;</span>a str,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to 2 previous errors</span><br></pre></td></tr></table></figure>
<h2 id="打印-struct"><a href="#打印-struct" class="headerlink" title="打印 struct"></a>打印 struct</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span>=Rectangle&#123;</span><br><span class="line">        width:<span class="number">30</span>,</span><br><span class="line">        length:<span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">area</span>(&amp;rect));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,rect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rect: &amp;Rectangle)<span class="punctuation">-&gt;</span><span class="type">u32</span>&#123;</span><br><span class="line">    rect.width*rect.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct-的方法"><a href="#struct-的方法" class="headerlink" title="struct 的方法"></a>struct 的方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">u32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.width*<span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span>=Rectangle&#123;</span><br><span class="line">        width:<span class="number">30</span>,</span><br><span class="line">        length:<span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,rect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在 impl 块里面定义方法</li>
<li><strong>方法的第一个参数可以是&amp;self，也可以获得其所有权或可变借用，和其他参数一样</strong></li>
<li>更良好的代码组织</li>
</ol>
<h2 id="方法调用的运算符"><a href="#方法调用的运算符" class="headerlink" title="方法调用的运算符"></a>方法调用的运算符</h2><p>在 C/C++ 语言中，有两个不同的运算符来调用方法：. 直接在对象上调用方法，而 -&gt; 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 object 是一个指针，那么 object-&gt;something() 就像 (*object).something() 一样。</p>
<p>Rust 并没有一个与 -&gt; 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。<strong>方法调用</strong>是 Rust 中<strong>少数几个拥有这种行为的地方</strong>。</p>
<p>它是这样工作的：当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &amp;、&amp;mut 或 * 以便使 object 与方法签名匹配。也就是说，这些代码是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.distance(&amp;p2);</span><br><span class="line">(&amp;p1).distance(&amp;p2);</span><br></pre></td></tr></table></figure>
<p>这种自动引用的行为之所以有效，是因为<strong>方法有一个明确的接收者</strong>———— <strong>self 的类型</strong>。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（&amp;self），做出修改（&amp;mut self）或者是获取所有权（self）。</p>
<h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有在 impl 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>）</p>
<p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 new ，但 <strong>new 并不是一个关键字</strong>。</p>
<p><strong>使用结构体名和 :: 语法来调用这个关联函数：比如 let sq = Rectangle::square(3)</strong>;。这个函数位于结构体的命名空间中：:: 语法用于关联函数和模块创建的命名空间</p>
<p>每个结构体都允许拥有多个 impl 块。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Point` 的关联函数都放在下面的 `impl` 语句块中</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数的使用方法跟构造器非常类似</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">origin</span>() <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: <span class="number">0.0</span>, y: <span class="number">0.0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另外一个关联函数，有两个参数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: x, y: y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    p1: Point,</span><br><span class="line">    p2: Point,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个方法</span></span><br><span class="line">    <span class="comment">// `&amp;self` 是 `self: &amp;Self` 的语法糖</span></span><br><span class="line">    <span class="comment">// `Self` 是当前调用对象的类型，对于本例来说 `Self` = `Rectangle`</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="comment">// 使用点操作符可以访问 `self` 中的结构体字段</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x1, y: y1 &#125; = <span class="keyword">self</span>.p1;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x2, y: y2 &#125; = <span class="keyword">self</span>.p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// `abs` 是一个 `f64` 类型的方法，会返回调用者的绝对值</span></span><br><span class="line">        ((x1 - x2) * (y1 - y2)).<span class="title function_ invoke__">abs</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">perimeter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x1, y: y1 &#125; = <span class="keyword">self</span>.p1;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x2, y: y2 &#125; = <span class="keyword">self</span>.p2;</span><br><span class="line"></span><br><span class="line">        <span class="number">2.0</span> * ((x1 - x2).<span class="title function_ invoke__">abs</span>() + (y1 - y2).<span class="title function_ invoke__">abs</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法要求调用者是可变的，`&amp;mut self` 是 `self: &amp;mut Self` 的语法糖</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">translate</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="type">f64</span>, y: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.p1.x += x;</span><br><span class="line">        <span class="keyword">self</span>.p2.x += x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.p1.y += y;</span><br><span class="line">        <span class="keyword">self</span>.p2.y += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Pair` 持有两个分配在堆上的整数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>(<span class="type">Box</span>&lt;<span class="type">i32</span>&gt;, <span class="type">Box</span>&lt;<span class="type">i32</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法会拿走调用者的所有权</span></span><br><span class="line">    <span class="comment">// `self` 是 `self: Self` 的语法糖</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">destroy</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Pair</span>(first, second) = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Destroying Pair(&#123;&#125;, &#123;&#125;)&quot;</span>, first, second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `first` 和 `second` 在这里超出作用域并被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rectangle</span> = Rectangle &#123;</span><br><span class="line">        <span class="comment">// 关联函数的调用不是通过点操作符，而是使用 `::`</span></span><br><span class="line">        p1: Point::<span class="title function_ invoke__">origin</span>(),</span><br><span class="line">        p2: Point::<span class="title function_ invoke__">new</span>(<span class="number">3.0</span>, <span class="number">4.0</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法才是通过点操作符调用</span></span><br><span class="line">    <span class="comment">// 注意，这里的方法需要的是 `&amp;self` 但是我们并没有使用 `(&amp;rectangle).perimeter()` 来调用，原因在于：</span></span><br><span class="line">    <span class="comment">// 编译器会帮我们自动取引用</span></span><br><span class="line">    <span class="comment">//  `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Rectangle perimeter: &#123;&#125;&quot;</span>, rectangle.<span class="title function_ invoke__">perimeter</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Rectangle area: &#123;&#125;&quot;</span>, rectangle.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">square</span> = Rectangle &#123;</span><br><span class="line">        p1: Point::<span class="title function_ invoke__">origin</span>(),</span><br><span class="line">        p2: Point::<span class="title function_ invoke__">new</span>(<span class="number">1.0</span>, <span class="number">1.0</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！`rectangle` 是不可变的，但是这个方法要求一个可变的对象</span></span><br><span class="line">    <span class="comment">//rectangle.translate(1.0, 0.0);</span></span><br><span class="line">    <span class="comment">// TODO ^ 试着反注释此行，看看会发生什么</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以！可变对象可以调用可变的方法</span></span><br><span class="line">    square.<span class="title function_ invoke__">translate</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = <span class="title function_ invoke__">Pair</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    pair.<span class="title function_ invoke__">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! 上一个 `destroy` 调用拿走了 `pair` 的所有权</span></span><br><span class="line">    <span class="comment">//pair.destroy();</span></span><br><span class="line">    <span class="comment">// TODO ^ 试着反注释此行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在代码中定义一个 IpAddrKind 枚举来表现这个概念并列出可能的 IP 地址类型，V4 和 V6。这被称为枚举的 <strong>成员</strong>（<em>variants</em>）：</p>
<p>在创建枚举时，你可以使用显式的<strong>整数</strong>设定枚举成员的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    Zero,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Number1</span> &#123;</span><br><span class="line">    Zero = <span class="number">0</span>,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，不能用小数</span></span><br><span class="line"><span class="comment">//enum Number2 &#123;</span></span><br><span class="line"><span class="comment">//    Zero = 0.0,</span></span><br><span class="line"><span class="comment">//    One = 1.0,</span></span><br><span class="line"><span class="comment">//    Two = 2.0,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C-like enum</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    Zero = <span class="number">0</span>,</span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    Two = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过 `as` 可以将枚举值强转为整数类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(Number::One <span class="keyword">as</span> <span class="type">u8</span>, Number1::One <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Number1::One <span class="keyword">as</span> <span class="type">u8</span>, Number2::One <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>可以像这样创建 IpAddrKind 两个不同成员的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br></pre></td></tr></table></figure>
<p>枚举成员中的值可以使用模式匹配来获取</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Move&#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Message</span>::Move&#123;x:a,y: b&#125; = msg &#123;</span><br><span class="line">    <span class="comment">// 也可以写成</span></span><br><span class="line">    <span class="comment">// if let Message::Move&#123;x, y&#125; = msg &#123;</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(a, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;不要让这行代码运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将数据附加到枚举的变体中"><a href="#将数据附加到枚举的变体中" class="headerlink" title="将数据附加到枚举的变体中"></a>将数据附加到枚举的变体中</h2><p>使用 struct</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">       V4,</span><br><span class="line">       V6,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">       kind: IpAddrKind,</span><br><span class="line">       address: <span class="type">String</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">       kind: IpAddrKind::V4,</span><br><span class="line">       address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr &#123;</span><br><span class="line">       kind: IpAddrKind::V6,</span><br><span class="line">       address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。IpAddr 枚举的新定义表明了 V4 和 V6 成员都关联了 String 值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">       <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">       <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>我们<strong>直接将数据附加到枚举的每个成员上</strong>，这样就不需要一个额外的结构体了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">       <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">       <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>注意虽然标准库中包含一个 IpAddr 的定义，仍然可以创建和使用我们自己的定义而不会有冲突，因为我们并没有将标准库中的定义引入作用域。</p>
<p>枚举可以嵌入多种类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Quit 没有关联任何数据。</li>
<li>Move 类似结构体包含命名字段。</li>
<li>Write 包含单独一个 String。</li>
<li>ChangeColor 包含三个 i32。</li>
</ul>
<h2 id="枚举中定义函数"><a href="#枚举中定义函数" class="headerlink" title="枚举中定义函数"></a>枚举中定义函数</h2><p>结构体和枚举还有另一个相似点：就像<strong>可以使用 impl 来为结构体定义方法那样，也可以在枚举上定义方法</strong>。这是一个定义于我们 Message 枚举上的叫做 call 的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">       <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">           <span class="comment">// 在这里定义方法体</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">   m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure>
<p>方法体使用了 self 来获取调用方法的值。这个例子中，创建了一个值为 Message::Write(String::from(“hello”)) 的变量 m，而且这就是当 m.call() 运行时 call 方法中的 self 的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TrafficLightColor</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Yellow,</span><br><span class="line">    Green,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement TrafficLightColor with a method</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TrafficLightColor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">color</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            TrafficLightColor::Red =&gt; <span class="string">&quot;red&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            TrafficLightColor::Yellow =&gt; <span class="string">&quot;yellow&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            TrafficLightColor::Green =&gt; <span class="string">&quot;green&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = TrafficLightColor::Yellow;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(c.<span class="title function_ invoke__">color</span>(), <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option 枚举</h2><p><strong>定义于标准库中，在 prelude(预导入模块中)</strong></p>
<p><strong>Rust 没有 Null</strong>，提供了类似于 Null 概念的枚举-Option<T>,它定义于标准库中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>
<p>当有一个 Some 值时，我们就知道存在一个值，而这个值保存在 Some 中。当有个 None 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，Option<T> 为什么就比空值要好呢？</p>
<p>简而言之，因为 Option<T> 和 T（这里 T 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 Option<T>。例如，这段代码不能编译，因为它尝试将 Option<i8> 与 i8 相加：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br></pre></td></tr></table></figure>
<p>事实上，错误信息意味着 Rust 不知道该如何将 Option<i8> 与 i8 相加，因为它们的类型不同。当在 Rust 中拥有一个像 i8 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 Option<i8>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 Option<T> 进行 T 的运算之前必须将其转换为 T。</p>
<p>为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 Option<T> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 Option<T> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。</p>
<p>这是 Rust 的一个经过深思熟虑的设计决策，来<strong>限制空值的泛滥</strong>以增加 Rust 代码的安全性。</p>
<h2 id="枚举实现链表"><a href="#枚举实现链表" class="headerlink" title="枚举实现链表"></a>枚举实现链表</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="comment">// Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针</span></span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">u32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    <span class="comment">// Nil: 链表中的最后一个节点，用于说明链表的结束</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为枚举实现一些方法</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="comment">// 创建空的链表</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> List &#123;</span><br><span class="line">        <span class="comment">// 因为没有节点，所以直接返回 Nil 节点</span></span><br><span class="line">        <span class="comment">// 枚举成员 Nil 的类型是 List</span></span><br><span class="line">        Nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在老的链表前面新增一个节点，并返回新的链表</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">prepend</span>(<span class="keyword">self</span>, elem: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> List &#123;</span><br><span class="line">        <span class="title function_ invoke__">Cons</span>(elem, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的长度</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">len</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// 这里我们不能拿走 tail 的所有权，因此需要获取它的引用，递归计算</span></span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_,<span class="keyword">ref</span> tail) =&gt; <span class="number">1</span> + tail.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            <span class="comment">// 空链表的长度为 0</span></span><br><span class="line">            Nil =&gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的字符串表现形式，用于打印输出</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stringify</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(head, <span class="keyword">ref</span> tail) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 递归生成字符串</span></span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, head, tail.<span class="title function_ invoke__">stringify</span>())</span><br><span class="line">            &#125;,</span><br><span class="line">            Nil =&gt; &#123;</span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;Nil&quot;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的链表(也是空的)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = List::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一些元素</span></span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">1</span>);</span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">2</span>);</span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印列表的当前状态</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;链表的长度是: &#123;&#125;&quot;</span>, list.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, list.<span class="title function_ invoke__">stringify</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><h2 id="match-控制流结构"><a href="#match-控制流结构" class="headerlink" title="match 控制流结构"></a>match 控制流结构</h2><p>Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将<strong>一个值</strong>与<strong>一系列的模式</strong>相比较，并根据相匹配的模式执行相应代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="matches"><a href="#matches" class="headerlink" title="matches!"></a>matches!</h3><p>matches!看起来像 match, 但是它可以做一些特别的事情</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">alphabets</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;9&#x27;</span> , <span class="string">&#x27;Y&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the blank with `matches!` to make the code work</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ab</span> <span class="keyword">in</span> alphabets &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(matches!(ab, <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> | <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码会报错，原因是枚举默认没有实现 PartialEq，所以不能用==比较</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="keyword">if</span> e == MyEnum::Foo &#123; <span class="comment">// 修复错误，只能修改本行代码</span></span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(count, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">Compiling demo v0.<span class="number">1.0</span> (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">error[E0369]: binary operation `==` cannot be applied to <span class="keyword">type</span> `MyEnum`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">13</span>:<span class="number">14</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |         <span class="keyword">if</span> e == MyEnum::Foo &#123; <span class="comment">// 修复错误，只能修改本行代码</span></span><br><span class="line">   |            - ^^ ----------- MyEnum</span><br><span class="line">   |            |</span><br><span class="line">   |            MyEnum</span><br><span class="line">   |</span><br><span class="line">note: an implementation of `<span class="built_in">PartialEq</span>&lt;_&gt;` might be missing <span class="keyword">for</span> `MyEnum`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">3</span>:<span class="number">1</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">3</span>  | <span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">   | ^^^^^^^^^^^ must implement `<span class="built_in">PartialEq</span>&lt;_&gt;`</span><br><span class="line">help: consider annotating `MyEnum` with `<span class="meta">#[derive(PartialEq)]</span>`</span><br><span class="line">   |</span><br><span class="line"><span class="number">3</span>  | <span class="meta">#[derive(PartialEq)]</span></span><br><span class="line">   |</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `demo` due to previous error</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="keyword">if</span> matches!(e, MyEnum::Foo) &#123; <span class="comment">// 修复错误，只能修改本行代码</span></span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(count, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h3><p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 这样可以立刻看到州的名称</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>= Coin::<span class="title function_ invoke__">Quarter</span>(UsState::Alaska);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">value_in_cents</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a>匹配 Option<T></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">     <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">     &#125;</span><br><span class="line">&#125;<span class="comment">//它获取一个 Option&lt;i32&gt; ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 None 值，而不尝试执行任何操作。</span></span><br></pre></td></tr></table></figure>
<h3 id="match-匹配必须穷举所有的可能性"><a href="#match-匹配必须穷举所有的可能性" class="headerlink" title="match 匹配必须穷举所有的可能性"></a>match 匹配必须穷举所有的可能性</h3><p>使用<strong>_占位符</strong>(必须放到最后面)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if-let-简洁控制流"><a href="#if-let-简洁控制流" class="headerlink" title="if let 简洁控制流"></a>if let 简洁控制流</h2><p>处理只关心一种模式匹配而忽略其它匹配的情况</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">      <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max),</span><br><span class="line">      _ =&gt; (),</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用 if let</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，模式是 Some(max)，max 绑定为 Some 中的值。接着可以在 if let 代码块中使用 max 了，就跟在对应的 match 分支中一样。模式不匹配时 if let 块中的代码不会执行。</p>
<p>放弃了穷举的可能性</p>
<p><strong>可以把 if let 看作是 match 的语法糖</strong></p>
<p><strong>搭配 else 使用</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       count += <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="模式匹配中的变量遮蔽"><a href="#模式匹配中的变量遮蔽" class="headerlink" title="模式匹配中的变量遮蔽"></a>模式匹配中的变量遮蔽</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="title function_ invoke__">Some</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(age) = age &#123; <span class="comment">// 创建一个新的变量，该变量与之前的 `age` 变量同名</span></span><br><span class="line">       <span class="built_in">assert_eq!</span>(age, <span class="number">30</span>);</span><br><span class="line">    &#125; <span class="comment">// 新的 `age` 变量在这里超出作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> age &#123;</span><br><span class="line">        <span class="comment">// `match` 也能实现变量遮蔽</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(age) =&gt;  <span class="built_in">println!</span>(<span class="string">&quot;age 是一个新的变量，它的值是 &#123;&#125;&quot;</span>,age),</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//age 是一个新的变量，它的值是 30</span></span><br></pre></td></tr></table></figure>
<h1 id="Workspace-Package-Crate-Module"><a href="#Workspace-Package-Crate-Module" class="headerlink" title="Workspace, Package,Crate,Module"></a>Workspace, Package,Crate,Module</h1><ul>
<li><strong>包</strong>（<em>Packages</em>）： Cargo 的一个功能，它允许你构建、测试和分享 crate。</li>
<li><strong>Crate</strong> ：一个模块的树形结构，它形成了库或二进制项目。</li>
<li><strong>模块</strong>（<em>Modules</em>）和 <strong>use</strong>： 允许你控制作用域和路径的私有性。</li>
<li><strong>路径</strong>（<em>path</em>）：一个命名例如结构体、函数或模块等项的方式</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>层级</th>
<th>名称</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>📦 <strong>Package</strong></td>
<td>“包”，Cargo 管理的单位（一个项目）</td>
<td>包含一个或多个 crate，以及 <code>Cargo.toml</code></td>
<td>整个项目目录</td>
</tr>
<tr>
<td>🧩 <strong>Crate</strong></td>
<td>“单个编译单元”，可以是库或可执行程序</td>
<td>每次 <code>rustc</code> 编译的就是一个 crate</td>
<td><code>src/lib.rs</code> 或 <code>src/main.rs</code></td>
</tr>
<tr>
<td>📁 <strong>Module</strong></td>
<td>模块，组织 crate 内部代码的结构</td>
<td>类似 C++ 的命名空间或 Python 的模块</td>
<td><code>mod network;</code></td>
</tr>
<tr>
<td>🛣️ <strong>Path</strong></td>
<td>用来访问模块、结构体、函数的路径</td>
<td>类似 <code>std::io::Write</code></td>
<td><code>crate::foo::bar()</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Crate 的类型</strong></p>
<ul>
<li><strong>binary</strong></li>
<li><strong>library</strong></li>
</ul>
<p>每个 crate 是一个独立的编译单元。<br>Rust 编译器一次只编译一个 crate。</p>
<p><strong>Crate Root</strong></p>
<p>是源代码文件，Rust 编译器从这里开始，组成 Crate 的根 Module。<br>Crate Root 是 <strong>Rust 编译器构建 crate 时的起点文件</strong>，<br>它决定了 <strong>模块树（module tree）</strong> 的最顶层结构。</p>
<hr>
<p><strong>举个例子</strong></p>
<p>假设我们有一个最简单的项目：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br><span class="line">├── Cargo<span class="selector-class">.toml</span></span><br><span class="line">└── <span class="attribute">src</span>/</span><br><span class="line">    ├── <span class="selector-tag">main</span><span class="selector-class">.rs</span></span><br><span class="line">    └── lib.rs</span><br></pre></td></tr></table></figure>
<p>这两个文件都是 <strong>可能的 crate root</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件</th>
<th>crate 类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>src/main.rs</code></td>
<td>binary crate root</td>
<td>程序入口点（必须包含 <code>fn main()</code>）</td>
</tr>
<tr>
<td><code>src/lib.rs</code></td>
<td>library crate root</td>
<td>库的入口点（定义库的模块结构）</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>编译器的工作逻辑</strong></p>
<p>当运行<code>cargo build</code>时：</p>
<p>Cargo 会：</p>
<ol>
<li>读取 <code>Cargo.toml</code>；</li>
<li>找到当前 package 里的 <strong>crate roots</strong>（例如 <code>src/main.rs</code>、<code>src/lib.rs</code>）；</li>
<li>对每个 crate root 调用编译器，从这个文件开始构建整个 crate 的模块树。</li>
</ol>
<p><strong>一个 Package</strong></p>
<ul>
<li>包含 1 个 Cargo.toml，它描述了如何构建这些 Crates</li>
<li><strong>只能包含 0-1 个 library crate</strong></li>
<li><strong>可以包含任意数量的 binary crate</strong></li>
<li>但必须<strong>至少包含一个 crate</strong>（library 或者 binary)</li>
</ul>
<p>举例：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_package<span class="symbol">/</span></span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src<span class="symbol">/</span></span><br><span class="line">│   ├── lib.rs          <span class="comment"># library crate</span></span><br><span class="line">│   ├── main.rs         <span class="comment"># 主 binary crate</span></span><br><span class="line">│   └── bin<span class="symbol">/</span></span><br><span class="line">│       ├── tool1.rs    <span class="comment"># 第二个 binary crate</span></span><br><span class="line">│       └── tool2.rs    <span class="comment"># 第三个 binary crate</span></span><br></pre></td></tr></table></figure>
<p>在 Cargo.toml 里无需特别配置。运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.rs</span></span><br><span class="line">cargo run</span><br><span class="line"><span class="comment"># tool1.rs</span></span><br><span class="line">cargo run --bin tool1</span><br><span class="line"><span class="comment"># tool2.rs</span></span><br><span class="line">cargo run --bin tool1</span><br></pre></td></tr></table></figure>
<p><strong>workspace</strong></p>
<p>workspace 是多个 package 的集合，每个 package 都可以有自己的 library crate。如下例子：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_workspace<span class="symbol">/</span></span><br><span class="line">├── Cargo.toml          <span class="comment"># workspace 声明</span></span><br><span class="line">├── app<span class="symbol">/</span>                <span class="comment"># 一个 binary crate package</span></span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src<span class="symbol">/main.rs</span></span><br><span class="line">├── utils<span class="symbol">/</span>              <span class="comment"># 一个 library crate package</span></span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src<span class="symbol">/lib.rs</span></span><br><span class="line">└── network<span class="symbol">/</span>            <span class="comment"># 另一个 library crate package</span></span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src<span class="symbol">/lib.rs</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>workspace 声明的 toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [<span class="string">&quot;app&quot;</span>, <span class="string">&quot;utils&quot;</span>, <span class="string">&quot;network&quot;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Cargo-的惯例"><a href="#Cargo-的惯例" class="headerlink" title="Cargo 的惯例"></a>Cargo 的惯例</h2><p>src/main.rs</p>
<ul>
<li>binary crate 的 crate root</li>
<li><strong>crate 名与 package 名相同</strong></li>
</ul>
<p>src/lib.rs</p>
<ul>
<li>package 包含一个 Library crate</li>
<li>library crate 的 crate root</li>
<li>crate 名与 package 名相同</li>
</ul>
<p>一个 package 可以同时包含 src/main.rs 和 src/lib.rs</p>
<p>一个 Package 可以有多个 binary crate：</p>
<p>文件放在 src/bin 下，每个文件都是单独的 binary crate</p>
<h2 id="定义-module-来控制作用域和私有性"><a href="#定义-module-来控制作用域和私有性" class="headerlink" title="定义 module 来控制作用域和私有性"></a>定义 module 来控制作用域和私有性</h2><p><strong>Module</strong></p>
<ul>
<li>在一个 crate 内，将 crate 进行分组</li>
<li>控制项目（item) 的私有性,public,private</li>
</ul>
<p><strong>建立 module</strong></p>
<ul>
<li>mod 关键字</li>
<li>可嵌套</li>
<li>可包含其他项的定义(struct,enum,常量,trait，函数等)的定义</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的模块树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>
<p>src/main.rs 和 src/lib.rs 叫做 crate roots</p>
<ul>
<li>这两个文件(任意一个)的内容形成了名为 crate 的模块，位于整个模块树的根部</li>
<li>整个模块树在隐式的 crate 模块下</li>
</ul>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>为了在 Rust 的模块中找到某个条目，需要使用<strong>路径</strong></p>
<ul>
<li><strong>绝对路径</strong>从 crate root 开始，使用 crate 名或字面值 crate</li>
<li><strong>相对路径</strong>从当前模块开始，使用 self，super 或当前模块的标识符</li>
</ul>
<p>路径至少由一个标识符组成，标识符之间使用::</p>
<p>src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;<span class="comment">//共有的</span></span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="私有边界（privacy-boundary"><a href="#私有边界（privacy-boundary" class="headerlink" title="私有边界（privacy boundary)"></a>私有边界（privacy boundary)</h2><ul>
<li>Rust 的所有条目(函数，方法，struct,enum,模块,常量) <strong>默认都是私有的</strong></li>
<li><strong>父级模块无法访问所有子模块的私有条目</strong></li>
<li>子模块里可以使用<strong>所有</strong>祖先模块中的条目</li>
<li><strong>同级模块</strong>可以<strong>互相调用</strong></li>
<li><strong>pub 关键字可以标记为公共的</strong></li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super:用来访问父级模块路径中的内容，类似于文件系统中的..</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pub-struct"><a href="#pub-struct" class="headerlink" title="pub struct"></a>pub struct</h2><p><strong>pub 放在 struct 前</strong>：</p>
<ul>
<li>struct 是公共的</li>
<li><strong>struct 的字段默认是私有的</strong>，<strong>字段前面加 pub 就可以设为公有的</strong></li>
</ul>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 在夏天订购一个黑麦土司作为早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// 改变主意更换想要面包的类型</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果取消下一行的注释代码不能编译；</span></span><br><span class="line">    <span class="comment">// 不允许查看或修改早餐附带的季节水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pub-enum"><a href="#pub-enum" class="headerlink" title="pub enum"></a>pub enum</h2><p>把 pub 放在 enum 前：</p>
<ul>
<li>enum 是公共的</li>
<li><strong>enum 的变体默认也都是公共的（不需要加 pub 关键字)</strong></li>
</ul>
<h2 id="use-关键字"><a href="#use-关键字" class="headerlink" title="use 关键字"></a>use 关键字</h2><p>使用 use 关键字将路径引入作用域</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>仍然遵循私有性规则</li>
<li>使用 use 来指定相对路径</li>
</ul>
<h2 id="use-的习惯用法"><a href="#use-的习惯用法" class="headerlink" title="use 的习惯用法"></a>use 的习惯用法</h2><ul>
<li>函数:将函数的父级模块引入到作用域(指定到父级)</li>
</ul>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> self::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>struct,enum,其他:指定完整路径(指定到本身)</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个具有相同名称的项带入作用域</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-as-关键字提供新的名称"><a href="#使用-as-关键字提供新的名称" class="headerlink" title="使用 as 关键字提供新的名称"></a>使用 as 关键字提供新的名称</h2><p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pub-use-重导出"><a href="#pub-use-重导出" class="headerlink" title="pub use 重导出"></a>pub use 重导出</h2><p>使用 use 将路径（名称）导入到作用域内后，<strong>该名称在此作用域内是私有的</strong></p>
<p>如果你希望 <strong>外部模块也能通过你的路径访问</strong> 那个条目（比如函数、结构体、模块等），就可以用 pub use，re-export 重导出</p>
<p>pub use：重导出</p>
<ul>
<li>将条目引入到作用域</li>
<li>该条目可以被<strong>外部代码</strong>引入到它们的作用域</li>
</ul>
<h2 id="pub-in-Crate"><a href="#pub-in-Crate" class="headerlink" title="pub(in Crate)"></a>pub(in Crate)</h2><p>有时我们希望某一个项只对特定的包可见，那么就可以使用 pub(in Crate) 语法.</p>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> a &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> I: <span class="type">i32</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">semisecret</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> self::b::c::J;</span><br><span class="line">        x + J</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bar</span>(z: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">semisecret</span>(I) * z</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">foo</span>(y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">semisecret</span>(I) + y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> b &#123;</span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::a) <span class="keyword">mod</span> c &#123;</span><br><span class="line">            <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::a) <span class="keyword">const</span> J: <span class="type">i32</span> = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用外部包-package"><a href="#使用外部包-package" class="headerlink" title="使用外部包(package)"></a>使用外部包(package)</h2><p>1.Cargo.toml 添加依赖的包</p>
<p>2.use 将特定条目引入到作用域</p>
<ul>
<li>标准库 std 也被当做外部包，但是不需要修改 Cargo.toml 来包含 std</li>
<li>需要使用 use 将 std 中的特定条目引入当前作用域</li>
</ul>
<h2 id="使用嵌套路径清理大量的-use-语句"><a href="#使用嵌套路径清理大量的-use-语句" class="headerlink" title="使用嵌套路径清理大量的 use 语句"></a>使用嵌套路径清理大量的 use 语句</h2><p><strong>路径相同的部分::{路径差异的部分}</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering,io&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br></pre></td></tr></table></figure>
<p>如果两个 use 路径之一是另一个的子路径</p>
<p>使用 self</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use std::io;</span></span><br><span class="line"><span class="comment">//use std::io::Write;</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>,Write&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符*"></a>通配符*</h2><p>使用*可以把路径中所有的公共条目都引入到作用域</p>
<p>谨慎使用</p>
<p>应用场景：</p>
<ul>
<li>prelude</li>
<li>测试，将所有被测试代码引入到 tests 模块</li>
</ul>
<h2 id="将模块拆分为不同的文件"><a href="#将模块拆分为不同的文件" class="headerlink" title="将模块拆分为不同的文件"></a>将模块拆分为不同的文件</h2><p>模块定义时，如果模块名后面时”;”，而不是代码块</p>
<ul>
<li><strong>Rust 会从模块同名的文件中加载内容</strong></li>
<li><strong>模块树不会发生变化</strong></li>
</ul>
<p>示例:</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 ：声明 front<em>of_house 模块，其内容将位于 _src/front_of_house.rs</em></p>
<p><em>src/front_of_house.rs</em> 会获取 front_of_house 模块的定义内容，如示例所示。</p>
<p>文件名: src/front_of_house.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p><strong>定义模块 <code>front_of_house</code></strong></p>
<p><strong>方式一</strong>：直接在文件中写模块内容</p>
<p>文件：<code>src/front_of_house.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>front_of_house</code> 模块直接定义了子模块 <code>hosting</code>。</li>
<li>好处：简单，模块小的时候可以这样写。</li>
</ul>
<hr>
<p><strong>方式二</strong>：把子模块拆到单独文件</p>
<ol>
<li>在 <code>front_of_house.rs</code> 中只声明子模块：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建目录和文件结构：</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">src</span>/</span><br><span class="line">├── lib<span class="selector-class">.rs</span></span><br><span class="line">├── front_of_house<span class="selector-class">.rs</span>      ← front_of_house 模块的主体</span><br><span class="line">└── front_of_house/        ← front_of_house 的子模块目录</span><br><span class="line">    └── hosting<span class="selector-class">.rs</span>         ← 子模块 hosting 的实现</span><br></pre></td></tr></table></figure>
<ol>
<li>在 <code>hosting.rs</code> 中写实际内容：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这时 <code>hosting</code> 的内容完全放到 <code>hosting.rs</code>。</li>
<li>好处：模块大时，拆开文件更清晰、可维护。</li>
</ul>
<p><strong>传统风格</strong></p>
<p>Rust Edition 2018 前，使用下面这种风格</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">src</span>/</span><br><span class="line">└── front_of_house/</span><br><span class="line">    ├── mod<span class="selector-class">.rs</span>       <span class="comment">// front_of_house 模块本体</span></span><br><span class="line">    └── hosting<span class="selector-class">.rs</span>   <span class="comment">// front_of_house 的子模块</span></span><br></pre></td></tr></table></figure>
<h1 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vec<T> 叫做 vector</p>
<h3 id="创建-vector"><a href="#创建-vector" class="headerlink" title="创建 vector"></a>创建 vector</h3><p><strong>Vec::new 函数</strong></p>
<p>let v:Vec<i32>=Vec::new();</p>
<p>使用初始值创建 Vec<T>,使用<strong>vec!</strong>宏</p>
<p>let v = vec![1,2,3];</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(arr);</span><br><span class="line">   <span class="title function_ invoke__">is_vec</span>(v);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">   <span class="title function_ invoke__">is_vec</span>(v);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// vec!(..) 和 vec![..] 是同样的宏，宏可以使用 []、()、&#123;&#125;三种形式，因此...</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="title function_ invoke__">is_vec</span>(v);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...在下面的代码中, v 是 Vec&lt;[u8; 3]&gt; , 而不是 Vec&lt;u8&gt;</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>(arr);</span><br></pre></td></tr></table></figure>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>:<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;=<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="删除-Vector"><a href="#删除-Vector" class="headerlink" title="删除 Vector"></a>删除 Vector</h3><p>类似于任何其他的 struct，vector 在其离开作用域时会被释放</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理变量 v</span></span><br><span class="line">&#125; <span class="comment">// &lt;- 这里 v 离开作用域并被丢弃</span></span><br></pre></td></tr></table></figure>
<h3 id="读取-Vector-中的值"><a href="#读取-Vector-中的值" class="headerlink" title="读取 Vector 中的值"></a>读取 Vector 中的值</h3><ul>
<li>索引方式</li>
<li>get 方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用索引方法访问超出数组元素的值时，程序会 panic</strong></li>
<li><strong>而使用 get 方法访问时程序会返回一个 None</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v.<span class="title function_ invoke__">get</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = v.<span class="title function_ invoke__">get</span>(i) &#123;</span><br><span class="line">            v[i] = x + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v.<span class="title function_ invoke__">push</span>(i + <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v), <span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用借用规则"><a href="#引用借用规则" class="headerlink" title="引用借用规则"></a>引用借用规则</h3><p>当我们获取了 vector 的第一个元素的不可变引用并尝试在 vector 末尾增加一个元素的时候，如果尝试在函数的后面引用这个元素是行不通的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];<span class="comment">//不可变的借用</span></span><br><span class="line"></span><br><span class="line">   v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);<span class="comment">//可变的借用</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;&#125;&quot;</span>, first);<span class="comment">//不可变的借用</span></span><br></pre></td></tr></table></figure>
<p>为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，<strong>可能会要求分配新内存并将老的元素拷贝到新的空间中</strong>。这时，<strong>第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况</strong>。</p>
<h3 id="遍历-Vector"><a href="#遍历-Vector" class="headerlink" title="遍历 Vector"></a>遍历 Vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">   <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">       *i += <span class="number">50</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>为了修改可变引用所指向的值，在使用 += 运算符之前必须使用解引用运算符（*）获取 i 中的值。</p>
<h3 id="扩展-Vector"><a href="#扩展-Vector" class="headerlink" title="扩展 Vector"></a>扩展 Vector</h3><p>Vec 可以使用 extend 方法进行扩展</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">    v1.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    v1.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// v1 is [1,2,3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v2.<span class="title function_ invoke__">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// v2 is [1,2,3]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v1), <span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-enum-来使-Vec-存储多种数据类型"><a href="#使用-enum-来使-Vec-存储多种数据类型" class="headerlink" title="使用 enum 来使 Vec 存储多种数据类型"></a>使用 enum 来使 Vec 存储多种数据类型</h3><p>定义一个枚举，以便能在 vector 中存放不同类型的数据</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">       <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">       <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">       <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">       SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">       SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">       SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">   ];</span><br></pre></td></tr></table></figure>
<h3 id="使用特征对象来使-Vec-存储多种数据类型"><a href="#使用特征对象来使-Vec-存储多种数据类型" class="headerlink" title="使用特征对象来使 Vec 存储多种数据类型"></a>使用特征对象来使 Vec 存储多种数据类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V4</span>(<span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V4</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv4: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V6</span>(<span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V6</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv6: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> IpAddr&gt;&gt; = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        ip.<span class="title function_ invoke__">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将-X-类型转换-From-Into-特征-成-Vec"><a href="#将-X-类型转换-From-Into-特征-成-Vec" class="headerlink" title="将 X 类型转换(From/Into 特征)成 Vec"></a>将 X 类型转换(From/Into 特征)成 Vec</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// array -&gt; Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(arr);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = arr.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1, v2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// String -&gt; Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = s.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = s.<span class="title function_ invoke__">into_bytes</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1, v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v3</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(s);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, v3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>与 String 的切片类似， Vec 也可以使用切片。如果说 Vec 是可变的，那它的切片就是不可变或者说只读的，我们可以通过 &amp; 来获取切片。</p>
<p>在 Rust 中，<strong>将切片作为参数进行传递是更常见的使用方式</strong>，例如当一个函数只需要可读性时，那传递 Vec 或 String 的切片 &amp;[T] / &amp;str 会更加适合。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice1</span> = &amp;v[..];</span><br><span class="line">    <span class="comment">// 越界访问将导致 panic.</span></span><br><span class="line">    <span class="comment">// 修改时必须使用 `v.len`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice2</span> = &amp;v[<span class="number">0</span>..v.<span class="title function_ invoke__">len</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice1, slice2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切片是只读的</span></span><br><span class="line">    <span class="comment">// 注意：切片和 `&amp;Vec` 是不同的类型，后者仅仅是 `Vec` 的引用，并可以通过解引用直接获取 `Vec`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec_ref</span>: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = &amp;<span class="keyword">mut</span> v;</span><br><span class="line">    (*vec_ref).<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice3</span> = &amp;<span class="keyword">mut</span> v[<span class="number">0</span>..];</span><br><span class="line">    <span class="comment">// slice3.push(4);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice3, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p>容量 capacity 是已经分配好的内存空间，用于存储未来添加到 Vec 中的元素。而长度 len 则是当前 Vec 中已经存储的元素数量。如果要添加新元素时，长度将要超过已有的容量，那容量会自动进行增长：Rust 会重新分配一块更大的内存空间，然后将之前的 Vec 拷贝过去，因此，这里就会发生新的内存分配</p>
<p>若这段代码会频繁发生，那频繁的内存分配会大幅影响我们系统的性能，最好的办法就是提前分配好足够的容量，尽量减少内存分配。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">capacity</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于提前设置了足够的容量，这里的循环不会造成任何内存分配...</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        vec.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">capacity</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...但是下面的代码会造成新的内存分配</span></span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写一个合适的值，在 `for` 循环运行的过程中，不会造成任何内存分配</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">        vec.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">capacity</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要为 Vec 实现了 From<T> 特征，那么 T 就可以被转换成 Vec。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li>字符串是 Byte 的集合</li>
<li>UFT-8 编码</li>
<li>一些方法能将 byte 解析为文本</li>
</ul>
<h3 id="字符串是什么？"><a href="#字符串是什么？" class="headerlink" title="字符串是什么？"></a>字符串是什么？</h3><p>Rust 的核心语言层面，只有一个字符串类型:字符串切片 str（或者&amp;str）</p>
<ul>
<li>字符串切片:对存储在其它地方,UTF-8 编码的字符串引用</li>
<li>字符串的字面值：存储在二进制文件中，也是字符串切片</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, 世界&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice1</span> = &amp;s[<span class="number">0</span>..<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//提示: `h` 在 UTF-8 编码中只占用 1 个字节</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice1, <span class="string">&quot;h&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice2</span> = &amp;s[<span class="number">7</span>..<span class="number">10</span>];<span class="comment">// 提示: `中` 在 UTF-8 编码中占用 3 个字节</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice2, <span class="string">&quot;世&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 s 中的所有字符</span></span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">7</span> &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(c, <span class="string">&#x27;世&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上 String 是一个<strong>智能指针</strong>，它作为一个结构体存储在栈上，然后指向存储在堆上的字符串底层数据。</p>
<p>存储在栈上的智能指针结构体由三部分组成：一个指针只指向堆上的字节数组，已使用的长度以及已分配的容量 capacity (已使用的长度小于等于已分配的容量，当容量不够时，会重新分配内存空间)。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">story</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust By Practice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止 String 的数据被自动 drop</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">story</span> = mem::ManuallyDrop::<span class="title function_ invoke__">new</span>(story);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = story.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = story.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">capacity</span> = story.<span class="title function_ invoke__">capacity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">16</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以基于 ptr 指针、长度和容量来重新构建 String.</span></span><br><span class="line">    <span class="comment">// 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="keyword">unsafe</span> &#123; <span class="type">String</span>::<span class="title function_ invoke__">from_raw_parts</span>(ptr, len, capacity) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(*story, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它字符串类型"><a href="#其它字符串类型" class="headerlink" title="其它字符串类型"></a><strong>其它字符串类型</strong></h3><p><strong>String 类型</strong></p>
<p>来自标准库，也是 UTF-8 编码</p>
<p>String vs Str：拥有或借用的变体</p>
<p><strong>其他字符串类型</strong></p>
<p><strong>OsString</strong> / <strong>OsStr</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::OsString;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">os_string</span> = OsString::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    os_string.<span class="title function_ invoke__">push</span>(<span class="string">&quot; world&quot;</span>); <span class="comment">// 可变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要用于处理文件路径、命令行参数、环境变量等系统字符串。</p>
<p><strong>CString</strong> / <strong>CStr</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c_string</span> = CString::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;NUL found!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>来自 <code>std::ffi</code>，用于 <strong>与 C 语言接口交互</strong>。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>以 <strong>NUL 结尾</strong> (<code>\0</code>) 的字符串。</li>
<li><code>CString</code> 拥有数据，保证没有内部 NUL。</li>
<li><code>CStr</code> 是不可变借用，类似于 <code>&amp;str</code>。</li>
</ul>
<blockquote>
<p><code>CString</code> 没有提供类似 <code>push_str</code> 或索引访问的方法修改内容，一旦创建，就<strong>不能修改内部字节</strong>。</p>
</blockquote>
<h3 id="String-与-amp-str-的转换"><a href="#String-与-amp-str-的转换" class="headerlink" title="String 与&amp;str 的转换"></a>String 与&amp;str 的转换</h3><p><strong>使用 to_string()</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello, world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 String::from()</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 你可以使用转义的方式来输出想要的字符，这里我们使用十六进制的值，例如 \x73 会被转义成小写字母 &#x27;s&#x27;</span></span><br><span class="line">    <span class="comment">// 填空以输出 &quot;I&#x27;m writing Rust&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_escape</span> = <span class="string">&quot;I&#x27;m writing Ru\x73__!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;</span>, byte_escape);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用 Unicode 形式的转义字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unicode_codepoint</span> = <span class="string">&quot;\u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">character_name</span> = <span class="string">&quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;</span>,</span><br><span class="line">                unicode_codepoint, character_name );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还能使用 \ 来连接多行字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">long_string</span> = <span class="string">&quot;String literals</span></span><br><span class="line"><span class="string">                        can span multiple lines.</span></span><br><span class="line"><span class="string">                        The linebreak and indentation here \</span></span><br><span class="line"><span class="string">                         can be escaped too!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, long_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有时候需要转义的字符很多，我们会希望使用更方便的方式来书写字符串: raw string.</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_str</span> = <span class="string">r&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, raw_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字符串包含双引号，可以在开头和结尾加 #</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotes</span> = <span class="string">r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, quotes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是有歧义，可以继续增加，没有限制</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">longer_delimiter</span> = <span class="string">r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, longer_delimiter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_str</span> = <span class="string">&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(raw_str, <span class="string">&quot;Escapes don&#x27;t work here: ? ℝ&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you need quotes in a raw string, add a pair of #s</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotes</span> = <span class="string">r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, quotes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you need &quot;# in your string, just use more #s in the delimiter.</span></span><br><span class="line">    <span class="comment">// You can use up to 65535 #s.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">delimiter</span> = <span class="string">r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, delimiter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill the blank</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">long_delimiter</span> = <span class="string">r###&quot;Hello, &quot;##&quot;&quot;###</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(long_delimiter, <span class="string">&quot;Hello, \&quot;##\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 r#”标记一个原始字符串的开始，”#标记一个字符串的结束，如果还是有歧义可以继续加#</p>
<h3 id="创建一个新的-String"><a href="#创建一个新的-String" class="headerlink" title="创建一个新的 String"></a>创建一个新的 String</h3><p>String::new()</p>
<p>let mut s = String::new();</p>
<p>使用 to_string()</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;initial contents&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>
<p>也可以使用 string::from()</p>
<p>let s = String::from(“initial contents”);</p>
<h3 id="更新-String"><a href="#更新-String" class="headerlink" title="更新 String"></a>更新 String</h3><h4 id="push-str"><a href="#push-str" class="headerlink" title="push_str()"></a><strong>push_str()</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">   s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>push_str()方法不会获得参数的所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">   s1.<span class="title function_ invoke__">push_str</span>(s2);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">   s1.<span class="title function_ invoke__">push_str</span>(&amp;s2);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br></pre></td></tr></table></figure>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a><strong>push()</strong></h4><p>push 方法被定义为获取一个单独的字符作为参数，并附加到 String 中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">   s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="+连接字符串"></a><strong>+连接字符串</strong></h4><p><strong>只能将</strong> <strong>String</strong> <strong>跟</strong> <strong>&amp;str</strong> <strong>类型进行拼接，并且</strong> <strong>String</strong> <strong>的所有权在此过程中会被 move</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure>
<p>+ 运算符使用了 add 函数，这个函数签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure>
<p>这并不是标准库中实际的签名；</p>
<p>但是&amp;s2 的类型是 &amp;String 而不是 &amp;str。那么为什么还能编译呢</p>
<p>之所以能够在 add 调用中使用 &amp;s2 是因为 &amp;String 可以被 <strong>强转</strong>（<em>coerced</em>）成 &amp;str。当 add 函数被调用时，Rust 使用了一个被称为 <strong>Deref 强制转换</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 &amp;s2 变成了 &amp;s2[..]。</p>
<h4 id="format"><a href="#format" class="headerlink" title="format!"></a>format!</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2 + <span class="string">&quot;-&quot;</span> + &amp;s3;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure>
<p>宏 format! 生成的代码使用引用所以<strong>不会获取任何参数的所有权</strong></p>
<p><code>s1</code>, <code>s2</code>, <code>s3</code> 都是借用。</p>
<p>Rust 会 <strong>把内容复制到新字符串</strong>（堆上分配）：</p>
<ul>
<li>原来的字符串不受影响。</li>
<li>这里的复制是必需的，因为生成了新的独立字符串。</li>
</ul>
<h3 id="按索引的形式进行访问String"><a href="#按索引的形式进行访问String" class="headerlink" title="按索引的形式进行访问String"></a>按索引的形式进行访问<strong>String</strong></h3><p>Rust 的字符串<strong>不支持索引语法</strong>访问</p>
<p><strong>内部表现</strong></p>
<p>String 是一个 Vec<u8> 的封装。</p>
<p>let hello = String::from(“Hola”);</p>
<p>在这里，len 的值是 4 ，这意味着储存字符串 “Hola” 的 Vec 的长度是四个字节：这里每一个字母的 UTF-8 编码都占用一个字节。</p>
<p>（注意这个字符串中的首字母是西里尔字母的 Ze 而不是阿拉伯数字 3 。）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте” 所需要的字节数，这是因为每个 Unicode 标量值需要两个字节存储。</p>
<p><strong>因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值</strong></p>
<h3 id="字节字符串"><a href="#字节字符串" class="headerlink" title="字节字符串"></a>字节字符串</h3><p>字节字符串或者说字节数组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 注意，这并不是 `&amp;str` 类型了！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytestring</span>: &amp;[<span class="type">u8</span>; <span class="number">21</span>] = <span class="string">b&quot;this is a byte string&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组没有实现 `Display` 特征，因此只能使用 `Debug` 的方式去打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A byte string: &#123;:?&#125;&quot;</span>, bytestring);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组也可以使用转义</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">escaped</span> = <span class="string">b&quot;\x52\x75\x73\x74 as bytes&quot;</span>;</span><br><span class="line">    <span class="comment">// ...但是不支持 unicode 转义</span></span><br><span class="line">    <span class="comment">// let escaped = b&quot;\u&#123;211D&#125; is not allowed&quot;;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some escaped bytes: &#123;:?&#125;&quot;</span>, escaped);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// raw string</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_bytestring</span> = <span class="string">br&quot;\u&#123;211D&#125; is not escaped here&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, raw_bytestring);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节数组转成 `str` 类型可能会失败</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(my_str) = <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(raw_bytestring) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_quotes</span> = <span class="string">br#&quot;You can also use &quot;fancier&quot; formatting, \</span></span><br><span class="line"><span class="string">                    like with normal raw strings&quot;#</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组可以不是 UTF-8 格式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shift_jis</span> = <span class="string">b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;</span>; <span class="comment">// &quot;ようこそ&quot; in SHIFT-JIS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是它们未必能转换成 `str` 类型</span></span><br><span class="line">    <span class="keyword">match</span> <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(shift_jis) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(my_str) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion failed: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节-标量值-字型簇"><a href="#字节-标量值-字型簇" class="headerlink" title="字节,标量值,字型簇"></a>字节,标量值,字型簇</h3><p>Rust 有三种看待字符串的方式：</p>
<ul>
<li>字节 Byte</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="string">&quot;नमस्ते&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> w.<span class="title function_ invoke__">bytes</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">224</span><br><span class="line">164</span><br><span class="line">168</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">174</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">184</span><br><span class="line">224</span><br><span class="line">165</span><br><span class="line">141</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">164</span><br><span class="line">224</span><br><span class="line">165</span><br><span class="line">135</span><br></pre></td></tr></table></figure>
<ul>
<li>标量值 Scalar Values</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="string">&quot;नमस्ते&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> w.<span class="title function_ invoke__">chars</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure>
<ul>
<li>字形簇 Grapheme Clusters（最接近所谓的字母）</li>
</ul>
<p>获取比较复杂，标准库中已经不提供了。 需要借助第三方库。</p>
<div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div>
<blockquote>
<p>Rust 不允许对 String 进行索引的一个原因:</p>
<p>索引操作应该小号一个常量时间 O(1)</p>
<p>而 String 无法保证：需要遍历所有的内容，来确定有多少个合法的字符</p>
</blockquote>
<h3 id="切割-String"><a href="#切割-String" class="headerlink" title="切割 String"></a>切割 String</h3><p>字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。因此，如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，相比使用 [] 和单个值的索引，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>s 会是一个 &amp;str，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 s 将会是 “Зд”。</p>
<p>如果获取 &amp;hello[0..1] 会发生什么呢？答案是：Rust 在运行时会 panic</p>
<p>因此<strong>切割时不能跨越字符串边界</strong></p>
<h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><p>无法通过索引的方式去访问字符串中的某个字符，但是可以使用切片的方式 &amp;s1[start..end] ，但是 start 和 end 必须准确落在字符的边界处.</p>
<ul>
<li>对于标量值: chars()方法</li>
<li>对于字节: bytes()方法、</li>
<li>对于字形簇:很复杂，标准库未提供，中英文都不需要关注字符簇，利用 chars 就可以遍历中英文</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi,中国&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = &amp;s1[<span class="number">0</span>..<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(h, <span class="string">&quot;h&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h1</span> = &amp;s1[<span class="number">3</span>..<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(h1, <span class="string">&quot;中&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;你好，世界&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//你</span></span><br><span class="line"><span class="comment">//好</span></span><br><span class="line"><span class="comment">//，</span></span><br><span class="line"><span class="comment">//世</span></span><br><span class="line"><span class="comment">//界</span></span><br></pre></td></tr></table></figure>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 默认使用 SipHash 1-3 哈希算法，该算法对于抵抗 HashDos 攻击非常有效。在性能方面，如果你的 key 是中型大小的，那该算法非常不错，但是如果是小型的 key( 例如整数 )亦或是大型的 key ( 例如字符串 )，那你需要采用社区提供的其它算法来提高性能。</p>
<p>哈希表的算法是基于 Google 的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://abseil.io/blog/20180927-swisstables">SwissTable</a>，你可以在<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h">这里</a>找到 C++ 的实现。</p>
<h3 id="创建-HashMap"><a href="#创建-HashMap" class="headerlink" title="创建 HashMap"></a>创建 HashMap<K,V></h3><p><strong>创建空 HashMap:new()函数</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">//let mut scores:HashMap&lt;String,i32&gt; = HashMap::new();</span></span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>HashMap 用的较少，<strong>不在 Prelude 中</strong></li>
<li>标准库对其支持较少，<strong>没有内置的宏来创建 HashMap</strong></li>
<li>数据存在 heap 中</li>
<li>同构的，即 K 必须为一种类型，V 为另一种类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams</span> = [</span><br><span class="line">        (<span class="string">&quot;Chinese Team&quot;</span>, <span class="number">100</span>),</span><br><span class="line">        (<span class="string">&quot;American Team&quot;</span>, <span class="number">10</span>),</span><br><span class="line">        (<span class="string">&quot;France Team&quot;</span>, <span class="number">50</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">teams_map1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">team</span> <span class="keyword">in</span> &amp;teams &#123;</span><br><span class="line">        teams_map1.<span class="title function_ invoke__">insert</span>(team.<span class="number">0</span>, team.<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams_map2</span>: HashMap&lt;_,_&gt; = teams.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">// let teams_map2 = HashMap::from(teams);</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(teams_map1, teams_map2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>collect 方法创建 HashMap</strong></p>
<p>collect 方法可以将数据收集进一系列的集合类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;_, _&gt; =</span><br><span class="line">        teams.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>
<p>如果队伍的名字和初始分数分别在两个 vector 中，可以使用 <strong>zip</strong> 方法来<strong>创建一个元组的迭代器</strong>，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 collect 方法将这个元组的迭代器转换成一个 HashMap</p>
<h3 id="HashMap-和所有权"><a href="#HashMap-和所有权" class="headerlink" title="HashMap 和所有权"></a>HashMap 和所有权</h3><ul>
<li>对于实现了 Copy trait 的类型（如 i32)，值会被复制到 HashMap 中</li>
<li>对于拥有所有权的值（例如 String)，值会被移动，所有权会转移给 HashMap</li>
<li>如果把引用插入到 HashMap，值本身不会移动但是在 HashMap 有效的期间，被引用的值必须保持有效</li>
</ul>
<h3 id="访问-HashMap-中的值"><a href="#访问-HashMap-中的值" class="headerlink" title="访问 HashMap 中的值"></a>访问 HashMap 中的值</h3><p><strong>get 方法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br></pre></td></tr></table></figure>
<p><strong>for 循环遍历 HashMap</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这会以<strong>任意顺序</strong>打印出每一个键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yellow: 50</span><br><span class="line">Blue: 10</span><br></pre></td></tr></table></figure>
<p><strong>索引与 get 方法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Sunface&quot;</span>, <span class="number">98</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Daniel&quot;</span>, <span class="number">95</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Ashley&quot;</span>, <span class="number">69</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Katie&quot;</span>, <span class="number">58</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 返回一个 Option&lt;&amp;V&gt; 枚举值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(<span class="string">&quot;Sunface&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(score, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">98</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> scores.<span class="title function_ invoke__">contains_key</span>(<span class="string">&quot;Daniel&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引返回一个值 V</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">score</span> = scores[<span class="string">&quot;Daniel&quot;</span>];</span><br><span class="line">        <span class="built_in">assert_eq!</span>(score, <span class="number">95</span>);</span><br><span class="line">        scores.<span class="title function_ invoke__">remove</span>(<span class="string">&quot;Daniel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(scores.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (name, score) <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The score of &#123;&#125; is &#123;&#125;&quot;</span>, name, score)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新-HashMap"><a href="#更新-HashMap" class="headerlink" title="更新 HashMap"></a>更新 HashMap</h3><h4 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a>覆盖一个值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>
<p>这会打印出 {“Blue”: 25}。原始的值 10 则被覆盖了</p>
<h4 id="只在键没有对应值时插入"><a href="#只在键没有对应值时插入" class="headerlink" title="只在键没有对应值时插入"></a>只在键没有对应值时插入</h4><p>使用 entry 方法<strong>只在键没有对应一个值时插入</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">e</span>=scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>));</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,e);</span><br><span class="line">	e.<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Entry</span><span class="params">(VacantEntry(<span class="string">&quot;Yellow&quot;</span>)</span></span>)</span><br><span class="line">&#123;<span class="string">&quot;Blue&quot;</span>: <span class="number">10</span>, <span class="string">&quot;Yellow&quot;</span>: <span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>entry 方法</strong></p>
<p>检查指定的 K 是否对应一个 V</p>
<p>参数为 K,返回 enum Entry:代表值是否存在</p>
<p>Entry 的<strong>or_insert()方法</strong>:</p>
<p>返回:</p>
<ul>
<li>如果 K 存在，返回到对应的 V 的一个可变引用</li>
<li>如果 K 不存在，将方法参数作为 K 的新值插进去，返回到这个值的可变引用</li>
</ul>
<h4 id="根据旧值更新一个值"><a href="#根据旧值更新一个值" class="headerlink" title="根据旧值更新一个值"></a>根据旧值更新一个值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure>
<p>这里 or_insert 返回的是一个可变引用，指向刚 entry 方法插入的键对应的值</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>HashMap 默认使用一种叫做 SipHash 的哈希函数，它可以抵御涉及哈希表（hash table）<a target="_blank" rel="noopener external nofollow noreferrer" href="https://kaisery.github.io/trpl-zh-cn/ch08-03-hash-maps.html#siphash">1</a> 的拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 BuildHasher trait 的类型。我们并不需要从头开始实现你自己的 hasher；crates.io 上有许多常用哈希算法的 hasher 的库。</p>
<h3 id="HashMap-key-的限制"><a href="#HashMap-key-的限制" class="headerlink" title="HashMap key 的限制"></a>HashMap key 的限制</h3><p>任何实现了 Eq 和 Hash 特征的类型都可以用于 HashMap 的 key，包括:</p>
<ul>
<li>bool (虽然很少用到，因为它只能表达两种 key)</li>
<li>int, uint 以及它们的变体，例如 u8、i32 等</li>
<li>String 和 &amp;str (提示: HashMap 的 key 是 String 类型时，你其实可以使用 &amp;str 配合 get 方法进行查询</li>
</ul>
<p>需要注意的是，f32 和 f64 并没有实现 Hash，原因是 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">浮点数精度</a> 的问题会导致它们无法进行相等比较。</p>
<p>如果一个集合类型的所有字段都实现了 Eq 和 Hash,那该集合类型会自动实现 Eq 和 Hash。例如 Vec<T> 要实现 Hash，那么首先需要 T 实现 Hash。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提示: `derive` 是实现一些常用特征的好办法</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Hash, Eq, PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Viking</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    country: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Viking</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="type">str</span>, country: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Viking &#123;</span><br><span class="line">        Viking &#123;</span><br><span class="line">            name: name.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            country: country.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用 HashMap 来存储 viking 的生命值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vikings</span> = HashMap::<span class="title function_ invoke__">from</span>([</span><br><span class="line">        (Viking::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Einar&quot;</span>, <span class="string">&quot;Norway&quot;</span>), <span class="number">25</span>),</span><br><span class="line">        (Viking::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Olaf&quot;</span>, <span class="string">&quot;Denmark&quot;</span>), <span class="number">24</span>),</span><br><span class="line">        (Viking::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Harald&quot;</span>, <span class="string">&quot;Iceland&quot;</span>), <span class="number">12</span>),</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 derive 的方式来打印 viking 的当前状态</span></span><br><span class="line">    <span class="keyword">for</span> (viking, health) <span class="keyword">in</span> &amp;vikings &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; has &#123;&#125; hp&quot;</span>, viking, health);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容量-1"><a href="#容量-1" class="headerlink" title="容量"></a>容量</h3><p>关于容量，我们在之前的 Vector 中有详细的介绍，而 HashMap 也可以调整容量: 你可以通过 HashMap::with_capacity(uint) 使用指定的容量来初始化，或者使用 HashMap::new() ，后者会提供一个默认的初始化容量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">with_capacity</span>(<span class="number">100</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 事实上，虽然我们使用了 100 容量来初始化，但是 map 的容量很可能会比 100 更多</span></span><br><span class="line">    <span class="built_in">assert!</span>(map.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对容量进行收缩，你提供的值仅仅是一个允许的最小值，实际上，Rust 会根据当前存储的数据量进行自动设置，当然，这个值会尽量靠近你提供的值，同时还可能会预留一些调整空间</span></span><br><span class="line"></span><br><span class="line">    map.<span class="title function_ invoke__">shrink_to</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(map.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 Rust  自行调整到一个合适的值，剩余策略同上</span></span><br><span class="line">    map.<span class="title function_ invoke__">shrink_to_fit</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(map.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>对于实现了 Copy 特征的类型，例如 i32，那类型的值会被拷贝到 HashMap 中。而对于有所有权的类型，例如 String，它们的值的所有权将被转移到 HashMap 中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">  m1.<span class="title function_ invoke__">insert</span>(v1, v1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;</span>, v1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">v2</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m2</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">  <span class="comment">// 所有权在这里发生了转移</span></span><br><span class="line">  m2.<span class="title function_ invoke__">insert</span>(v2, v1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(v2, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三方-Hash-库"><a href="#第三方-Hash-库" class="headerlink" title="第三方 Hash 库"></a>第三方 Hash 库</h3><p>在开头，我们提到过如果现有的 SipHash 1-3 的性能无法满足需求，那么可以使用社区提供的替代算法。</p>
<p>例如其中一个社区库的使用方式如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::hash::BuildHasherDefault;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="comment">// 引入第三方的哈希函数</span></span><br><span class="line"><span class="keyword">use</span> twox_hash::XxHash64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hash</span>: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>();</span><br><span class="line">hash.<span class="title function_ invoke__">insert</span>(<span class="number">42</span>, <span class="string">&quot;the answer&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(hash.<span class="title function_ invoke__">get</span>(&amp;<span class="number">42</span>), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;the answer&quot;</span>));</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>大部分情况下，在编译时提示错误，并处理</p>
<p><strong>错误的分类</strong></p>
<ul>
<li>可恢复:</li>
</ul>
<p>例如文件未找到，可再次尝试</p>
<ul>
<li>不可恢复</li>
</ul>
<p>bug,例如访问索引超出范围</p>
<p><strong>Rust 没有类似 C++/Java 的异常机制</strong></p>
<ul>
<li>可恢复的错误:<strong>Result<T,E></strong></li>
<li>不可恢复:panic!宏</li>
</ul>
<h2 id="不可恢复的错误与-panic"><a href="#不可恢复的错误与-panic" class="headerlink" title="不可恢复的错误与 panic!"></a>不可恢复的错误与 panic!</h2><p>当 panic!宏执行</p>
<ul>
<li><strong>程序打印一个错误信息</strong></li>
<li><strong>展开(unwind),清理调用栈(Stack)</strong></li>
<li><strong>退出程序</strong></li>
</ul>
<h3 id="panic-‘abort’"><a href="#panic-‘abort’" class="headerlink" title="panic = ‘abort’"></a>panic = ‘abort’</h3><p>默认情况下，当 panic 发生</p>
<ul>
<li>程序展开调用栈(工作量大)</li>
</ul>
<p>Rust 沿着调用栈往回走，清理每个遇到的函数中的数据</p>
<ul>
<li>或立即中止调用栈 abort</li>
</ul>
<p>不进行清理，直接停止程序，内存需要由 OS 进行清理</p>
<p><strong>想让二进制文件更小，把设置从“展开”改为“中止”</strong></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure>
<p>自己写的代码中内 panic</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以依赖的代码中：外部 panic</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vector</span>=<span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    vector[<span class="number">100</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Compiling demo v0.1.0 (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.18s</span><br><span class="line">     Running `target\debug\demo.exe`</span><br><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at <span class="string">&#x27;index out of bounds: the len is 3 but the index is 100&#x27;</span>, src\main.rs:3:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line">error: process didn<span class="string">&#x27;t exit successfully: `target\debug\demo.exe` (exit code: 101)</span></span><br></pre></td></tr></table></figure>
<h3 id="通过调用-panic-的函数的回溯信息来定位引起问题的代码"><a href="#通过调用-panic-的函数的回溯信息来定位引起问题的代码" class="headerlink" title="通过调用 panic!的函数的回溯信息来定位引起问题的代码"></a>通过调用 panic!的函数的回溯信息来定位引起问题的代码</h3><p>使用以下命令运行代码(Windows cmd)</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> RUST_BACKTRACE=<span class="number">1</span> &amp;&amp; cargo run</span><br></pre></td></tr></table></figure>
<p>Windows Poweshell</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Env:RUST_BACKTRACE</span>=<span class="number">1</span> <span class="operator">-and</span> (cargo run)</span><br></pre></td></tr></table></figure>
<p>linux 下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> RUST_BACKTRACE=1 &amp;&amp; cargo run</span><br></pre></td></tr></table></figure>
<p>更详细的信息</p>
<p><strong>RUST_BACKTRACE=full</strong></p>
<p>为了获取带有调试信息的回溯，必须启用调试符号(不带—release)</p>
<h2 id="Result-枚举与可恢复的错误"><a href="#Result-枚举与可恢复的错误" class="headerlink" title="Result 枚举与可恢复的错误"></a>Result 枚举与可恢复的错误</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T 代表成功时返回的 Ok 成员中的数据的类型，</p>
<p>而 E 代表失败时返回的 Err 成员中的错误的类型</p>
<p>Result 及其变体也是由 prelude 带入作用域的</p>
<p>打开文件</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配不同的错误"><a href="#匹配不同的错误" class="headerlink" title="匹配不同的错误"></a>匹配不同的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <strong>unrap_or_else()</strong> 和 <strong>闭包（closure）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a>unwrap</h3><p>match 表达式的一个快捷方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 Result 结果是 Ok，返回 Ok 里面的值</li>
<li>如果 Result 结果是 Err,调用 panic!宏</li>
</ul>
<h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><p>可自定义错误信息的 unwrap</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h2><p>将错误传播给调用者</p>
<p><strong>自定义实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="？运算符"><a href="#？运算符" class="headerlink" title="？运算符"></a>？运算符</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>? 被定义为与自定义传播错误的示例中定义的处理 Result 值的 match 表达式有着完全相同的工作方式。</p>
<p>如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。</p>
<p>如果值是 Err，Err 中的值将作为整个函数的返回值，<strong>就好像使用了</strong> <strong>return</strong> <strong>关键字一样</strong>，这样错误值就被传播给了调用者。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file2</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">read_file1</span>().<span class="title function_ invoke__">unwrap_err</span>().<span class="title function_ invoke__">to_string</span>(), <span class="title function_ invoke__">read_file2</span>().<span class="title function_ invoke__">unwrap_err</span>().<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="？与-from-函数"><a href="#？与-from-函数" class="headerlink" title="？与 from 函数"></a>？与 from 函数</h2><p>Trait std::convert::From 上的 from 函数</p>
<ul>
<li>用于错误之间的转换</li>
<li>被？所应用的错误，会隐式地被 from 函数处理</li>
<li>当? 调用 from 函数时:</li>
</ul>
<p>它所接收地错误类型会被转化为当前函数返回类型所定义的错误类型</p>
<p>用于: <strong>针对不同的错误原因，返回同一种错误类型</strong></p>
<p>只要每个错误类型实现了转换为所返回的错误类型的 from 函数</p>
<p>可以在 ? 之后直接使用<strong>链式方法调用</strong>来进一步缩短代码</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    Parse,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 MyError 实现 Display（可选但常用）</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            MyError::<span class="title function_ invoke__">Io</span>(e) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">            MyError::Parse =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse error&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> MyError &#123;</span><br><span class="line">        MyError::<span class="title function_ invoke__">Io</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="？与-main-函数"><a href="#？与-main-函数" class="headerlink" title="？与 main 函数"></a>？与 main 函数</h2><p>main 函数的返回类型为()类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map，and-then"><a href="#map，and-then" class="headerlink" title="map，and_then"></a>map，and_then</h2><p><strong>map 示例 —— 修改 <code>Ok</code> 里的值</strong></p>
<p>只处理 <code>Ok</code> 的值并返回新的 <code>Result</code>，不会改变错误类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">map</span>(|n| n * <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(y, <span class="title function_ invoke__">Ok</span>(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>
<p>如果是错误呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">map</span>(|n| n * <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(y, <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error&quot;</span>));  <span class="comment">// 错误会原样返回</span></span><br></pre></td></tr></table></figure>
<p><strong>and_then 示例 —— 链式 Result 操作</strong></p>
<p><code>and_then</code>处理 <code>Ok</code>，并继续返回一个 <code>Result</code>（链式逻辑）， 适合把多个可能出错的步骤串起来：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sq_then_to_string</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;negative&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>((x * x).<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">Ok</span>(<span class="number">3</span>).<span class="title function_ invoke__">and_then</span>(sq_then_to_string);</span><br><span class="line"><span class="built_in">assert_eq!</span>(result, <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;9&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br></pre></td></tr></table></figure>
<p>如果出错，自动停止链式计算：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;bad&quot;</span>).<span class="title function_ invoke__">and_then</span>(sq_then_to_string);</span><br><span class="line"><span class="built_in">assert_eq!</span>(result, <span class="title function_ invoke__">Err</span>(<span class="string">&quot;bad&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With the return type rewritten, we use pattern matching without `unwrap()`.</span></span><br><span class="line"><span class="comment">// But it&#x27;s so Verbose..</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">multiply</span>(n1_str: &amp;<span class="type">str</span>, n2_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> n1_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n1)  =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> n2_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(n2)  =&gt; &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(n1 * n2)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rewriting `multiply` to make it succinct</span></span><br><span class="line"><span class="comment">// You  MUST USING `and_then` and `map` here</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">multiply1</span>(n1_str: &amp;<span class="type">str</span>, n2_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="comment">// IMPLEMENT...</span></span><br><span class="line">    n1_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">and_then</span>(|n1| &#123;</span><br><span class="line">        n2_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|n2| n1 * n2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(result: <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n)  =&gt; <span class="built_in">println!</span>(<span class="string">&quot;n is &#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// This still presents a reasonable answer.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">twenty</span> = <span class="title function_ invoke__">multiply1</span>(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print</span>(twenty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following now provides a much more helpful error message.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tt</span> = <span class="title function_ invoke__">multiply</span>(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print</span>(tt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="何时-panic"><a href="#何时-panic" class="headerlink" title="何时 panic!"></a>何时 panic!</h2><h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a><strong>总体原则</strong></h3><ul>
<li>在定义一个<strong>可能失败的函数时，优先考虑返回 Result</strong></li>
<li>否则就 panic!</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>演示某些概念：unwrap</li>
<li>原型代码:unwrap,expect</li>
<li>测试:unwrap,expect</li>
</ul>
<p><strong>有时你比编译器掌握更多的信息</strong></p>
<ul>
<li>你可以确定 Result 就是 Ok:<strong>unwrap</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p>调用你的代码，传入无意义的参数值:<strong>panic!</strong></p>
<ul>
<li><p>调用外部不可控代码，返回非法状态，你无法修复:<strong>panic!</strong></p>
</li>
<li><p>如果失败是可预期的：<strong>Result</strong></p>
</li>
<li><p>当你的代码对值进行操作，首先应该验证这些值:<strong>panic!</strong> （assert!）</p>
</li>
</ul>
<h3 id="创建自定义类型进行有效性验证"><a href="#创建自定义类型进行有效性验证" class="headerlink" title="创建自定义类型进行有效性验证"></a>创建自定义类型进行有效性验证</h3><p>一种实现方式是将猜测解析成 i32 而不仅仅是 u32，来默许输入负数，接着检查数字是否在范围内：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">1</span> || guess &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The secret number will be between 1 and 100.&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>if 表达式检查了值是否超出范围，告诉用户出了什么问题，并调用 continue 开始下一次循环，请求另一个猜测。if 表达式之后，就可以在知道 guess 在 1 到 100 之间的情况下与秘密数字作比较了。</p>
<p>相反我们可以创建一个新类型来将验证放入创建其实例的函数中，而不是到处重复这些检查。这样就可以安全的在函数签名中使用新类型并相信他们接收到的值。示例 中展示了一个定义 Guess 类型的方法，只有在 new 函数接收到 1 到 100 之间的值时才会创建 Guess 的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现了一个借用了 self 的方法 value，它没有任何其他参数并返回一个 i32。这类方法有时被称为 <em>getter</em>，因为它的目的就是返回对应字段的数据。这样的公有方法是必要的，因为 Guess 结构体的 value 字段是私有的。私有的字段 value 是很重要的，这样使用 Guess 结构体的代码将不允许直接设置 value 的值：调用者 <strong>必须</strong> 使用 Guess::new 方法来创建一个 Guess 的实例，这就确保了不会存在一个 value 没有通过 Guess::new 函数的条件检查的 Guess。</p>
<p>于是，一个接收（或返回） 1 到 100 之间数字的函数就可以声明为接收（或返回） Guess 的实例，而不是 i32，同时其函数体中也无需进行任何额外的检查。</p>
<h2 id="在-fn-main-中使用-Result"><a href="#在-fn-main-中使用-Result" class="headerlink" title="在 fn main 中使用 Result"></a>在 fn main 中使用 Result</h2><p>一个典型的 main 函数长这样:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上 main 函数还可以返回一个 Result 类型：如果 main 函数内部发生了错误，那该错误会被返回并且打印出一条错误的 debug 信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_str</span> = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">match</span> number_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(number)  =&gt; number,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="函数中定义泛型"><a href="#函数中定义泛型" class="headerlink" title="函数中定义泛型"></a>函数中定义泛型</h2><p>寻找 vec 中的最大值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_i32</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_char</span>(list: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest_i32</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest_char</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiling demo v0.1.0 (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to type `T`</span><br><span class="line"> --&gt; src\main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |         if item &gt; largest &#123;</span><br><span class="line">  |            ---- ^ ------- T</span><br><span class="line">  |            |</span><br><span class="line">  |            T</span><br><span class="line">  |</span><br><span class="line">help: consider restricting type parameter `T`</span><br><span class="line">  |</span><br><span class="line">1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">  |             ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0369`.</span><br><span class="line">error: could not compile `demo` due to previous error</span><br></pre></td></tr></table></figure>
<p>简单来说，这个错误表明 largest 的函数体不能适用于 T 的所有可能的类型</p>
<p>因为在函数体需要比较 T 类型的值，不过它只能用于我们知道如何排序的类型。为了开启比较功能，标准库中定义的 std::cmp::PartialOrd trait 可以实现类型的比较功能.</p>
<p>修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">PartialOrd</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> *item &gt; *largest &#123;<span class="comment">// 这里不用加*也可以，因为rust为引用类型实现了PartialOrd,前提是被引用的类型 T: PartialOrd</span></span><br><span class="line"></span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体中定义泛型"><a href="#结构体中定义泛型" class="headerlink" title="结构体中定义泛型"></a>结构体中定义泛型</h2><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举中定义泛型"><a href="#枚举中定义泛型" class="headerlink" title="枚举中定义泛型"></a>枚举中定义泛型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举也可以拥有多个泛型类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法定义中的泛型"><a href="#方法定义中的泛型" class="headerlink" title="方法定义中的泛型"></a>方法定义中的泛型</h2><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>把 T 放在 impl 关键字后,表示在类型 T 上实现方法:impl<T> Point<T></li>
<li>只针对具体类型实现方法:impl Point<f32></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x: <span class="number">5.0_f32</span>, y: <span class="number">10.0_f32</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,p.<span class="title function_ invoke__">distance_from_origin</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>struct 里的泛型类型参数可以和方法的泛型类型参数不同</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;X1, Y1&gt; &#123;</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const-泛型"><a href="#const-泛型" class="headerlink" title="const 泛型"></a>const 泛型</h2><p>针对类型实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对值的泛型？答案就是 Const 泛型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArrayPair</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    left: [T; N],</span><br><span class="line">    right: [T; N],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; <span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">ArrayPair</span>&lt;T, N&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;<span class="keyword">const</span> N: <span class="type">usize</span>&gt;() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>&lt;T, <span class="keyword">const</span> M: <span class="type">usize</span>&gt;() &#123;</span><br><span class="line">    foo::&lt;M&gt;(); <span class="comment">// ok: 符合第一种</span></span><br><span class="line">    foo::&lt;<span class="number">2021</span>&gt;(); <span class="comment">// ok: 符合第二种</span></span><br><span class="line">    foo::&lt;&#123;<span class="number">20</span> * <span class="number">100</span> + <span class="number">20</span> * <span class="number">10</span> + <span class="number">1</span>&#125;&gt;(); <span class="comment">// ok: 符合第三种</span></span><br><span class="line"></span><br><span class="line">    foo::&lt;&#123; M + <span class="number">1</span> &#125;&gt;(); <span class="comment">// error: 违背第三种，const 表达式中不能有泛型参数 M</span></span><br><span class="line">    foo::&lt;&#123; std::mem::size_of::&lt;T&gt;() &#125;&gt;(); <span class="comment">// error: 泛型表达式包含了泛型参数 T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span>: [<span class="type">u8</span>; M]; <span class="comment">// ok: 符合第一种</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span>: [<span class="type">u8</span>; std::mem::size_of::&lt;T&gt;()]; <span class="comment">// error: 泛型表达式包含了泛型参数 T</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>目前，const 泛型参数只能使用以下形式的实参:</p>
<ul>
<li><p>一个单独的 const 泛型参数</p>
</li>
<li><p>一个字面量 (i.e. 整数, 布尔值或字符).</p>
</li>
<li><p>一个具体的 const 表达式( 表达式中不能包含任何 泛型参数)</p>
</li>
</ul>
</li>
<li><p>const 泛型还能帮我们避免一些运行时检查，提升性能</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MinSlice</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> head: [T; N],</span><br><span class="line">    <span class="keyword">pub</span> tail: [T],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">u8</span>] = <span class="string">b&quot;Hello, world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference</span>: <span class="type">Option</span>&lt;&amp;<span class="type">u8</span>&gt; = slice.<span class="title function_ invoke__">get</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 我们知道 `.get` 返回的是 `Some(b&#x27; &#x27;)`</span></span><br><span class="line">    <span class="comment">// 但编译器不知道</span></span><br><span class="line">    <span class="built_in">assert!</span>(reference.<span class="title function_ invoke__">is_some</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">u8</span>] = <span class="string">b&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当编译构建 MinSlice 时会进行长度检查，也就是在编译期我们就知道它的长度是 12</span></span><br><span class="line">    <span class="comment">// 在运行期，一旦 `unwrap` 成功，在 `MinSlice` 的作用域内，就再无需任何检查</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">minslice</span> = MinSlice::&lt;<span class="type">u8</span>, <span class="number">12</span>&gt;::<span class="title function_ invoke__">from_slice</span>(slice).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span>: <span class="type">u8</span> = minslice.head[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(value, <span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>`</p>
<p><T, const N: usize> 是结构体类型的一部分，和数组类型一样，这意味着长度不同会导致类型不同： <strong>Array<i32, 3> 和 Array<i32, 4> 是不同的类型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    data : [T; N]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arrays</span> = [</span><br><span class="line">        Array&#123;</span><br><span class="line">            data: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        Array &#123;</span><br><span class="line">            data: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        Array &#123;</span><br><span class="line">            data: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填空</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填空</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_array</span>&lt;__&gt;(__) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时我们希望能<strong>限制一个变量占用内存的大小</strong>，例如在嵌入式环境中，此时 const 泛型参数的第三种形式 const 表达式 就非常适合:</p>
<p>下面的代码用到了 feature，需要 nightly 编译器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(incomplete_features)]</span></span><br><span class="line"><span class="meta">#![feature(generic_const_exprs)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check_size</span>&lt;T&gt;(val: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; <span class="number">768</span> &#125;&gt;: IsTrue,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fix the errors in main</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="number">0u8</span>; <span class="number">767</span>]);</span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="number">0i32</span>; <span class="number">191</span>]);</span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="string">&quot;hello你好&quot;</span>; <span class="number">47</span>]); <span class="comment">// &amp;str is a string reference, containing a pointer and string length in it, so it takes two word long, in x86-64, 1 word = 8 bytes</span></span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([(); <span class="number">31</span>].<span class="title function_ invoke__">map</span>(|_| <span class="string">&quot;hello你好&quot;</span>.<span class="title function_ invoke__">to_string</span>()));  <span class="comment">// String is a smart pointer struct, it has three fields: pointer, length and capacity, each takes 8 bytes</span></span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="string">&#x27;中&#x27;</span>; <span class="number">191</span>]); <span class="comment">// A char takes 4 bytes in Rust</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Assert</span>&lt;<span class="keyword">const</span> CHECK: <span class="type">bool</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IsTrue</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IsTrue</span> <span class="keyword">for</span> <span class="title class_">Assert</span>&lt;<span class="literal">true</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型代码的性能"><a href="#泛型代码的性能" class="headerlink" title="泛型代码的性能"></a>泛型代码的性能</h2><p>Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。</p>
<p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。<strong>单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fn main()&#123;</span></span><br><span class="line"><span class="comment">//    let integer = Some(5);</span></span><br><span class="line"><span class="comment">//    let float = Some(5.0);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译时，rust 会将 Option 泛型展开为 Option<i32>和 Option<i64>类型</p>
<h1 id="Trait：定义共同行为"><a href="#Trait：定义共同行为" class="headerlink" title="Trait：定义共同行为"></a>Trait：定义共同行为</h1><p>trait 告诉 Rust 编译器，某种类型具有哪些并且可以与其他类型共享的功能</p>
<h2 id="定义一个-trait"><a href="#定义一个-trait" class="headerlink" title="定义一个 trait"></a>定义一个 trait</h2><p>把方法签名放在一起，来定义实现某种目的所必需的一组行为</p>
<ul>
<li>关键字：trait</li>
<li>只有方法签名，没有具体实现</li>
</ul>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在类型上实现-trait"><a href="#在类型上实现-trait" class="headerlink" title="在类型上实现 trait"></a>在类型上实现 trait</h2><p>与为类型实现方法类似</p>
<p>不同之处：impl Xxxx for Tweet{….}</p>
<p>文件: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件 src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> demo::&#123;Summary,Tweet&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet&#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebook&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course,sa you probably...&quot;</span>),</span><br><span class="line">        reply:<span class="literal">false</span>,</span><br><span class="line">        retweet:<span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet:&#123;&#125;&quot;</span>,tweet.<span class="title function_ invoke__">summary</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo 就是 Cargo.toml 文件中的[package]项的 name</p>
<h2 id="实现-trait-的约束"><a href="#实现-trait-的约束" class="headerlink" title="实现 trait 的约束"></a>实现 trait 的约束</h2><p>可以在某个类型上实现某个 trait 的前提条件是:</p>
<ul>
<li>整个类型 <strong>或</strong> 这个 trait 是在本地 crate 里定义的</li>
</ul>
<p><strong>无法为外部类型实现外部 trait</strong></p>
<p>这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p>
<p>简而言之：<strong>类型和 trait 都不是你写的</strong>，<strong>那你就没有资格给它们加 impl</strong>。</p>
<h2 id="trait-中的函数的默认实现"><a href="#trait-中的函数的默认实现" class="headerlink" title="trait 中的函数的默认实现"></a>trait 中的函数的默认实现</h2><p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="comment">//fn summarize(&amp;self) -&gt; String &#123;</span></span><br><span class="line">    <span class="comment">//    format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location)</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="comment">//默认实现的重写的实现</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认实现允许调用相同 trait 中的其他方法</strong>，<strong>哪怕这些方法没有默认实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:无法从方法的重写实现里面调用默认的实现</p>
<h2 id="trait-作为参数"><a href="#trait-作为参数" class="headerlink" title="trait 作为参数"></a>trait 作为参数</h2><h3 id="impl-triat-语法："><a href="#impl-triat-语法：" class="headerlink" title="impl triat 语法："></a>impl triat 语法：</h3><p>适用于简单情况,是 trait bound 的语法糖</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trait-bound-语法："><a href="#trait-bound-语法：" class="headerlink" title="trait bound 语法："></a>trait bound 语法：</h3><p>适用于复杂情况</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这适用于 item1 和 item2 允许是不同类型的情况（只要它们都实现了 Summary）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-指定多个-traint-bound"><a href="#使用-指定多个-traint-bound" class="headerlink" title="使用+指定多个 traint bound"></a>使用+指定多个 traint bound</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-where-简化-trait-bound"><a href="#使用-where-简化-trait-bound" class="headerlink" title="使用 where 简化 trait bound"></a>使用 where 简化 trait bound</h3><p>fn some_function<T: Display + Clone, U: Clone + Debug>(t: &amp;T, u: &amp;U) -&gt; i32 {</p>
<p>使用 where 从句</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回实现了-trait-的类型"><a href="#返回实现了-trait-的类型" class="headerlink" title="返回实现了 trait 的类型"></a>返回实现了 trait 的类型</h2><p>也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这只适用于<strong>返回单一类型的情况</strong>。例如，这段代码的返回值类型指定为返回 impl Summary，但是返回了 NewsArticle 或 Tweet 就行不通：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        NewsArticle &#123;</span><br><span class="line">            headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">            author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">                 hockey team in the NHL.&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123;</span><br><span class="line">            username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            reply: <span class="literal">false</span>,</span><br><span class="line">            retweet: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里尝试返回 NewsArticle 或 Tweet。这不能编译，因为 impl Trait 工作方式的限制。</p>
<p>可以使用 dyn trait 对象</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sheep</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cow</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;baaaaah!&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Cow</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;moooooo!&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个类型，该类型实现了 Animal 特征，但是我们并不能在编译期获知具体返回了哪个类型</span></span><br><span class="line"><span class="comment">// 修复这里的错误，你可以使用虚假的随机，也可以使用特征对象</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">random_animal</span>(random_number: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> random_number &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Sheep &#123;&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cow &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">random_number</span> = <span class="number">0.234</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animal</span> = <span class="title function_ invoke__">random_animal</span>(random_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;</span>, animal.<span class="title function_ invoke__">noise</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特征对象-在数组中使用特征对象"><a href="#特征对象-在数组中使用特征对象" class="headerlink" title="特征对象,在数组中使用特征对象"></a>特征对象,在数组中使用特征对象</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">quack</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Duck</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Look, the duck is flying&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Swan</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Swan</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Look, the duck.. oh sorry, the swan is flying&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Bird</span> <span class="keyword">for</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">quack</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;duck duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Bird</span> <span class="keyword">for</span> <span class="title class_">Swan</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">quack</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;swan swan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">birds</span> :[<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Bird&gt;;<span class="number">2</span>]=[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Duck&#123;&#125;),<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Swan&#123;&#125;)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">bird</span> <span class="keyword">in</span> birds &#123;</span><br><span class="line">        bird.<span class="title function_ invoke__">quack</span>();</span><br><span class="line">        <span class="comment">// 当 duck 和 swan 变成 bird 后，它们都忘了如何翱翔于天际，只记得该怎么叫唤了。。</span></span><br><span class="line">        <span class="comment">// 因此，以下代码会报错</span></span><br><span class="line">        <span class="comment">// bird.fly();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="amp-dyn-和-Box"><a href="#amp-dyn-和-Box" class="headerlink" title="&amp;dyn 和 Box"></a>&amp;dyn 和 Box<dyn></h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;f64: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1.1f64</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">8u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw x</span></span><br><span class="line">    <span class="title function_ invoke__">draw_with_box</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw y</span></span><br><span class="line">    <span class="title function_ invoke__">draw_with_ref</span>(&amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_with_box</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_with_ref</span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态分发和动态分发-Static-and-Dynamic-dispatch"><a href="#静态分发和动态分发-Static-and-Dynamic-dispatch" class="headerlink" title="静态分发和动态分发 Static and Dynamic dispatch"></a>静态分发和动态分发 Static and Dynamic dispatch</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="built_in">format!</span>(<span class="string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="built_in">format!</span>(<span class="string">&quot;string: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement below with generics</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_dispatch</span>&lt;T: Foo&gt;(x: T) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">method</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement below with trait objects</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dynamic_dispatch</span>(x: &amp;<span class="keyword">dyn</span> Foo) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">method</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5u8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">static_dispatch</span>(x);</span><br><span class="line">    <span class="title function_ invoke__">dynamic_dispatch</span>(&amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-trait-bounds-来修复-largest-函数"><a href="#使用-trait-bounds-来修复-largest-函数" class="headerlink" title="使用 trait bounds 来修复 largest 函数"></a>使用 trait bounds 来修复 largest 函数</h2><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果并不希望限制 largest 函数只能用于实现了 Copy trait 的类型，我们可以在 T 的 trait bounds 中指定 Clone 而不是 Copy。并克隆 slice 的每一个值使得 largest 函数拥有其所有权。使用 clone 函数意味着对于类似 String 这样拥有堆上数据的类型，会潜在的分配更多堆上空间，而堆分配在涉及大量数据时可能会相当缓慢。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_list</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;str_list)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest word is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者 largest 直接返回一个引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_list</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;str_list)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest word is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-trait-bound-有条件地实现方法"><a href="#使用-trait-bound-有条件地实现方法" class="headerlink" title="使用 trait bound 有条件地实现方法"></a>使用 trait bound 有条件地实现方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为满足 trait bound 的所有类型上实现 trait 叫做<strong>覆盖实现(blanket implementations)</strong></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T: Display&gt; ToString for T &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为标准库有了这些 blanket implementation，我们可以对任何实现了 Display trait 的类型调用由 ToString 定义的 to_string 方法。例如，可以将整型转换为对应的 String 值，因为整型实现了 Display：</p>
<p>let s = 3.to_string();</p>
<h2 id="Derive-宏派生实现"><a href="#Derive-宏派生实现" class="headerlink" title="Derive 宏派生实现"></a>Derive 宏派生实现</h2><p>我们可以使用 #[derive] 属性来派生一些特征，对于这些特征编译器会自动进行默认实现，对于日常代码开发而言，这是非常方便的，例如大家经常用到的 Debug 特征，就是直接通过派生来获取默认实现，而无需我们手动去完成这个工作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Centimeters`, 一个元组结构体，可以被比较大小</span></span><br><span class="line"><span class="meta">#[derive(PartialEq, PartialOrd)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Centimeters</span>(<span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Inches`, 一个元组结构体可以被打印</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Inches</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Inches</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_centimeters</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Centimeters &#123;</span><br><span class="line">        <span class="keyword">let</span> &amp;<span class="title function_ invoke__">Inches</span>(inches) = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Centimeters</span>(inches <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">2.54</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些属性让代码工作</span></span><br><span class="line"><span class="comment">// 不要修改其它代码！</span></span><br><span class="line"><span class="meta">#[derive(Debug,PartialEq,PartialOrd)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seconds</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_one_second</span> = <span class="title function_ invoke__">Seconds</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;One second looks like: &#123;:?&#125;&quot;</span>, _one_second);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_this_is_true</span> = _one_second == _one_second;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_this_is_true</span> = _one_second &gt; _one_second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foot</span> = <span class="title function_ invoke__">Inches</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;One foot equals &#123;:?&#125;&quot;</span>, foot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">meter</span> = <span class="title function_ invoke__">Centimeters</span>(<span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cmp</span> =</span><br><span class="line">        <span class="keyword">if</span> foot.<span class="title function_ invoke__">to_centimeters</span>() &lt; meter &#123;</span><br><span class="line">            <span class="string">&quot;smaller&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">&quot;bigger&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;One foot is &#123;&#125; than one meter.&quot;</span>, cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul>
<li>Rust 的每个引用都有自己的生命周期</li>
<li><strong>生命周期：引用保持有效的作用域</strong></li>
<li>大多数情况下：生命周期是隐式的，可被推断的</li>
<li>当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</li>
</ul>
<p>生命周期存在的目标是:<strong>避免悬空引用</strong></p>
<p>尝试使用离开作用域的值的引用会失败</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">           r = &amp;x;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h2><p>Rust 编译器有一个 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                             <span class="comment">//          |</span></span><br><span class="line">       &#123;                     <span class="comment">//          |</span></span><br><span class="line">           <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">           r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">       &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                             <span class="comment">//          |</span></span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//          |</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里将 r 的生命周期标记为 ‘a 并将 x 的生命周期标记为 ‘b。如你所见，内部的 ‘b 块要比外部的生命周期 ‘a 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 ‘a，不过它引用了一个拥有生命周期 ‘b 的对象。程序被拒绝编译，因为生命周期 ‘b 比生命周期 ‘a 要小：被引用的对象比它的引用者存在的时间更短。</p>
<h2 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src\main.rs:1:33</span><br><span class="line">  |</span><br><span class="line">1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = <span class="built_in">help</span>: this <span class="keyword">function</span><span class="string">&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span></span><br><span class="line"><span class="string">help: consider introducing a named lifetime parameter</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">1 | fn longest&lt;&#x27;</span>a&gt;(x: &amp;<span class="string">&#x27;a str, y: &amp;&#x27;</span>a str) -&gt; &amp;<span class="string">&#x27;a str &#123;</span></span><br><span class="line"><span class="string">  |           ++++     ++          ++          ++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0106`.</span></span><br><span class="line"><span class="string">error: could not compile `demo` due to previous error</span></span><br></pre></td></tr></table></figure>
<p>标识生命周期</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示返回值的生命周期是传入参数的两个引用的生命周期的重叠部分。</p>
<h2 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h2><ul>
<li>生命周期的标注不会改变引用的生命周期的长度</li>
<li>当制定了泛型生命周期参数，函数可以接受带有任何生命周期的引用</li>
<li>生命周期的标注：<strong>描述了多个引用的生命周期的关系，但不影响生命周期</strong></li>
<li><p>生命周期的参数名: 以 ‘ 开头，通常全小写且非常短，很多人使用 ‘a</p>
</li>
<li><p>生命周期标注的位置</p>
</li>
</ul>
<p><strong>在引用的&amp;符号后</strong>，使用空格将标注和引用类型分开</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>
<p>泛型生命周期参数声明在:<strong>函数名和参数列表之间的&lt;&gt;里</strong></p>
<p>fn longest&lt;’a&gt;(x: &amp;’a str, y: &amp;’a str) -&gt; &amp;’a str {</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的实际含义是 longest 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致。</p>
<p>记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 longest 函数并不需要知道 x 和 y 具体会存在多久，而只需要知道有某个可以被 ‘a 替代的作用域将会满足这个签名。</p>
<p>当具体的引用被传递给 longest 时，被 ‘a 所替代的具体生命周期是 x 的作用域与 y 的作用域<strong>相重叠的那一部分</strong>。换一种说法就是泛型生命周期 ‘a 的具体生命周期等同于 x 和 y 的生命周期中<strong>较小的那一个</strong>。因为我们用相同的生命周期参数 ‘a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。</p>
<p>使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，string1 直到外部作用域结束都是有效的，string2 则在内部作用域中是有效的，而 result 则引用了一些直到内部作用域结束都是有效的值。借用检查器认可这些代码；它能够编译和运行，并打印出 The longest string is long string is long。</p>
<p>修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行出错</p>
<p>错误表明为了保证 println! 中的 result 是有效的，string2 需要直到外部作用域结束都是有效的。Rust 知道这些是因为（longest）函数的参数和返回值都使用了相同的生命周期参数 ‘a。</p>
<h2 id="深入理解声明周期"><a href="#深入理解声明周期" class="headerlink" title="深入理解声明周期"></a>深入理解声明周期</h2><ul>
<li><strong>指定生命周期参数的正确方式依赖函数实现的具体功能</strong></li>
</ul>
<p>如果将 longest 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 y 指定一个生命周期。如下代码将能够编译：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。</strong></li>
</ul>
<p>如果返回的引用 <strong>没有</strong> 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;really long string&quot;</span>);</span><br><span class="line">    result.<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错</p>
<p>综上，生命周期语法是用于<strong>将函数的多个参数与其返回值的生命周期进行关联的</strong>。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</p>
<h2 id="结构体定义中的生命周期注解"><a href="#结构体定义中的生命周期注解" class="headerlink" title="结构体定义中的生命周期注解"></a>结构体定义中的生命周期注解</h2><p>struct 里可包括：</p>
<ul>
<li>自持有类型</li>
<li>引用:需要在每个引用上添加声明周期标注</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示结构体的生命周期和其成员 part 的生命周期相同。</p>
<h2 id="生命周期的省略"><a href="#生命周期的省略" class="headerlink" title="生命周期的省略"></a>生命周期的省略</h2><p><strong>Lifetime Elision</strong></p>
<p>在 Rust 引用分析中所编入的模式称为<strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）</p>
<p>这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。</p>
<p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>编译器采用<strong>三条规则</strong>来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则<strong>适用于</strong> <strong>fn</strong> <strong>定义，以及</strong> <strong>impl</strong> <strong>块</strong>。</p>
<ul>
<li><strong>规则 1</strong>：<strong>每个引用类型的参数都有自己的声明周期</strong></li>
<li><strong>规则 2</strong>：<strong>如果只有 1 个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数</strong></li>
<li><strong>规则 3</strong>：<strong>如果有多个输入生命周期参数，但其中一个是&amp;self 或&amp;mut self(是方法)，那么 self 的生命周期就会被赋给所有的输出生命周期参数</strong></li>
</ul>
<p>例子:</p>
<p>假设我们自己就是编译器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>
<p>接着编译器应用第一条规则，也就是<strong>每个引用参数都有其自己的生命周期</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>
<p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>
<p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x:&amp;<span class="type">str</span>,y:&amp;<span class="type">str</span>)<span class="punctuation">-&gt;</span>&amp;<span class="type">str</span>&#123;</span><br></pre></td></tr></table></figure>
<p>应用第一条规则</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;b</span>&gt;(x:&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,y:&amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>)<span class="punctuation">-&gt;</span>&amp;<span class="type">str</span>&#123;</span><br></pre></td></tr></table></figure>
<p>第二条规则不适用，第三条不适用，所以编译器报错</p>
<h2 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a>方法定义中的生命周期标注</h2><p>当为带有生命周期的结构体实现方法时，其语法依然类似泛型类型参数的语法。</p>
<p>在哪里声明生命周期参数，依赖于：</p>
<ul>
<li><strong>生命周期参数是否同结构体字段或方法参数和返回值相关</strong>。</li>
</ul>
<p>struct 字段的生命周期名:</p>
<ul>
<li>在 impl 后声明</li>
<li>在 struct 名后使用</li>
<li>这些生命周期是 struct 类型的一部分</li>
</ul>
<p>impl 块内的方法签名中:</p>
<ul>
<li>引用必须绑定于 struct 字段引用的声明周期，或者引用是独立的也可以</li>
<li>生命周期省略规则经常使得方法中的生命周期标注不是必须的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是一个适用于第三条生命周期省略规则的例子</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael.Some year ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not found a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt&#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>announce_and_return_part 这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 &amp;self 和 announcement 他们各自的生命周期。接着，因为其中一个参数是 &amp;self，返回值类型被赋予了 &amp;self 的生命周期，这样所有的生命周期都被计算出来了。</p>
<h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p>‘static，其生命周期<strong>能够</strong>存活于整个程序期间。</p>
<p><strong>所有的字符串字面值都拥有</strong> <strong>‘static</strong> <strong>生命周期</strong></p>
<p>let s: &amp;’static str = “I have a static lifetime.”;</p>
<p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 ‘static 的。</p>
<h2 id="结合泛型类型参数、trait-bounds-和生命周期"><a href="#结合泛型类型参数、trait-bounds-和生命周期" class="headerlink" title="结合泛型类型参数、trait bounds 和生命周期"></a>结合泛型类型参数、trait bounds 和生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编写自动化测试"><a href="#编写自动化测试" class="headerlink" title="编写自动化测试"></a>编写自动化测试</h1><p>Rust 中的测试函数是用来验证非测试代码是否是按照期望的方式运行的。测试函数体通常执行如下三种操作：</p>
<ol>
<li>设置任何所需的数据或状态(Arrange)</li>
<li>运行需要测试的代码(Act)</li>
<li>断言（Assert）其结果是我们所期望的</li>
</ol>
<h2 id="测试函数剖析"><a href="#测试函数剖析" class="headerlink" title="测试函数剖析"></a>测试函数剖析</h2><h3 id="编写测试函数"><a href="#编写测试函数" class="headerlink" title="编写测试函数"></a>编写测试函数</h3><p>Rust 中的测试就是一个带有 test 属性注解的函数。属性（attribute）是关于 Rust 代码片段的元数据</p>
<p>为了将一个函数变成测试函数，需要在 fn 行之前加上 <strong>#[test]</strong></p>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><ul>
<li>使用 cargo test 命令运行所有测试函数</li>
</ul>
<p>Rust Hui 构建一个 Test Runner 的可执行文件，它会运行标注了 test 的函数，并报告其运行是否成功</p>
<ul>
<li>当使用 cargo 创建 library 项目时，会生成一个 test module,里面有一个 test 函数</li>
</ul>
<p>可以添加任意数量的 test module 或函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new 项目名 --lib</span><br></pre></td></tr></table></figure>
<p>src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="测试失败"><a href="#测试失败" class="headerlink" title="测试失败"></a>测试失败</h3><ul>
<li>测试函数 panic 就表示失败</li>
<li>每个测试运行在一个新线程</li>
<li>当主线程看见某个测试线程挂掉了，那个测试标记为失败了</li>
</ul>
<h2 id="断言（Assert）"><a href="#断言（Assert）" class="headerlink" title="断言（Assert）"></a>断言（Assert）</h2><h3 id="使用-assert-宏检查测试结果"><a href="#使用-assert-宏检查测试结果" class="headerlink" title="使用 assert!宏检查测试结果"></a>使用 assert!宏检查测试结果</h3><p>assert!宏，来自标准库，用来确定某个状态是否为 true</p>
<ul>
<li>true，测试通过</li>
<li>false, 调用 panic！，测试失败</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">8</span>,</span><br><span class="line">            height: <span class="number">7</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">5</span>,</span><br><span class="line">            height: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-assert-eq-和-assert-ne-宏来测试相等"><a href="#使用-assert-eq-和-assert-ne-宏来测试相等" class="headerlink" title="使用 assert_eq! 和 assert_ne! 宏来测试相等"></a>使用 assert_eq! 和 assert_ne! 宏来测试相等</h3><ul>
<li>都来自于标准库</li>
<li>判断两个参数是否相等或不等</li>
<li>实际上，它们使用的就是==和！=运算符的 assert!</li>
<li>断言失败，会自动打印出两个参数的值</li>
</ul>
<p>使用 debug 格式打印参数：要求参数实现了 PartialEq 和 Debug Traits（所有基本类型和标准库大部分类型都实现了）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><p>可以向 assert!、assert_eq! 和 assert_ne! 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。</p>
<ul>
<li>assert! 宏的第一个参数必填，自定义消息作为第二个参数</li>
<li>assert_eq!和 assert_ne! 前两个参数必填，自定义消息作为第 3 个参数</li>
<li>自定义消息参数会被传递给 format!宏，可以使用{}占位符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greeting</span>(name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;&#125;!&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义错误信息</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">            result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Greeting did not contain name, value was `&#123;&#125;`&quot;</span>,</span><br><span class="line">            result</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="验证错误处理的情况"><a href="#验证错误处理的情况" class="headerlink" title="验证错误处理的情况"></a>验证错误处理的情况</h2><p>可验证代码在特定情况下是否发生了 panic</p>
<p><strong>should_panic</strong> 属性(attribute):</p>
<ul>
<li>函数 panic：测试通过</li>
<li>函数没有 panic：测试失败</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="让-should-panic-更精确"><a href="#让-should-panic-更精确" class="headerlink" title="让 should_panic 更精确"></a>让 should_panic 更精确</h3><p>可以给 should_panic 属性增加一个可选的 expected 参数。测试工具会确保错误信息中包含其提供的文本</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在测试中使用-Result"><a href="#在测试中使用-Result" class="headerlink" title="在测试中使用 Result"></a>在测试中使用 Result<T,E></h2><p>无需 panic，可以使用 Result<T,E>作为返回类型编写测试</p>
<ul>
<li>返回 Ok:测试通过</li>
<li>返回 Err:测试失败</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>不能对这些使用 Result<T, E> 的测试使用 #[should_panic] 注解</strong>。</p>
<p>因为运行失败时会返回 Err 而不会发生 panic</p>
<h2 id="控制测试运行"><a href="#控制测试运行" class="headerlink" title="控制测试运行"></a>控制测试运行</h2><p>改变 cargo test 的行为:添加命令行参数</p>
<p>默认行为:</p>
<ul>
<li><strong>并行运行</strong></li>
<li><strong>所有测试</strong></li>
<li>捕获（不显示）所有标准输出，使读取与测试结果相关的输出更容易</li>
</ul>
<p>命令行参数:</p>
<ul>
<li>针对 cargo test 的参数: 紧跟 cargo test 后</li>
</ul>
<p>cargo test —help</p>
<ul>
<li>针对测试可执行程序: 放在—之后</li>
</ul>
<p>cargo test — —help</p>
<h3 id="并行运行测试"><a href="#并行运行测试" class="headerlink" title="并行运行测试"></a>并行运行测试</h3><p>默认使用多个线程并行运行</p>
<p>要确保测试之间：</p>
<ul>
<li>不会相互依赖</li>
<li>不依赖于某个共享状态(环境，工作目录，环境变量等)</li>
</ul>
<h4 id="—test-threads-参数"><a href="#—test-threads-参数" class="headerlink" title="—test-threads 参数"></a>—test-threads 参数</h4><p>如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 —test-threads 参数和希望使用线程的数量给测试二进制文件。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span> -- --test-threads=1</span><br></pre></td></tr></table></figure>
<p>这里将测试线程设置为 1，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<h3 id="显式函数输出"><a href="#显式函数输出" class="headerlink" title="显式函数输出"></a>显式函数输出</h3><p>默认，如果测试通过，Rust 的 test 库会捕获所有打印到标准输出的内容</p>
<p>比如 println!:</p>
<ul>
<li><strong>如果测试成功，我们将不会在终端看到 println! 的输出</strong>：只会看到说明测试通过的提示行。</li>
<li>如果<strong>测试失败了，则会看到所有标准输出和其他错误信息</strong>。</li>
</ul>
<p>如果你希望也能看到通过的测试中打印的值，也可以在结尾加上 —show-output 告诉 Rust 显示成功测试的输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span> -- --show-output</span><br></pre></td></tr></table></figure>
<h3 id="按名称运行测试的子集"><a href="#按名称运行测试的子集" class="headerlink" title="按名称运行测试的子集"></a>按名称运行测试的子集</h3><p>如果没有传递任何参数就运行测试，所有测试都会并行运行：</p>
<h4 id="运行单个测试"><a href="#运行单个测试" class="headerlink" title="运行单个测试"></a>运行单个测试</h4><p>可以向 cargo test 传递任意测试的名称来只运行这个测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span> one_hundred</span><br></pre></td></tr></table></figure>
<h4 id="过滤运行多个测试"><a href="#过滤运行多个测试" class="headerlink" title="过滤运行多个测试"></a>过滤运行多个测试</h4><p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 add，可以通过 cargo test add 来运行这两个测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> add</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished <span class="built_in">test</span> [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.61s</span><br><span class="line">     Running unittests (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line"><span class="built_in">test</span> tests::add_three_and_two ... ok</span><br><span class="line"><span class="built_in">test</span> tests::add_two_and_two ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished <span class="keyword">in</span> 0.00s</span><br></pre></td></tr></table></figure>
<p>这运行了所有名字中带有 add 的测试，也过滤掉了名为 one_hundred 的测试。</p>
<h4 id="忽略某些测试"><a href="#忽略某些测试" class="headerlink" title="忽略某些测试"></a>忽略某些测试</h4><p>有时一些特定的测试执行起来是非常耗费时间的，所以在大多数运行 cargo test 的时候希望能排除他们</p>
<p>可以使用 ignore 属性来标记耗时的测试并排除他们，如下所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expensive_test</span>() &#123;</span><br><span class="line">    <span class="comment">// 需要运行一个小时的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于想要排除的测试，我们在 #[test] 之后增加了 #[ignore] 行。现在如果运行测试，就会发现 it_works 运行了，而 expensive_test 没有运行：</p>
<p>如果我们只希望运行被忽略的测试，可以使用 cargo test — —ignored</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --ignored</span><br></pre></td></tr></table></figure>
<h2 id="测试组织"><a href="#测试组织" class="headerlink" title="测试组织"></a>测试组织</h2><p>Rust 社区倾向于根据测试的两个主要分类来考虑问题：</p>
<p><strong>单元测试</strong>（<em>unit tests</em>）与 <strong>集成测试</strong>（<em>integration tests</em>）</p>
<ul>
<li>元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口。</li>
<li>而集成测试对于你的库来说则完全是外部的。它们与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。</li>
</ul>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><strong>#[cfg(test)]标注 test 模块</strong></p>
<ul>
<li>只有运行 cargo test 才编译和运行代码</li>
<li>运行 cargo build 则不会</li>
<li>集成测试在不同的目录，它不需要#[cfg(test)]标注</li>
</ul>
<p><strong>cfg: configuration 配置</strong></p>
<p>告诉 Rust 下面的条目只有在指定的配置选项下才被包含</p>
<h4 id="测试私有函数"><a href="#测试私有函数" class="headerlink" title="测试私有函数"></a>测试私有函数</h4><p>测试社区中一直存在关于是否应该对私有函数直接进行测试的论战，而在其他语言中想要测试私有函数是一件困难的，甚至是不可能的事。不过无论你坚持哪种测试意识形态，<strong>Rust 的私有性规则确实允许你测试私有函数</strong>。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pub fn add_two(a: i32) -&gt; i32 &#123;</span><br><span class="line">    internal_adder(a, 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn internal_adder(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn internal() &#123;</span><br><span class="line">        assert_eq!(4, internal_adder(2, 2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 11-12：测试私有函数</p>
<p>注意 internal_adder 函数并没有标记为 pub。同时 tests 也仅仅是另一个模块。正如 “路径用于引用模块树中的项”部分所说，子模块的项可以使用其上级模块的项。在测试中，我们通过 use super::* 将 test 模块的父模块的所有项引入了作用域，接着测试调用了 internal_adder。</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>在 Rust 里，集成测试完全位于测试库的外部</p>
<p>同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以<strong>集成测试的覆盖率</strong>也是很重要的。</p>
<h4 id="tests-目录"><a href="#tests-目录" class="headerlink" title="tests 目录"></a>tests 目录</h4><ul>
<li>创建集成测试:tests 目录</li>
<li><strong>tests 目录下的每个测试文件都是单独的一个 crate</strong></li>
</ul>
<p>创建一个集成测试。保留示例 adder 中 <em>src/lib.rs</em> 的代码。创建一个 <em>tests</em> 目录，新建一个文件 <em>tests/integration_test.rs</em>，并输入示例中的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>并不需要将 <em>tests/integration_test.rs</em> 中的任何代码标注为 #[cfg(test)]。 <strong>tests 文件夹在 Cargo 中是一个特殊的文件夹</strong>， Cargo 只会在运行 cargo test 时编译这个目录中的文件。</li>
<li>需要将被测试库导入</li>
</ul>
<h4 id="运行指定的集成测试"><a href="#运行指定的集成测试" class="headerlink" title="运行指定的集成测试"></a>运行指定的集成测试</h4><p>运行一个特定的集成测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> 函数名</span><br></pre></td></tr></table></figure>
<p>运行某个测试文件内的所有测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --<span class="built_in">test</span> 文件名</span><br></pre></td></tr></table></figure>
<h4 id="集成测试中的子模块"><a href="#集成测试中的子模块" class="headerlink" title="集成测试中的子模块"></a>集成测试中的子模块</h4><p>随着集成测试的增加，你可能希望在 tests 目录增加更多文件以便更好的组织他们，例如根据测试的功能来将测试分组。正如我们之前提到的，每一个 <em>tests</em> 目录中的文件都被编译为单独的 crate。</p>
<p>将每个集成测试文件当作其自己的 crate 来对待，这更有助于创建单独的作用域，这种单独的作用域能提供更类似与最终使用者使用 crate 的环境。</p>
<p>例如，如果我们可以创建 一个<em>tests/common.rs</em> 文件并创建一个名叫 setup 的函数，我们希望这个函数能被多个测试文件的测试函数调用：</p>
<p>文件名: tests/common.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line">    <span class="comment">// setup code specific to your library&#x27;s tests would go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果再次运行测试，将会在测试结果中看到一个新的对应 <em>common.rs</em> 文件的测试结果部分，即便这个文件并没有包含任何测试函数，也没有任何地方调用了 setup 函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished <span class="built_in">test</span> [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.89s</span><br><span class="line">     Running unittests (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> tests::internal ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> it_adds_two ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br></pre></td></tr></table></figure>
<p>我们并不想要 common 出现在测试结果中显示 running 0 tests 。我们只是希望其能被其他多个集成测试文件中调用罢了。</p>
<p>为了不让 common 出现在测试输出中，我们将<strong>创建</strong> <strong><em>tests/common/mod.rs</em></strong> ，<strong>而不是创建</strong> <strong><em>tests/common.rs</em></strong> 。这是一种 Rust 的命名规范，这样命名<strong>告诉 Rust 不要将</strong> <strong>common</strong> <strong>看作一个集成测试文件</strong>。将 setup 函数代码移动到 <em>tests/common/mod.rs</em> 并删除 <em>tests/common.rs</em> 文件之后，测试输出中将不会出现这一部分。<strong><em>tests</em> 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中</strong>。</p>
<p>一旦拥有了 <em>tests/common/mod.rs</em>，就可以将其作为模块以便在任何集成测试文件中使用。这里是一个 <em>tests/integration_test.rs</em> 中调用 setup 函数的 it_adds_two 测试的例子：</p>
<p>文件名: tests/integration_test.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;<span class="comment">//接着在测试函数中就可以调用 `common::setup()` 了。</span></span><br></pre></td></tr></table></figure>
<h4 id="针对-binary-crate-的集成测试"><a href="#针对-binary-crate-的集成测试" class="headerlink" title="针对 binary crate 的集成测试"></a>针对 binary crate 的集成测试</h4><ul>
<li><p>如果项目时 binary crate 只有含有 src/main.rs 没有 src/lib.rs：</p>
<ul>
<li><p>不能在 tests 目录下创建集成测试</p>
</li>
<li><p>无法把 main.rs 的函数导入作用域</p>
</li>
</ul>
</li>
<li><p>只有 library crate 在能暴露函数给其它 crate 使用</p>
</li>
<li>binary crate 意味着独立运行</li>
</ul>
<h1 id="IO-项目-构建命令行程序"><a href="#IO-项目-构建命令行程序" class="headerlink" title="IO 项目:构建命令行程序"></a>IO 项目:构建命令行程序</h1><h2 id="接收命令行参数"><a href="#接收命令行参数" class="headerlink" title="接收命令行参数"></a>接收命令行参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p> std::env::args 在其任何参数包含无效 Unicode 字符时会 panic。</p>
<p> 如果你需要接受包含无效 Unicode 字符的参数，使用 <strong>std::env::args_os</strong> 代替。这个函数<strong>返回 OsString 值</strong>而不是 String 值。这里出于简单考虑使用了 std::env::args，因为 OsString 值每个平台都不一样而且比 String 值处理起来更为复杂。</p>
<h2 id="二进制项目的关注与分离"><a href="#二进制项目的关注与分离" class="headerlink" title="二进制项目的关注与分离"></a>二进制项目的关注与分离</h2><p>main 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 main 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：</p>
<ul>
<li><strong>将程序拆分成 <em>main.rs</em> 和 <em>lib.rs</em> 并将程序的逻辑放入 <em>lib.rs</em> 中</strong>。</li>
<li>当命令行解析逻辑比较小时，可以保留在 <em>main.rs</em> 中。</li>
<li>当命令行解析开始变得复杂时，也同样将其从 <em>main.rs</em> 提取到 <em>lib.rs</em> 中。</li>
</ul>
<p>经过这些过程之后保留在 main 函数中的责任应该被限制为：</p>
<ul>
<li>使用参数值调用命令行解析逻辑</li>
<li>设置任何其他的配置</li>
<li>调用 <em>lib.rs</em> 中的 run 函数</li>
<li>如果 run 返回错误，则处理这个错误</li>
</ul>
<p>这个模式的一切就是为了关注分离：<em>main.rs</em> 处理程序运行，而 <em>lib.rs</em> 处理所有的真正的任务逻辑。因为不能直接测试 main 函数，这个结构通过将所有的程序逻辑移动到 <em>lib.rs</em> 的函数中使得我们可以测试他们。仅仅保留在 <em>main.rs</em> 中的代码将足够小以便阅读就可以验证其正确性。</p>
<h2 id="TDD-测试驱动开发"><a href="#TDD-测试驱动开发" class="headerlink" title="TDD 测试驱动开发"></a>TDD 测试驱动开发</h2><p>遵循测试驱动开发（Test Driven Development, TDD）的模式来逐步增加 minigrep 的搜索逻辑。这是一个软件开发技术，它遵循如下步骤：</p>
<ol>
<li>编写一个失败的测试，并运行它以确保它失败的原因是你所期望的。</li>
<li>编写或修改足够的代码来使新的测试通过。</li>
<li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li>
<li>从步骤 1 开始重复！</li>
</ol>
<p>这只是众多编写软件的方法之一，不过 TDD 有助于驱动代码的设计。在编写能使测试通过的代码之前编写测试有助于在开发过程中保持高测试覆盖率。</p>
<h2 id="编写-minigrep-代码"><a href="#编写-minigrep-代码" class="headerlink" title="编写 minigrep 代码"></a>编写 minigrep 代码</h2><p>src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(&amp;config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;With text:\n&#123;&#125;&quot;, contents);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="comment">// println!(&quot;Search for &#123;&#125;&quot;, query);</span></span><br><span class="line">        <span class="comment">// println!(&quot;In file &#123;&#125;&quot;, filename);</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,args);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments:&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config)&#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>,e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数式语言特性-迭代器和闭包"><a href="#函数式语言特性-迭代器和闭包" class="headerlink" title="函数式语言特性:迭代器和闭包"></a>函数式语言特性:迭代器和闭包</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数</p>
<ul>
<li>匿名函数</li>
<li>保存为变量,作为参数</li>
<li>可以在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li>
<li>可从其定义的作用域捕获值</li>
</ul>
<p>文件名: src/main.rs</p>
<p>一个用来代替假定计算的函数，它大约会执行两秒钟</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">simulated_expensive_calculation</span>(intensity: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    intensity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件名: src/main.rs</p>
<p>程序的业务逻辑，它根据输入并调用 simulated_expensive_calculation 函数来打印出健身计划</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件名: src/main.rs</p>
<p>main 函数包含了用于 generate_workout 函数的模拟用户输入和模拟随机数输入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">simulated_user_specified_value</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">simulated_random_number</span> = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">generate_workout</span>(simulated_user_specified_value, simulated_random_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">       thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">       num</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包定义是 expensive_closure 赋值的 = 之后的部分。闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数；</li>
<li>如果<strong>有多于一个参数，可以使用逗号分隔，比如 |param1, param2|</strong>。</li>
<li>参数之后是存放闭包体的大括号 —— <strong>如果闭包体只有一行则大括号是可以省略的</strong>。大括号之后闭包的结尾，需要用于 let 语句的分号。因为闭包体的最后一行没有分号（正如函数体一样），所以闭包体（num）最后一行的返回值作为调用闭包时的返回值 。</li>
</ul>
<p>注意:</p>
<p>这个 let 语句意味着 expensive_closure 包含一个匿名函数的 <strong>定义</strong>，不是调用匿名函数的 <strong>返回值</strong>。</p>
<p><strong>重构代码</strong></p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">expensive_closure</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包的类型推断"><a href="#闭包的类型推断" class="headerlink" title="闭包的类型推断"></a>闭包的类型推断</h3><ul>
<li><strong>闭包不要求标注参数和返回值的类型</strong></li>
<li>闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型</li>
<li>可以手动添加类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>与函数的比较</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;<span class="comment">//函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;<span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;<span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;<span class="comment">//闭包</span></span><br></pre></td></tr></table></figure>
<p>src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>这个闭包在执行第二行代码时，编译器就能确定该闭包的类型是 String 了，而在执行第三行时就会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   Compiling rust_programming v0.1.0 (/home/zhaohang/repository/rust_programming)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:4:29</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> n = example_closure(5);</span><br><span class="line">  |             --------------- ^ expected `String`, found <span class="built_in">integer</span></span><br><span class="line">  |             |</span><br><span class="line">  |             arguments to this <span class="keyword">function</span> are incorrect</span><br><span class="line">  |</span><br><span class="line">note: expected because the closure was earlier called with an argument of <span class="built_in">type</span> `String`</span><br><span class="line"> --&gt; src/main.rs:3:29</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="built_in">let</span> s = example_closure(String::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of <span class="built_in">type</span> `String`</span><br><span class="line">  |             |</span><br><span class="line">  |             <span class="keyword">in</span> this closure call</span><br><span class="line">note: closure parameter defined here</span><br><span class="line"> --&gt; src/main.rs:2:28</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> example_closure = |x| x;</span><br><span class="line">  |                            ^</span><br><span class="line"><span class="built_in">help</span>: try using a conversion method</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> n = example_closure(5.to_string());</span><br><span class="line">  |                              ++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br></pre></td></tr></table></figure>
<h3 id="泛型参数闭包"><a href="#泛型参数闭包" class="headerlink" title="泛型参数闭包"></a>泛型参数闭包</h3><p>在上面的代码仍然把慢计算闭包调用了比所需更多的次数。解决这个问题的一个方法是在全部代码中的每一个需要多个慢计算闭包结果的地方，可以将结果保存进变量以供复用，这样就可以使用变量而不是再次调用闭包。但是这样就会有很多重复的保存结果变量的地方。</p>
<p>幸运的是，还有另一个可用的方案。可以<strong>创建一个存放闭包和调用闭包结果的结构体</strong>。该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。你可能见过这种模式被称 <strong>*memoization*</strong> 或 <strong>*lazy evaluation**</strong>（惰性求值）*。</p>
<h4 id="如何让-struct-持有闭包"><a href="#如何让-struct-持有闭包" class="headerlink" title="如何让 struct 持有闭包"></a>如何让 struct 持有闭包</h4><ul>
<li>struct 的定义需要知道所有字段的类型，即需要指明闭包的类型</li>
<li><strong>每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样</strong></li>
<li>所以需要使用:泛型和 Trait Bound</li>
</ul>
<p><strong>Fn Trait</strong></p>
<ul>
<li>由标准库提供</li>
<li><strong>所有的闭包都至少实现了以下 trait 之一:</strong><ul>
<li><strong>Fn</strong></li>
<li><strong>FnMut</strong></li>
<li><strong>FnOnce</strong></li>
</ul>
</li>
</ul>
<p>注意：<strong>函数也都实现了这三个</strong> <strong>Fn</strong> <strong>trait</strong>。如果不需要捕获环境中的值，则可以使用实现了 Fn trait 的函数而不是闭包。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体 Cacher 有一个泛型 T 的字段 calculation。</p>
<p>T 的 trait bound 指定了 T 是一个使用 Fn 的闭包。</p>
<p>任何我们希望储存到 Cacher 实例的 calculation 字段的闭包必须有一个 u32 参数（由 Fn 之后的括号的内容指定）并必须返回一个 u32（由 -&gt; 之后的内容）。</p>
<p>字段 value 是 Option<u32> 类型的。在执行闭包之前，value 将是 None。如果使用 Cacher 的代码请求闭包的结果，这时会执行闭包并将结果储存在 value 字段的 Some 成员中。接着<strong>如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 Some 成员中的结果</strong>。</p>
<p>重构代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expensive_result</span> = Cacher::<span class="title function_ invoke__">new</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, expensive_result.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, expensive_result.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                expensive_result.<span class="title function_ invoke__">value</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Cacher-实现的限制"><a href="#Cacher-实现的限制" class="headerlink" title="Cacher 实现的限制"></a>Cacher 实现的限制</h4><ol>
<li>第一个问题是 Cacher 实例假设对于 value 方法的任何 arg 参数值总是会返回相同的值。</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p>可以使用 HashMap 代替单个值:</p>
<ul>
<li><p>key: arg 参数</p>
</li>
<li><p>value: 执行闭包的结果</p>
</li>
</ul>
<ol>
<li>第二个问题是只能接收一个 u32 类型的参数和 u32 类型的返回值</li>
</ol>
<p><strong>解决方案:</strong></p>
<p>引入两个或多个泛型参数</p>
<h3 id="闭包会捕获其环境"><a href="#闭包会捕获其环境" class="headerlink" title="闭包会捕获其环境"></a>闭包会捕获其环境</h3><ul>
<li>可以捕获其环境并访问其被定义的作用域的变量,而普通函数则不能</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包<strong>会产生内存开销</strong><br> 闭包在 Rust 中是一个编译器生成的匿名结构体，结构体的字段就是捕获的变量。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器内部类似：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>, <span class="comment">// 捕获的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fn</span>() <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>捕获变量需要存储空间</strong></p>
<ul>
<li>如果捕获的是<strong>值</strong>，闭包会在自身结构体中存储该值。</li>
<li>如果捕获的是<strong>引用</strong>，闭包结构体中存储的是指针（引用本身也占空间）。</li>
</ul>
<p><strong>开销大小</strong></p>
<ul>
<li><strong>小变量（如 i32, bool）</strong>：几乎没有额外开销，存储在闭包的结构体里即可。</li>
<li><strong>大变量（如 String, Vec, HashMap）</strong>：<ul>
<li>如果 <code>move</code> 捕获，闭包会拷贝或移动整个对象（堆内存可能被绑定到闭包）。</li>
<li>如果只是引用捕获，闭包内部只存指针，但要保证引用生命周期有效。</li>
</ul>
</li>
</ul>
<h4 id="闭包从所在环境捕获值的方式"><a href="#闭包从所在环境捕获值的方式" class="headerlink" title="闭包从所在环境捕获值的方式"></a>闭包从所在环境捕获值的方式</h4><p>与函数获得参数的三种方式一样:</p>
<ul>
<li><p>取得所有权: <strong>FnOnce</strong></p>
<ul>
<li>FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境</strong>，<em>environment</em>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li>
</ul>
</li>
<li><p>可变借用: <strong>FnMut</strong></p>
<ul>
<li>FnMut 获取可变的借用值所以可以改变其环境</li>
</ul>
</li>
<li><p>不可变借用: <strong>Fn</strong></p>
<ul>
<li>Fn 从其环境获取不可变的借用值</li>
</ul>
</li>
</ul>
<p>创建闭包时，通过闭包对环境值的使用，Rust 推断出具体使用哪个 trait：</p>
<ul>
<li><strong>所有的闭包都实现了 FnOnce</strong></li>
<li><strong>没有移动捕获变量的实现了 FnMut</strong></li>
<li><strong>无需可变访问捕获变量的闭包实现了 Fn</strong></li>
</ul>
<p>实际上有一个层级关系，所有实现了 Fn 的都实现了 FnMut，所有实现了 FnMut 的，都实现了 FnOnce</p>
<h4 id="move-关键字"><a href="#move-关键字" class="headerlink" title="move 关键字"></a>move 关键字</h4><p>在参数列表前<strong>使用 move 关键字，可以强制闭包取得它所使用的环境值得所有权</strong></p>
<ul>
<li>当<strong>将闭包传递给新线程以移动数据使其归新线程所有</strong>时，此技术最为有用</li>
</ul>
<p>例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x 被移动进了闭包，因为闭包使用 move 关键字定义。接着闭包获取了 x 的所有权，同时 main 就不再允许在 println! 语句中使用 x 了。去掉 println! 即可修复问题。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>当指定 Fn trait bound 之一时，首先用 Fn,基于闭包体里得情况，如果需要 FnOnce 或 FnMut，编译器会再告诉你 </p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器模式允许你对一个序列的项进行某些处理。<strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑。当使用迭代器时，我们无需重新实现这些逻辑。</p>
<p>在 Rust 中，<strong>迭代器是 惰性的（<em>lazy</em>）</strong>，这意味着在调用方法使用迭代器之前它都不会有效果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Iterator-trait"><a href="#Iterator-trait" class="headerlink" title="Iterator trait"></a>Iterator trait</h3><ul>
<li>所有迭代器都实现了这个 trait</li>
<li>定义于标准库</li>
</ul>
<p>这个 trait 的定义看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>type Item 和 Self::Item，他们定义了 trait 的 <strong>关联类型</strong>（<em>associated type</em>）。</p>
<p>这段代码表明实现 Iterator trait 要求同时<strong>定义一个</strong> <strong>Item</strong> <strong>类型</strong>，这个 Item 类型被用作 <strong>next</strong> <strong>方法的返回值类型</strong>。换句话说，Item 类型将是迭代器返回元素的类型。</p>
<p>Iterator trait 仅要求实现一个方法：next</p>
<p>next:</p>
<ul>
<li>每次返回迭代中的一项</li>
<li>返回结果包裹在 Some 里</li>
<li>迭代结束，返回 None</li>
</ul>
<p>可直接在迭代器上调用 next 方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">iterator_demonstration</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>v1_iter 需要是可变的：在迭代器上调用 next 方法改变了迭代器中用来记录序列位置的状态。换句话说，代码 <strong>消费</strong>（consume）了，或使用了迭代器。每一个 next 调用都会从迭代器中消费一个项。</li>
<li>使用 for 循环时无需使 v1_iter 可变因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变。</li>
</ul>
<h4 id="几个迭代方法"><a href="#几个迭代方法" class="headerlink" title="几个迭代方法"></a>几个迭代方法</h4><ul>
<li><strong>iter</strong> 方法：在<strong>不可变引用上创建迭代器</strong>（元素的不可变引用）</li>
<li><strong>into_iter</strong> 方法：创建的<strong>迭代器会获得所有权</strong></li>
<li><strong>iter_mut</strong> 方法: <strong>迭代可变的引用</strong></li>
</ul>
<h3 id="消耗迭代器的方法"><a href="#消耗迭代器的方法" class="headerlink" title="消耗迭代器的方法"></a>消耗迭代器的方法</h3><ul>
<li>在标准库中，Iterator trait 由一些带默认实现的方法</li>
<li>其中有一些方法会调用 next 方法</li>
</ul>
<p>实现 Iterator trait 时必须实现 next 方法的原因之一</p>
<ul>
<li>调用 next 的叫做“<strong>消耗型适配器</strong>”</li>
</ul>
<p>因为调用它们会把迭代器耗尽</p>
<p>一个消费适配器的例子是 sum 方法。这个方法获取迭代器的所有权并反复调用 next 来遍历迭代器，因而会消费迭代器。当其遍历每一个项时，它将每一个项加总到一个总和并在迭代完成时返回总和。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">iterator_sum</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="产生其它迭代器的方法"><a href="#产生其它迭代器的方法" class="headerlink" title="产生其它迭代器的方法"></a>产生其它迭代器的方法</h3><p>Iterator trait 中定义了另一类方法，被称为 <strong>迭代器适配器</strong>（<em>iterator adaptors</em>），</p>
<ul>
<li>他们允许将当前迭代器变为不同类型的迭代器。</li>
<li>可以链式调用多个迭代器适配器。</li>
<li>不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let v1: Vec&lt;i32&gt; = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    v1.iter().map(|x| x + 1);</span><br></pre></td></tr></table></figure>
<p>该 map 方法使用闭包来调用每个元素以生成新的迭代器。 这里的闭包创建了一个新的迭代器，对其中 vector 中的每个元素都被加 1。</p>
<p>不过这些代码会产生一个警告：</p>
<p>= note: iterators are lazy and do nothing unless consumed</p>
<p><strong>代码实际上并没有做任何事；所指定的闭包从未被调用过</strong>。警告提醒了我们为什么：<strong>迭代器适配器是惰性的</strong>，而这里我们需要消费迭代器。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
<p>第二行代码的下划线实际上是让编译器去推断他的类型</p>
<p>collect 方法是一个<strong>消耗型适配器</strong>，把结果收集到一个集合类型中</p>
<p>因为 map 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作。这是一个展示如何使用闭包来自定义行为同时又复用 Iterator trait 提供的迭代行为的绝佳例子。</p>
<h3 id="使用闭包捕获环境"><a href="#使用闭包捕获环境" class="headerlink" title="使用闭包捕获环境"></a>使用闭包捕获环境</h3><p>filter 方法过滤器</p>
<ul>
<li>迭代器的 filter 方法获取一个使用迭代器的每一个项并返回布尔值的闭包。</li>
<li>如果闭包返回 true，其值将会包含在 filter 提供的新迭代器中。</li>
<li>如果闭包返回 false，其值不会包含在结果迭代器中。</li>
</ul>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">    <span class="comment">//闭包从环境中捕获了 `shoe_size` 变量并使用其值与每一只鞋的大小作比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">filters_by_size</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shoes</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">13</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sandal&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">in_my_size</span> = <span class="title function_ invoke__">shoes_in_size</span>(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            in_my_size,</span><br><span class="line">            <span class="built_in">vec!</span>[</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shoes_in_my_size 函数获取一个鞋子 vector 的所有权和一个鞋子大小作为参数。它返回一个只包含指定大小鞋子的 vector。</p>
<p>shoes_in_my_size 函数体中调用了 into_iter 来创建一个获取 vector 所有权的迭代器。接着调用 filter 将这个迭代器适配成一个只含有那些闭包返回 true 的元素的新迭代器。</p>
<p>闭包从环境中捕获了 shoe_size 变量并使用其值与每一只鞋的大小作比较，只保留指定大小的鞋子。最终，调用 collect 将迭代器适配器返回的值收集进一个 vector 并返回。</p>
<h3 id="创建自定义迭代器"><a href="#创建自定义迭代器" class="headerlink" title="创建自定义迭代器"></a>创建自定义迭代器</h3><p>trait Iterator定义中唯一要求提供的方法就是 next 方法。一旦定义了它，就可以使用所有其他由 Iterator trait 提供的拥有默认实现的方法来创建自定义迭代器了！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="comment">//这里将迭代器的关联类型 Item 设置为 u32，意味着迭代器会返回 u32 值集合。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 count 值小于 6，next 会返回封装在 Some 中的当前值，</span></span><br><span class="line">        <span class="comment">//不过如果 count 大于或等于 6，迭代器会返回 None。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">calling_next_directly</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过定义 next 方法实现 Iterator trait，我们现在就可以使用任何标准库定义的拥有默认实现的 Iterator trait 方法了，因为他们都使用了 next 方法的功能。</p>
<p>例如，出于某种原因我们希望获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在<strong>省略了第一个值</strong>之后产生的值配对，<strong>将每一对值相乘</strong>，<strong>只保留那些可以被三整除的结果</strong>，<strong>然后将所有保留的结果相加</strong>，这可以如示例 13-23 中的测试这样做：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">using_other_iterator_trait_methods</span>() &#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">           .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">           .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">           .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">           .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">       <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>示例 13-23：使用自定义的 Counter 迭代器的多种方法，注意Counter本身就是Iterator</p>
<p>注意 zip 只产生四对值；理论上第五对值 (5, None) 从未被产生，因为 zip 在任一输入迭代器返回 None 时也返回 None。</p>
<p>所有这些方法调用都是可能的，因为我们指定了 next 方法如何工作，而标准库则提供了其它调用 next 的方法的默认实现。</p>
<h3 id="改进-I-O-项目"><a href="#改进-I-O-项目" class="headerlink" title="改进 I/O 项目"></a>改进 I/O 项目</h3><h4 id="使用迭代器并去掉-clone"><a href="#使用迭代器并去掉-clone" class="headerlink" title="使用迭代器并去掉 clone"></a>使用迭代器并去掉 clone</h4><p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接使用-env-args-返回的迭代器"><a href="#直接使用-env-args-返回的迭代器" class="headerlink" title="直接使用 env::args 返回的迭代器"></a>直接使用 env::args 返回的迭代器</h4><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//let args: Vec&lt;String&gt; = env::args().collect();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(&amp;config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;With text:\n&#123;&#125;&quot;, contents);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(<span class="keyword">mut</span> args: std::env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// if args.len() &lt; 3 &#123;</span></span><br><span class="line">        <span class="comment">//     return Err(&quot;not enough arguments&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        args.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Didn&#x27;t get a query string&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Didn&#x27;t get a file name&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// println!(&quot;Search for &#123;&#125;&quot;, query);</span></span><br><span class="line">        <span class="comment">// println!(&quot;In file &#123;&#125;&quot;, filename);</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let mut result = Vec::new();</span></span><br><span class="line">    <span class="comment">// for line in contents.lines() &#123;</span></span><br><span class="line">    <span class="comment">//     if line.contains(query) &#123;</span></span><br><span class="line">    <span class="comment">//         result.push(line);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// result</span></span><br><span class="line"></span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let mut result = Vec::new();</span></span><br><span class="line">    <span class="comment">// let query = query.to_lowercase();</span></span><br><span class="line">    <span class="comment">// for line in contents.lines() &#123;</span></span><br><span class="line">    <span class="comment">//     if line.to_lowercase().contains(&amp;query) &#123;</span></span><br><span class="line">    <span class="comment">//         result.push(line);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// result</span></span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(query.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">as_str</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,args);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments:&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config)&#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>,e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能比较-循环-迭代器"><a href="#性能比较-循环-迭代器" class="headerlink" title="性能比较 循环/迭代器"></a>性能比较 循环/迭代器</h3><p>代器是 Rust 的 <strong>零成本抽象</strong>（<em>zero-cost abstractions</em>）之一，它意味着抽象并不会引入运行时开销，它与Bjarne Stroustrup（C++ 的设计和实现者）在 “Foundations of C++”（2012） 中所定义的 <strong>零开销</strong>（<em>zero-overhead</em>）如出一辙：</p>
<p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p>
<ul>
<li>Bjarne Stroustrup “Foundations of C++”</li>
</ul>
<p>从整体来说，C++ 的实现遵循了零开销原则：你不需要的，无需为他们买单。更有甚者的是：你需要的时候，也不可能找到其他更好的代码了。</p>
<ul>
<li>本贾尼·斯特劳斯特卢普 “Foundations of C++”</li>
</ul>
<h1 id="Cargo-和-crates-io"><a href="#Cargo-和-crates-io" class="headerlink" title="Cargo 和 crates.io"></a>Cargo 和 crates.io</h1><h2 id="采用发布配置自定义构建"><a href="#采用发布配置自定义构建" class="headerlink" title="采用发布配置自定义构建"></a>采用发布配置自定义构建</h2><p><strong>release profile</strong></p>
<ul>
<li>是预定义的</li>
<li>可自定义</li>
<li>每个 profile 配置独立于其它 profile</li>
</ul>
<p>cargo 主要的两个 profile</p>
<ul>
<li><strong>dev profile</strong>: 适用于开发 cargo build</li>
<li><strong>release profile</strong>: 适用于发布 cargo build —release</li>
</ul>
<h3 id="自定义-profile"><a href="#自定义-profile" class="headerlink" title="自定义 profile"></a>自定义 profile</h3><p>在 Cargo.toml 中添加[profile.xxxx]区域，在里面覆盖某人配置的子集</p>
<p>文件名: Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>opt-level 设置控制 Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下编译得快一些。这就是为什么 dev 的 opt-level 默认为 0。</p>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul>
<li>生成 HTML 文档</li>
<li>显示公共 Api 的文档注释: 如何使用 API</li>
<li>使用///</li>
<li>支持 Markdown</li>
<li>放置在说明条目前</li>
</ul>
<h3 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h3><p>运行 rustdoc 工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc</span><br></pre></td></tr></table></figure>
<p>把生成的文档放到 target/doc 下</p>
<h3 id="生成文档并浏览"><a href="#生成文档并浏览" class="headerlink" title="生成文档并浏览"></a>生成文档并浏览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc --open</span><br></pre></td></tr></table></figure>
<h3 id="常用章节"><a href="#常用章节" class="headerlink" title="常用章节"></a>常用章节</h3><p>#Examples</p>
<p>其它常用章节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Panics: 函数可能发生panic的场景</span><br><span class="line">Errors: 如果函数返回Result,描述可能的错误种类，以及可导致错误的条件</span><br><span class="line">Safety: 如果函数处于unsafe调用，就应该解释函数unsafe的原因，以及调用者确保的使用前提</span><br></pre></td></tr></table></figure>
<h3 id="文档注释作为测试"><a href="#文档注释作为测试" class="headerlink" title="文档注释作为测试"></a>文档注释作为测试</h3><p>运行 cargo test： 把文档注释中的示例代码作为测试来运行</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = my_crate::add_one(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(6, answer);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试 cargo test 运行像示例中 add_one 函数的文档；应该在测试结果中看到像这样的部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Doc-tests my_crate</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> src/lib.rs - add_one (line 5) ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.27s</span><br></pre></td></tr></table></figure>
<p>现在尝试改变函数或例子来使例子中的 assert_eq! 产生 panic。再次运行 cargo test，我们将会看到文档测试捕获到了例子与代码不再同步！</p>
<h3 id="为包含注释的项添加文档注释"><a href="#为包含注释的项添加文档注释" class="headerlink" title="为包含注释的项添加文档注释"></a>为包含注释的项添加文档注释</h3><ul>
<li>符号: //!</li>
<li>这类注释通常描述 crate 和模块</li>
</ul>
<p>crate root (按惯例 src/lib.rs)</p>
<p>一个模块内，将 crate 或模块作为一个整体进行记录</p>
<p>例子：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # My Crate</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `my_crate` is a collection of utilities to make performing certain</span></span><br><span class="line"><span class="comment">//! calculations more convenient.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-pub-use-导出方便使用的公共-API"><a href="#使用-pub-use-导出方便使用的公共-API" class="headerlink" title="使用 pub use 导出方便使用的公共 API"></a>使用 pub use 导出方便使用的公共 API</h2><p>你开发时候使用的文件架构可能并不方便用户。你的结构可能是一个包含多个层级的分层结构，不过这对于用户来说并不方便。这是因为想要使用被定义在很深层级中的类型的人可能很难发现这些类型的存在。他们也可能会厌烦要使用 use my_crate::some_module::another_module::UsefulType; 而不是 use my_crate::UsefulType; 来使用类型。</p>
<p><strong>使用</strong> <strong>pub use</strong> <strong>重导出（re-export）项来使公有结构不同于私有结构</strong></p>
<p>src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">/// The primary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The secondary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Combines two primary colors in equal amounts to create</span></span><br><span class="line">    <span class="comment">/// a secondary color.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        SecondaryColor::Green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> art::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">red</span> = PrimaryColor::Red;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">yellow</span> = PrimaryColor::Yellow;</span><br><span class="line">    <span class="title function_ invoke__">mix</span>(red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了从公有 API 中去掉 crate 的内部组织，我们可以采用示例 中的 art crate 并增加 pub use 语句来重导出项到顶层结构，如示例 14-5 所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::mix;</span><br><span class="line"><span class="keyword">use</span> art::PrimaryColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发布-Crate"><a href="#发布-Crate" class="headerlink" title="发布 Crate"></a>发布 Crate</h2><p>有了唯一的名称、版本号、由 cargo new 新建项目时增加的作者信息、描述和所选择的 license，已经准备好发布的项目的 <em>Cargo.toml</em> 文件可能看起来像这样：</p>
<p>文件名: Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A fun game where you guess what number the computer has chosen.&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br><span class="line"><span class="attr">author</span> = <span class="string">&quot;even629&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>
<p>Cargo 的文档 描述了其他可以指定的元信息，他们可以帮助你的 crate 更容易被发现和使用！</p>
<p>发布：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo publish</span><br></pre></td></tr></table></figure>
<p><strong>crate 一旦发布，就是永久性的:该版本无法覆盖，代码无法删除</strong></p>
<ul>
<li>目的：依赖于该版本的项目可继续正常工作</li>
</ul>
<h2 id="发布已存在-crate-的新版本"><a href="#发布已存在-crate-的新版本" class="headerlink" title="发布已存在 crate 的新版本"></a>发布已存在 crate 的新版本</h2><p>修改 version 重新发布</p>
<h2 id="使用-cargo-yank-从-Crates-io-撤回版本"><a href="#使用-cargo-yank-从-Crates-io-撤回版本" class="headerlink" title="使用 cargo yank 从 Crates.io 撤回版本"></a>使用 cargo yank 从 Crates.io 撤回版本</h2><ul>
<li>不可以删除 crate 之前的版本</li>
</ul>
<p>撤回某个版本会阻止新项目开始依赖此版本，不过所有现存此依赖的项目仍然能够下载和依赖这个版本。从本质上说，撤回意味着所有带有 <em>Cargo.lock</em> 的项目的依赖不会被破坏，同时任何新生成的 <em>Cargo.lock</em> 将不能使用被撤回的版本。</p>
<p>为了撤回一个 crate，运行 cargo yank 并指定希望撤回的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo yank --vers 1.0.1</span><br></pre></td></tr></table></figure>
<p>也可以撤销撤回操作，并允许项目可以再次开始依赖某个版本，通过在命令上增加 —undo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo yank --vers 1.0.1 --undo</span><br></pre></td></tr></table></figure>
<p>撤回 <strong>并没有</strong> 删除任何代码。举例来说，撤回功能并不意在删除不小心上传的秘密信息。如果出现了这种情况，请立即重新设置这些秘密信息。</p>
<h2 id="Cargo-工作空间（Workspaces）"><a href="#Cargo-工作空间（Workspaces）" class="headerlink" title="Cargo 工作空间（Workspaces）"></a>Cargo 工作空间（Workspaces）</h2><ul>
<li>cargo 工作空间： 帮助管理多个相互关联且需要协同开发的 crate</li>
<li>cargo 工作空间是一套共享同一个 Cargo.lock 和输出文件夹的包</li>
</ul>
<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div>
<p>为了在顶层 <em>add</em> 目录运行二进制 crate，可以通过 -p 参数和包名称来运行 cargo run 指定工作空间中我们希望使用的包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -p adder</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/adder`</span><br><span class="line">Hello, world! 10 plus one is 11!</span><br></pre></td></tr></table></figure>
<p>这会运行 <em>adder/src/main.rs</em> 中的代码，其依赖 add_one crate</p>
<h2 id="从-CRATES-IO-安装二进制-crate"><a href="#从-CRATES-IO-安装二进制-crate" class="headerlink" title="从 CRATES.IO 安装二进制 crate"></a>从 CRATES.IO 安装二进制 crate</h2><ul>
<li>命令: cargo install</li>
<li>来源 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://crates.io">https://crates.io</a></li>
<li>限制: 只能安装具有二进制目标 (binary target) 的 crate</li>
</ul>
<p>二进制目标 binary target:是一个可运行的程序</p>
<ul>
<li>拥有 src/main.rs 或其它被指定为二进制文件的 crate 生成</li>
</ul>
<p>通常: READEME 里面有关于 crate 的描述:</p>
<ul>
<li>拥有 library target</li>
<li>拥有 library target</li>
<li>两者兼备</li>
</ul>
<h3 id="cargo-install"><a href="#cargo-install" class="headerlink" title="cargo install"></a>cargo install</h3><p>cargo install 安装的二进制存放在根目录的 bin 文件夹</p>
<h2 id="使用自定义命令扩展-cargo"><a href="#使用自定义命令扩展-cargo" class="headerlink" title="使用自定义命令扩展 cargo"></a>使用自定义命令扩展 cargo</h2><ul>
<li>cargo 被设计成可以使用子命令来扩展</li>
<li>例：如果$PATH 中的某个二进制是 cargo-something，你可以像子命令一样运行:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo something</span><br></pre></td></tr></table></figure>
<ul>
<li>类似这样的自定义命令可以通过该命令列出: cargo —list</li>
<li>优点: 可以使用 cargo install 来安装扩展，像内置工具一样来运行</li>
</ul>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul>
<li><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。</li>
</ul>
<p>这个地址引用，或 “指向”（points at）一些其他数据。</p>
<ul>
<li>Rust 中最常见的指针是 <strong>引用</strong>（<em>reference</em>）。</li>
</ul>
<p>引用以 &amp; 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也<strong>没有任何额外开销</strong>，所以应用得最多。</p>
<ul>
<li><strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。</li>
</ul>
<h2 id="引用和智能指针的其它不同"><a href="#引用和智能指针的其它不同" class="headerlink" title="引用和智能指针的其它不同"></a>引用和智能指针的其它不同</h2><ul>
<li><strong>引用：只借用数据</strong></li>
<li><strong>智能指针：很多时候都拥有它所指向的数据</strong></li>
</ul>
<p><strong>智能指针的例子：</strong></p>
<ul>
<li>String 和 Vec<T></li>
<li>都拥有一片内存区域，且允许用户对其操作</li>
<li>还拥有元数据（例如容量等）</li>
<li>提供额外的功能或保障（String 保障其数据是合法的 UTF-8 编码）</li>
</ul>
<p><strong>智能指针的实现</strong></p>
<ul>
<li>智能指针通常使用 struct 实现，并且实现了：</li>
</ul>
<p>Deref 和 Drop 这两个 trait</p>
<ul>
<li><strong>Deref trait 允许智能指针 struct 的实例像引用一样使用</strong></li>
<li><strong>Drop trait 允许你自定义当智能指针实例走出作用域时的代码</strong></li>
</ul>
<h2 id="使用-Box指向堆上的数据"><a href="#使用-Box指向堆上的数据" class="headerlink" title="使用 Box指向堆上的数据"></a>使用 Box<T>指向堆上的数据</h2><ul>
<li><p>Box<T>是最简单的智能指针：</p>
</li>
<li><ul>
<li>允许你在 heap 上存储数据（而不是 stack）</li>
<li>stack 上是指向 heap 数据的指针</li>
<li>没有性能开销</li>
<li>没有其它额外功能</li>
</ul>
</li>
<li><p>Box<T>实现了 Deref trait 和 Drop trait</p>
</li>
</ul>
<p>多用于如下场景：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let b = Box::new(5);</span><br><span class="line">    println!(&quot;b = &#123;&#125;&quot;,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Box-赋能递归类型"><a href="#使用-Box-赋能递归类型" class="headerlink" title="使用 Box 赋能递归类型"></a>使用 Box 赋能递归类型</h2><ul>
<li>在编译时,Rust 需要知道一个类型所占的空间大小</li>
<li>而递归类型的大小无法在编译时确定</li>
<li>但 Box 类型的大小确定</li>
<li>在递归类型中使用 Box 就可以解决上述问题</li>
<li>函数式语言的 Cons List</li>
</ul>
<h2 id="Cons-List"><a href="#Cons-List" class="headerlink" title="Cons List"></a>Cons List</h2><p><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构。在 Lisp 中，cons 函数（“construct function” 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。</p>
<p>cons 函数的概念涉及到更常见的函数式编程术语；“将 <em>x</em> 与 <em>y</em> 连接” 通常意味着构建一个新的容器而将 <em>x</em> 的元素放在新容器的开头，其后则是容器 <em>y</em> 的元素。</p>
<p>cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 Nil 的值且没有下一项。cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。</p>
<p>代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。注意这不同于 “null” 或 “nil” 的概念，他们代表无效或缺失的值。</p>
<p>Cons List 并不是 Rust 的常用集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use crate::List::&#123;Cons,Nil&#125;;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let list = Cons(1, Cons(2, Cons(3, Nil)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32,List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiling my_box v0.1.0 (C:\Users\cauchy\Desktop\rust\my_box)</span><br><span class="line">error[E0072]: recursive type `List` has infinite size</span><br><span class="line"> --&gt; src\main.rs:6:1</span><br><span class="line">  |</span><br><span class="line">6 | enum List &#123;</span><br><span class="line">  | ^^^^^^^^^</span><br><span class="line">7 |     Cons(i32,List),</span><br><span class="line">  |              ---- recursive without indirection</span><br><span class="line">  |</span><br><span class="line">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle</span><br><span class="line">  |</span><br><span class="line">7 |     Cons(i32,Box&lt;List&gt;),</span><br><span class="line">  |              ++++    +</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0072`.</span><br><span class="line">error: could not compile `my_box` due to previous error</span><br></pre></td></tr></table></figure>
<h2 id="计算非递归类型的大小"><a href="#计算非递归类型的大小" class="headerlink" title="计算非递归类型的大小"></a>计算非递归类型的大小</h2><p>Message 枚举：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现</p>
<ul>
<li>Message::Quit 并不需要任何空间，</li>
<li>Message::Move 需要足够储存两个 i32 值的空间，依此类推。</li>
<li>因为 enum 实际上只会使用其中的一个成员，所以 Message 值所需的空间等于储存其最大成员的空间大小。</li>
</ul>
<p>与此相对当 Rust 编译器检查像上例的 List 这样的递归类型时会发生什么呢。编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，它检查其成员，从 Cons 成员开始。Cons 成员储存了一个 i32 值和一个 List 值，这样的计算将无限进行下去</p>
<h2 id="使用-Box给递归类型一个已知的大小"><a href="#使用-Box给递归类型一个已知的大小" class="headerlink" title="使用 Box给递归类型一个已知的大小"></a>使用 Box<T>给递归类型一个已知的大小</h2><ul>
<li>因为 Box<T> 是一个指针，我们总是知道它需要多少空间</li>
</ul>
<p>——- 指针的大小并不会根据其指向的数据量而改变。</p>
<ul>
<li>Box<T></li>
</ul>
<ol>
<li>只提供了”间接”存储和 heap 内存分配的功能</li>
<li>没有其它额外功能</li>
<li>没有性能开销</li>
<li>适用于需要间接存储的场景，例如 Cons List</li>
<li>实现了 Deref trait 和 Drop trait</li>
</ol>
<h2 id="Dref-Trait"><a href="#Dref-Trait" class="headerlink" title="Dref Trait"></a>Dref Trait</h2><ul>
<li>实现 Deref Trait 使我们可以<strong>自定义解引用运算符*的行为</strong></li>
<li>通过实现 Deref，智能指针可<strong>像引用一样来处理</strong></li>
</ul>
<h2 id="解引用运算符"><a href="#解引用运算符" class="headerlink" title="解引用运算符"></a>解引用运算符</h2><p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把-Box当作引用"><a href="#把-Box当作引用" class="headerlink" title="把 Box当作引用"></a>把 Box<T>当作引用</h2><p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = Box::new(x);</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义自己的智能指针"><a href="#定义自己的智能指针" class="headerlink" title="定义自己的智能指针"></a>定义自己的智能指针</h2><p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct MyBox&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    fn new(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的编译错误是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling deref-example v0.1.0 (file:///projects/deref-example)</span><br><span class="line">error[E0614]: type `MyBox&lt;&#123;integer&#125;&gt;` cannot be dereferenced</span><br><span class="line">  --&gt; src/main.rs:14:19</span><br><span class="line">   |</span><br><span class="line">14 |     assert_eq!(5, *y);</span><br><span class="line">   |                   ^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0614`.</span><br><span class="line">error: could not compile `deref-example` due to previous error</span><br></pre></td></tr></table></figure>
<p>MyBox<T> 类型不能解引用，因为我们尚未在该类型实现这个功能。为了启用 * 运算符的解引用功能，需要实现 Deref trait。</p>
<h2 id="通过实现-Deref-trait-将某类型像引用一样处理"><a href="#通过实现-Deref-trait-将某类型像引用一样处理" class="headerlink" title="通过实现 Deref trait 将某类型像引用一样处理"></a>通过实现 Deref trait 将某类型像引用一样处理</h2><ul>
<li>标准库中的 Deref trait 要求我们实现一个 deref 方法：</li>
</ul>
<p>— 该方法借用 self</p>
<p>— 返回一个指向内部数据的引用</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Deref;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;</span><br><span class="line">    type Target = T;</span><br><span class="line"></span><br><span class="line">    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        &amp;self.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入 *y 时，Rust 事实上在底层运行了如下代码：</p>
<p>*(y.deref())</p>
<h2 id="函数和方法的隐式解引用转化（Deref-Coercion）"><a href="#函数和方法的隐式解引用转化（Deref-Coercion）" class="headerlink" title="函数和方法的隐式解引用转化（Deref Coercion）"></a>函数和方法的隐式解引用转化（Deref Coercion）</h2><ul>
<li>Deref Coercion 是为<strong>函数和方法</strong>提供的一种便捷特性</li>
<li>假设 T 实现了 Deref trait: Deref Coercion 可以把 T 的引用转化为 T 经过 Deref 操作后生成的引用</li>
<li>当把某类型的引用传递给函数或方法时，但它的类型于定义的参数类型不匹配:</li>
</ul>
<ol>
<li>Deref Coercion 就会自动发生</li>
<li>编译器会对 deref 进行一系列调用，来把它转为所需的参数类型</li>
<li>它在编译时完成，没有额外性能开销</li>
</ol>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn hello(name: &amp;str) &#123;</span><br><span class="line">    println!(&quot;Hello, &#123;&#125;!&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let m = MyBox::new(String::from(&quot;Rust&quot;));</span><br><span class="line">    //&amp;m &amp;MyBox&lt;String&gt;</span><br><span class="line">    //deref &amp;String</span><br><span class="line">    //&amp;String &amp;str</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里使用 &amp;m 调用 hello 函数，其为 MyBox<String> 值的引用</li>
<li>因为示例 中在 MyBox<T> 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox<String> 变为 &amp;String。</li>
<li>标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。</li>
</ol>
<p>如果 Rust 没有实现 Deref 强制转换，为了使用 &amp;MyBox<String> 类型的值调用 hello，则不得不编写以下的代码</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let m = MyBox::new(String::from(&quot;Rust&quot;));</span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解引用与可变性"><a href="#解引用与可变性" class="headerlink" title="解引用与可变性"></a>解引用与可变性</h2><ul>
<li>可使用 DerefMut trait 重载可变引用的*运算符</li>
<li>在类型和 trait 在下列三种情况发生时，Rust 会执行 deref coercion:</li>
</ul>
<ol>
<li>当 T: Deref<Target=U>，允许&amp;T 转换为&amp;U</li>
<li>当 T: Deref<Target=U>，允许&amp;mut T 转换为&amp;mut U</li>
<li>当 T: Deref<Target=U>，允许&amp;mut T 转换为&amp;U</li>
</ol>
<h2 id="Drop-Trait"><a href="#Drop-Trait" class="headerlink" title="Drop Trait"></a>Drop Trait</h2><ul>
<li>实现 Drop Trait 可以让我们自定义<strong>当值将要离开作用域时发生的动作</strong></li>
</ul>
<ol>
<li>例如：文件，网络资源释放等</li>
<li>任何类型都可以实现 Drop trait</li>
</ol>
<ul>
<li>Drop Trait 只要求你实现 drop 方法</li>
</ul>
<ol>
<li>参数： 对 self 的可变引用</li>
</ol>
<ul>
<li>Drop trait 在预导入模块里</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct CustomSmartPointer &#123;</span><br><span class="line">    data: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Drop for CustomSmartPointer &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123;</span><br><span class="line">        println!(&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;, self.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = CustomSmartPointer &#123;</span><br><span class="line">        data: String::from(&quot;my stuff&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    let d = CustomSmartPointer &#123;</span><br><span class="line">        data: String::from(&quot;other stuff&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;CustomSmartPointers created.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行这个程序，会出现如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.1.0 (file:///projects/drop-example)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.60s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointers created.</span><br><span class="line">Dropping CustomSmartPointer with data `other stuff`!</span><br><span class="line">Dropping CustomSmartPointer with data `my stuff`!</span><br></pre></td></tr></table></figure>
<h3 id="使用-std-mem-drop-来提前-drop-值"><a href="#使用-std-mem-drop-来提前-drop-值" class="headerlink" title="使用 std::mem::drop 来提前 drop 值"></a>使用 std::mem::drop 来提前 drop 值</h3><ul>
<li>很难直接禁用自动的 drop 功能，也没必要</li>
</ul>
<ol>
<li>Drop trait 的目的就是进行自动的释放处理逻辑</li>
</ol>
<ul>
<li>Rust 不允许手动调用 Drop trait 的 drop 方法</li>
<li>但可以调用标准库的 std::mem::drop 函数(prelude)，来提前 drop 值</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let c = CustomSmartPointer &#123;</span><br><span class="line">        data: String::from(&quot;some data&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;CustomSmartPointer created.&quot;);</span><br><span class="line">    drop(c);</span><br><span class="line">    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码会打印出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.1.0 (file:///projects/drop-example)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.73s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointer created.</span><br><span class="line">Dropping CustomSmartPointer with data `some data`!</span><br><span class="line">CustomSmartPointer dropped before the end of main.</span><br></pre></td></tr></table></figure>
<p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 drop 只会在值不再被使用时被调用一次。</p>
<h2 id="Rc引用计数智能指针"><a href="#Rc引用计数智能指针" class="headerlink" title="Rc引用计数智能指针"></a>Rc<T>引用计数智能指针</h2><ul>
<li>有时一个值会有多个所有者</li>
<li>为了支持多重所有权: Rt<T></li>
</ul>
<ol>
<li>reference counting(引用计数)</li>
<li>追踪到值得引用</li>
<li>0 个引用:该值可以被清理掉</li>
</ol>
<ul>
<li>需要在 heap 上分配数据，这些数据被程序得多个部分读取（只读），但在编译时无法确定哪个部分最后使用完这些数据</li>
<li>注意 Rc<T> 只能用于单线程场景；</li>
</ul>
<p>我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如图所示：</p>
<p>文件名: src/main.rs</p>
<p>不能用两个 Box<T> 的列表尝试共享第三个列表的所有权</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Box&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));</span><br><span class="line">    let b = Cons(3, Box::new(a));</span><br><span class="line">    let c = Cons(4, Box::new(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们修改 List 的定义为使用 Rc<T> 代替 Box<T>，如列表 所示。现在每一个 Cons 变量都包含一个值和一个指向 List 的 Rc<T>。当创建 b 时，不同于获取 a 的所有权，这里会克隆 a 所包含的 Rc<List>，这会将引用计数从 1 增加到 2 并允许 a 和 b 共享 Rc<List> 中数据的所有权。创建 c 时也会克隆 a，这会将引用计数从 2 增加为 3。每次调用 Rc::clone，Rc<List> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));</span><br><span class="line">    let b = Cons(3, Rc::clone(&amp;a));</span><br><span class="line">    let c = Cons(4, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以调用 a.clone() 而不是 Rc::clone(&amp;a)，不过在这里 Rust 的习惯是使用 Rc::clone。</p>
<ul>
<li>Rc::clone 的实现并不像大部分类型的 clone 实现那样对所有数据进行深拷贝。</li>
<li>Rc::clone 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间。</li>
</ul>
<h2 id="克隆-Rc会增加引用计数"><a href="#克隆-Rc会增加引用计数" class="headerlink" title="克隆 Rc会增加引用计数"></a>克隆 Rc<T>会增加引用计数</h2><p>文件名: src/main.rs</p>
<p>Rc::strong_count 获得引用计数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));</span><br><span class="line">    println!(&quot;count after creating a = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    let b = Cons(3, Rc::clone(&amp;a));</span><br><span class="line">    println!(&quot;count after creating b = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        let c = Cons(4, Rc::clone(&amp;a));</span><br><span class="line">        println!(&quot;count after creating c = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;count after c goes out of scope = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.45s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">count after creating a = 1</span><br><span class="line">count after creating b = 2</span><br><span class="line">count after creating c = 3</span><br><span class="line">count after c goes out of scope = 2</span><br></pre></td></tr></table></figure>
<p>我们能够看到 a 中 Rc<List> 的初始引用计数为 1，接着每次调用 clone，计数会增加 1。当 c 离开作用域时，计数减 1。不必像调用 Rc::clone 增加引用计数那样调用一个函数来减少计数；Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数。</p>
<p>从这个例子我们所不能看到的是，在 main 的结尾当 b 然后是 a 离开作用域时，此处计数会是 0，同时 Rc<List> 被完全清理。使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。</p>
<ul>
<li>Rc<T>通过<strong>不可变引用</strong>， Rc<T> 允许在程序的多个部分之间只读地共享数据。</li>
<li>如果 Rc<T> 也允许多个可变引用，则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。</li>
</ul>
<h2 id="RefCell和内部可变性"><a href="#RefCell和内部可变性" class="headerlink" title="RefCell和内部可变性"></a>RefCell<T>和内部可变性</h2><h3 id="内部可变性（interior-mutability"><a href="#内部可变性（interior-mutability" class="headerlink" title="内部可变性（interior mutability)"></a>内部可变性（interior mutability)</h3><ul>
<li>interior mutability 是 Rust 的设计模式之一</li>
<li>它允许你在支持有不可变引用的前提下对数据进行修改</li>
</ul>
<p>数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则</p>
<ul>
<li>与 Rc<T>不同，RefCell<T>类型代表了其持有数据的唯一所有权</li>
</ul>
<p>回忆借用规则：</p>
<ol>
<li>在任何给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用</li>
<li>引用总是有效的</li>
</ol>
<h3 id="RefCell与-Box的区别"><a href="#RefCell与-Box的区别" class="headerlink" title="RefCell与 Box的区别"></a>RefCell<T>与 Box<T>的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>Box**</strong>&lt;*<strong>*T**</strong>&gt;**</th>
<th><strong>RefCell**</strong>&lt;*<strong>*T**</strong>&gt;**</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>编译阶段</strong>强制代码遵守借用规则</td>
<td>只会在<strong>运行时</strong>检查借用规则</td>
</tr>
<tr>
<td>否则出现错误</td>
<td>否则触发 panic</td>
</tr>
</tbody>
</table>
</div>
<h3 id="借用规则在不同阶段进行检查的比较"><a href="#借用规则在不同阶段进行检查的比较" class="headerlink" title="借用规则在不同阶段进行检查的比较"></a>借用规则在不同阶段进行检查的比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>编译阶段</strong></th>
<th><strong>运行时</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>尽早暴露问题</td>
<td>问题暴露延后，甚至到生产环境</td>
</tr>
<tr>
<td>没有任何运行时开销</td>
<td>因借用计数产生些许性能损失</td>
</tr>
<tr>
<td>对大多数场景是最佳选择</td>
<td>实现某些特定的内存安全场景(不可变环境中修改自身数据)</td>
</tr>
<tr>
<td>是 Rust 的默认行为</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>与 Rc<T>类似，只能用于<strong>单线程</strong>场景</li>
</ul>
<h3 id="选择-Box，Rc，RefCell的依据"><a href="#选择-Box，Rc，RefCell的依据" class="headerlink" title="选择 Box，Rc，RefCell的依据"></a>选择 Box<T>，Rc<T>，RefCell<T>的依据</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>Box**</strong>&lt;*<strong>*T**</strong>&gt;**</th>
<th><strong>Rc**</strong>&lt;*<strong>*T**</strong>&gt;**</th>
<th><strong>RefCell**</strong>&lt;*<strong>*T**</strong>&gt;**</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一数据的所有者</td>
<td>一个</td>
<td>多个</td>
<td>一个</td>
</tr>
<tr>
<td>可变性,借用检查</td>
<td>可变，不可变借用(编译时检查)</td>
<td>不可变借用(编译时检查)</td>
<td>可变，不可变借用（运行时检查）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="内部可变性：可变的借用一个不可变的值"><a href="#内部可变性：可变的借用一个不可变的值" class="headerlink" title="内部可变性：可变的借用一个不可变的值"></a>内部可变性：可变的借用一个不可变的值</h3><p>借用规则的一个推论是当有一个不可变值时，不能可变地借用它。例如，如下代码不能编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;mut x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尝试编译，会得到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling borrowing v0.1.0 (file:///projects/borrowing)</span><br><span class="line">error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable</span><br><span class="line"> --&gt; src/main.rs:3:13</span><br></pre></td></tr></table></figure>
<p>如下是一个我们想要测试的场景：我们在编写一个记录某个值与最大值的差距的库，并根据当前值与最大值的差距来发送消息。例如，这个库可以用于记录用户所允许的 API 调用数量限额。</p>
<p>该库只提供记录与最大值的差距，以及何种情况发送什么消息的功能。使用此库的程序则期望提供实际发送消息的机制：程序可以选择记录一条消息、发送 email、发送短信等等。库本身无需知道这些细节；只需实现其提供的 Messenger trait 即可。示例 15-20 展示了库代码：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">pub trait Messenger &#123;</span><br><span class="line">    fn send(&amp;self, msg: &amp;str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct LimitTracker&lt;&#x27;a, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;&#x27;a T,</span><br><span class="line">    value: usize,</span><br><span class="line">    max: usize,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;&#x27;a, T&gt; LimitTracker&lt;&#x27;a, T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: 0,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn set_value(&amp;mut self, value: usize) &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        let percentage_of_max = self.value as f64 / self.max as f64;</span><br><span class="line"></span><br><span class="line">        if percentage_of_max &gt;= 1.0 &#123;</span><br><span class="line">            self.messenger.send(&quot;Error: You are over your quota!&quot;);</span><br><span class="line">        &#125; else if percentage_of_max &gt;= 0.9 &#123;</span><br><span class="line">            self.messenger</span><br><span class="line">                .send(&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;);</span><br><span class="line">        &#125; else if percentage_of_max &gt;= 0.75 &#123;</span><br><span class="line">            self.messenger</span><br><span class="line">                .send(&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    struct MockMessenger &#123;</span><br><span class="line">        sent_messages: Vec&lt;String&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl MockMessenger &#123;</span><br><span class="line">        fn new() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: vec![],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Messenger for MockMessenger &#123;</span><br><span class="line">        fn send(&amp;self, message: &amp;str) &#123;</span><br><span class="line">            self.sent_messages.push(String::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_sends_an_over_75_percent_warning_message() &#123;</span><br><span class="line">        let mock_messenger = MockMessenger::new();</span><br><span class="line">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(80);</span><br><span class="line"></span><br><span class="line">        assert_eq!(mock_messenger.sent_messages.len(), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码中一个重要部分是拥有一个方法 send 的 Messenger trait，其获取一个 self 的<strong>不可变引用</strong>和文本信息。这个 trait 是 mock 对象所需要实现的接口库，这样 mock 就能像一个真正的对象那样使用了。另一个重要的部分是我们需要测试 LimitTracker 的 set_value 方法的行为。可以改变传递的 value 参数的值，不过 set_value 并没有返回任何可供断言的值。也就是说，如果使用某个实现了 Messenger trait 的值和特定的 max 创建 LimitTracker，当传递不同 value 值时，消息发送者应被告知发送合适的消息。</p>
<p>我们所需的 mock 对象是，调用 send 并不实际发送 email 或消息，而是只记录信息被通知要发送了。可以新建一个 mock 对象实例，用其创建 LimitTracker，调用 LimitTracker 的 set_value 方法，然后检查 mock 对象是否有我们期望的消息。示例 15-21 展示了一个如此尝试的 mock 对象实现，不过借用检查器并不允许：</p>
<p>然而，这个测试是有问题的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo test</span><br><span class="line">   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)</span><br><span class="line">error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</span><br><span class="line">  --&gt; src/lib.rs:58:13</span><br><span class="line">   |</span><br><span class="line">2  |     fn send(&amp;self, msg: &amp;str);</span><br><span class="line">   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`</span><br><span class="line">...</span><br><span class="line">58 |             self.sent_messages.push(String::from(message));</span><br><span class="line">   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `limit-tracker` due to previous error</span><br><span class="line">warning: build failed, waiting for other jobs to finish...</span><br><span class="line">error: build failed</span><br></pre></td></tr></table></figure>
<p>不能修改 MockMessenger 来记录消息，因为 send 方法获取了 self 的不可变引用。我们也不能参考错误文本的建议使用 &amp;mut self 替代，因为这样 send 的签名就不符合 Messenger trait 定义中的签名了（可以试着这么改，看看会出现什么错误信息）。</p>
<p>这正是内部可变性的用武之地！我们将通过 RefCell 来储存 sent_messages，然后 send 将能够修改 sent_messages 并储存消息。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line">    use std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    struct MockMessenger &#123;</span><br><span class="line">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl MockMessenger &#123;</span><br><span class="line">        fn new() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::new(vec![]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Messenger for MockMessenger &#123;</span><br><span class="line">        fn send(&amp;self, message: &amp;str) &#123;</span><br><span class="line">            self.sent_messages.borrow_mut().push(String::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_sends_an_over_75_percent_warning_message() &#123;</span><br><span class="line">        // --snip--</span><br><span class="line"></span><br><span class="line">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-RefCell在运行时记录借用信息"><a href="#使用-RefCell在运行时记录借用信息" class="headerlink" title="使用 RefCell在运行时记录借用信息"></a>使用 RefCell<T>在运行时记录借用信息</h3><ul>
<li>两个方法（安全接口）</li>
</ul>
<ol>
<li>borrow 方法：返回智能指针 Ref<T>，它实现了 Deref</li>
<li>borrow_mut 方法：返回 RefMut<T>，它实现了 Deref</li>
</ol>
<ul>
<li>RefCell<T>会记录当前存在多少个活跃的 Ref<T>和 RefMut<T>智能指针</li>
</ul>
<ol>
<li>每次调用 borrow：不可变借用计数+1</li>
<li>任何一个 Ref<T>的值离开作用域被释放时：不可变借用计数-1</li>
<li>每次调用 borrow_mut: 可变借用计数+1</li>
<li>任何一个 RefMut<T>的值利开作用域被释放时：可变借用计数-1</li>
</ol>
<ul>
<li>Rust 以此计数来维护借用检查规则：</li>
</ul>
<p>任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用</p>
<h3 id="结合-Rc-和-RefCell-来拥有多个可变数据所有者"><a href="#结合-Rc-和-RefCell-来拥有多个可变数据所有者" class="headerlink" title="结合 Rc 和 RefCell 来拥有多个可变数据所有者"></a>结合 Rc 和 RefCell 来拥有多个可变数据所有者</h3><p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let value = Rc::new(RefCell::new(5));</span><br><span class="line"></span><br><span class="line">    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));</span><br><span class="line">    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += 10;</span><br><span class="line"></span><br><span class="line">    println!(&quot;a after = &#123;:?&#125;&quot;, a);</span><br><span class="line">    println!(&quot;b after = &#123;:?&#125;&quot;, b);</span><br><span class="line">    println!(&quot;c after = &#123;:?&#125;&quot;, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们打印出 a、b 和 c 时，可以看到他们都拥有修改后的值 15 而不是 5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.63s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span><br><span class="line">b after = Cons(RefCell &#123; value: 3 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br><span class="line">c after = Cons(RefCell &#123; value: 4 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br></pre></td></tr></table></figure>
<h2 id="其它可实现内部可变性的类型"><a href="#其它可实现内部可变性的类型" class="headerlink" title="其它可实现内部可变性的类型"></a>其它可实现内部可变性的类型</h2><ul>
<li>Cell<T>：通过复制来访问数据</li>
<li>Mutex<T>：用于实现跨线程的情形下的内部可变性模式</li>
</ul>
<h2 id="循环引用导致内存泄漏"><a href="#循环引用导致内存泄漏" class="headerlink" title="循环引用导致内存泄漏"></a>循环引用导致内存泄漏</h2><p>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 <strong>内存泄漏</strong>（<em>memory leak</em>）），但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的。这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl List &#123;</span><br><span class="line">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        match self &#123;</span><br><span class="line">            Cons(_, item) =&gt; Some(item),</span><br><span class="line">            Nil =&gt; None,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));</span><br><span class="line"></span><br><span class="line">    println!(&quot;a initial rc count = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span><br><span class="line"></span><br><span class="line">    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));</span><br><span class="line"></span><br><span class="line">    println!(&quot;a rc count after b creation = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    println!(&quot;b initial rc count = &#123;&#125;&quot;, Rc::strong_count(&amp;b));</span><br><span class="line">    println!(&quot;b next item = &#123;:?&#125;&quot;, b.tail());</span><br><span class="line"></span><br><span class="line">    if let Some(link) = a.tail() &#123;</span><br><span class="line">        *link.borrow_mut() = Rc::clone(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;b rc count after changing a = &#123;&#125;&quot;, Rc::strong_count(&amp;b));</span><br><span class="line">    println!(&quot;a rc count after changing a = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line"></span><br><span class="line">    // Uncomment the next line to see that we have a cycle;</span><br><span class="line">    // it will overflow the stack</span><br><span class="line">    // println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果保持最后的 println! 行注释并运行代码，会得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.53s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a initial rc count = 1</span><br><span class="line">a next item = Some(RefCell &#123; value: Nil &#125;)</span><br><span class="line">a rc count after b creation = 2</span><br><span class="line">b initial rc count = 1</span><br><span class="line">b next item = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">b rc count after changing a = 2</span><br><span class="line">a rc count after changing a = 2</span><br></pre></td></tr></table></figure>
<p>如果取消最后 println! 的注释并运行程序，Rust 会尝试打印出 a 指向 b 指向 a 这样的循环直到栈溢出。</p>
<p><strong>防止内存泄漏的解决办法</strong></p>
<ul>
<li>依靠开发者来保证，不能依靠 Rust</li>
<li>重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权</li>
</ul>
<ol>
<li>循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系</li>
<li>而只有所有权关系才影响值的清理</li>
</ol>
<h3 id="避免引用循环：将-Rc-变为-Weak"><a href="#避免引用循环：将-Rc-变为-Weak" class="headerlink" title="避免引用循环：将 Rc 变为 Weak"></a>避免引用循环：将 Rc<T> 变为 Weak<T></h3><ul>
<li>Rc::clone 为 Rc<T>实例的 strong_count 加 1，Rc<T>的实例只有在 strong_count 为 0 时才会被清理</li>
<li>Rc<T>实例通过调用 Rc::downgrade 方法可以创建值的 Weak Reference（弱引用）</li>
</ul>
<ol>
<li>返回类型是 Weak<T>（智能指针）</li>
<li>调用 Rc::downgrade 会为 weak_count 加 1</li>
</ol>
<ul>
<li>Rc<T>使用 weak_count 来追踪存在多少 Weak<T></li>
<li>weak_count 不为 0 并不影响 Rc<T>实例的清理</li>
</ul>
<h3 id="Strong-VS-Weak"><a href="#Strong-VS-Weak" class="headerlink" title="Strong VS Weak"></a>Strong VS Weak</h3><ul>
<li>Strong Reference 是关于如何分享 Rc<T>实例的所有权</li>
<li>Weak Reference 并不表达上述意思</li>
<li>使用 Weak Reference 并不会创建循环引用：</li>
</ul>
<p>当 Strong Reference 数量为 0 的时候，Weak Reference 会自动断开</p>
<ul>
<li>在使用 Weak<T>前，需保证它指向的值仍然存在：</li>
</ul>
<p>在 Weak<T>实例上调用 upgrade 方法，返回 Option<Rc<T>&gt;</p>
<h4 id="创建树形数据结构：带有子节点的-Node"><a href="#创建树形数据结构：带有子节点的-Node" class="headerlink" title="创建树形数据结构：带有子节点的 Node"></a>创建树形数据结构：带有子节点的 Node</h4><p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Node &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let leaf = Rc::new(Node &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        children: RefCell::new(vec![]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let branch = Rc::new(Node &#123;</span><br><span class="line">        value: 5,</span><br><span class="line">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这里克隆了 leaf 中的 Rc<Node> 并储存在了 branch 中，这意味着 leaf 中的 Node 现在有两个所有者：leaf 和 branch。可以通过 branch.children 从 branch 中获得 leaf，不过无法从 leaf 到 branch。leaf 没有到 branch 的引用且并不知道他们相互关联。我们希望 leaf 知道 branch 是其父节点。稍后我们会这么做</p>
<h4 id="增加从子到父的引用"><a href="#增加从子到父的引用" class="headerlink" title="增加从子到父的引用"></a>增加从子到父的引用</h4><p>为了使子节点知道其父节点，需要在 Node 结构体定义中增加一个 parent 字段。问题是 parent 的类型应该是什么。我们知道其不能包含 Rc<T>，因为这样 leaf.parent 将会指向 branch 而 branch.children 会包含 leaf 的指针，这会形成引用循环，会造成其 strong_count 永远也不会为 0。</p>
<p>现在换一种方式思考这个关系:</p>
<ul>
<li>父节点应该拥有其子节点：</li>
<li>如果父节点被丢弃了，其子节点也应该被丢弃。</li>
<li>然而子节点不应该拥有其父节点：</li>
<li>如果丢弃子节点，其父节点应该依然存在。</li>
</ul>
<p>这正是弱引用的例子！</p>
<p>所以 parent 使用 Weak<T> 类型而不是 Rc<T>，具体来说是 RefCell<Weak<Node>&gt;。现在 Node 结构体定义看起来像这样：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Node &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let leaf = Rc::new(Node &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(vec![]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;leaf parent = &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    let branch = Rc::new(Node &#123;</span><br><span class="line">        value: 5,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    println!(&quot;leaf parent = &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 leaf 节点类似于示例 15-27 中如何创建 leaf 节点的，除了 parent 字段有所不同：leaf 开始时没有父节点，所以我们新建了一个空的 Weak 引用实例。</p>
<p>此时，当尝试使用 upgrade 方法获取 leaf 的父节点引用时，会得到一个 None 值。如第一个 println! 输出所示：</p>
<p>leaf parent = None</p>
<p>当创建 branch 节点时，其也会新建一个 Weak<Node> 引用，因为 branch 并没有父节点。leaf 仍然作为 branch 的一个子节点。一旦在 branch 中有了 Node 实例，就可以修改 leaf 使其拥有指向父节点的 Weak<Node> 引用。这里使用了 leaf 中 parent 字段里的 RefCell<Weak<Node>&gt; 的 borrow_mut 方法，接着使用了 Rc::downgrade 函数来从 branch 中的 Rc<Node> 值创建了一个指向 branch 的 Weak<Node> 引用。</p>
<p>当再次打印出 leaf 的父节点时，这一次将会得到存放了 branch 的 Some 值：现在 leaf 可以访问其父节点了！当打印出 leaf 时，我们也避免了如示例 15-26 中最终会导致栈溢出的循环：Weak<Node> 引用被打印为 (Weak)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>没有无限的输出表明这段代码并没有造成引用循环。这一点也可以从观察 Rc::strong_count 和 Rc::weak_count 调用的结果看出。</p>
<p><strong>可视化 strong_count 和 weak_count 的改变</strong>让我们通过创建了一个新的内部作用域并将 branch 的创建放入其中，来观察 Rc<Node> 实例的 strong_count 和 weak_count 值的变化。这会展示当 branch 创建和离开作用域被丢弃时会发生什么。这些修改如示例 15-29 所示：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let leaf = Rc::new(Node &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(vec![]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println!(</span><br><span class="line">        &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let branch = Rc::new(Node &#123;</span><br><span class="line">            value: 5,</span><br><span class="line">            parent: RefCell::new(Weak::new()),</span><br><span class="line">            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">        println!(</span><br><span class="line">            &quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">            Rc::strong_count(&amp;branch),</span><br><span class="line">            Rc::weak_count(&amp;branch),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        println!(</span><br><span class="line">            &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">            Rc::strong_count(&amp;leaf),</span><br><span class="line">            Rc::weak_count(&amp;leaf),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;leaf parent = &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());</span><br><span class="line">    println!(</span><br><span class="line">        &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 15-29：在内部作用域创建 branch 并检查其强弱引用计数</p>
<p>一旦创建了 leaf，其 Rc<Node> 的强引用计数为 1，弱引用计数为 0。在内部作用域中创建了 branch 并与 leaf 相关联，此时 branch 中 Rc<Node> 的强引用计数为 1，弱引用计数为 1（因为 leaf.parent 通过 Weak<Node> 指向 branch）。这里 leaf 的强引用计数为 2，因为现在 branch 的 branch.children 中储存了 leaf 的 Rc<Node> 的拷贝，不过弱引用计数仍然为 0。</p>
<p>当内部作用域结束时，branch 离开作用域，Rc<Node> 的强引用计数减少为 0，所以其 Node 被丢弃。来自 leaf.parent 的弱引用计数 1 与 Node 是否被丢弃无关，所以并没有产生任何内存泄漏！</p>
<p>如果在内部作用域结束后尝试访问 leaf 的父节点，会再次得到 None。在程序的结尾，leaf 中 Rc<Node> 的强引用计数为 1，弱引用计数为 0，因为现在 leaf 又是 Rc<Node> 唯一的引用了。</p>
<p>所有这些管理计数和值的逻辑都内建于 Rc<T> 和 Weak<T> 以及它们的 Drop trait 实现中。通过在 Node 定义中指定从子节点到父节点的关系为一个 Weak<T>引用，就能够拥有父节点和子节点之间的双向引用而不会造成引用循环和内存泄漏。</p>
<h1 id="无畏并发"><a href="#无畏并发" class="headerlink" title="无畏并发"></a>无畏并发</h1><ul>
<li><strong>并发编程</strong>（<em>Concurrent programming</em>），代表程序的不同部分相互独立的执行，</li>
<li><strong>并行编程</strong>（<em>parallel programming</em>）代表程序不同部分于同时执行</li>
</ul>
<h2 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h2><p>在大部分现代操作系统中，已执行程序的代码在一个 <strong>进程</strong>（<em>process</em>）中运行，操作系统则负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。运行这些独立部分的功能被称为 <strong>线程</strong>（<em>threads</em>）。</p>
<p>将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p>
<ul>
<li>竞态条件（Race conditions），多个线程以不一致的顺序访问数据或资源</li>
<li>死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li>
<li>只会发生在特定情况且难以稳定重现和修复的 bug</li>
</ul>
<p>编程语言有一些不同的方法来实现线程。</p>
<ul>
<li>很多操作系统提供了创建新线程的 API。这种由编程语言调用操作系统 API 创建线程的模型有时被称为 <em>1:1</em>，一个 OS 线程对应一个语言线程。<strong>Rust 标准库只提供了 1:1 线程实现</strong>；需要较小的运行时</li>
<li>有一些 crate 实现了其他有着不同取舍的线程模型，即语言自己实现的线程（绿色线程）：M:N 模型。需要较大的运行时</li>
</ul>
<h2 id="通过-spawn-创建新线程"><a href="#通过-spawn-创建新线程" class="headerlink" title="通过 spawn 创建新线程"></a>通过 spawn 创建新线程</h2><p>为了创建一个新线程，需要调用 thread::spawn 函数并传递一个闭包，并在其中包含希望在新线程运行的代码</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for i in 1..5 &#123;</span><br><span class="line">        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当主线程结束时，新线程也会结束，而不管其是否执行完毕。</p>
<h2 id="通过-join-Handle-来等待所有线程的完成"><a href="#通过-join-Handle-来等待所有线程的完成" class="headerlink" title="通过 join Handle 来等待所有线程的完成"></a>通过 join Handle 来等待所有线程的完成</h2><ul>
<li>thread::spawn 的返回值类型是 JoinHandle。</li>
<li>JoinHandle 是一个拥有所有权的值</li>
<li>当对其调用 join 方法时，会阻止当前运行线程的执行，直到 handle 所表示的这些线程的终结。</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let handle = thread::spawn(|| &#123;</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for i in 1..5 &#123;</span><br><span class="line">        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束。<strong>阻塞</strong>（<em>Blocking</em>） 线程意味着阻止该线程执行工作或退出。因为我们将 join 调用放在了主线程的 for 循环之后，</p>
<h2 id="使用-move-闭包"><a href="#使用-move-闭包" class="headerlink" title="使用 move 闭包"></a>使用 move 闭包</h2><ul>
<li>move 闭包通常和 thread::spawn 函数一起使用，它允许你使用其他线程的数据</li>
<li>创建线程时，把值得所有权从一个线程转移到另一个线程</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let handle = thread::spawn(|| &#123;</span><br><span class="line">        println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-3: 尝试在另一个线程使用主线程创建的 vector</p>
<p>闭包使用了 v，所以闭包会捕获 v 并使其成为闭包环境的一部分。因为 thread::spawn 在一个新线程中运行这个闭包，所以可以在新线程中访问 v。然而当编译这个例子时，会得到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling threads v0.1.0 (file:///projects/threads)</span><br><span class="line">error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</span><br><span class="line"> --&gt; src/main.rs:6:32</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(|| &#123;</span><br><span class="line">  |                                ^^ may outlive borrowed value `v`</span><br><span class="line">7 |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">  |                                           - `v` is borrowed here</span><br><span class="line">  |</span><br><span class="line">note: function requires argument type to outlive `&#x27;static`</span><br><span class="line"> --&gt; src/main.rs:6:18</span><br><span class="line">  |</span><br><span class="line">6 |       let handle = thread::spawn(|| &#123;</span><br><span class="line">  |  __________________^</span><br><span class="line">7 | |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">8 | |     &#125;);</span><br><span class="line">  | |______^</span><br><span class="line">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(move || &#123;</span><br><span class="line">  |                                ++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0373`.</span><br><span class="line">error: could not compile `threads` due to previous error</span><br></pre></td></tr></table></figure>
<p>Rust 会 <strong>推断</strong> 如何捕获 v，因为 println! 只需要 v 的引用，闭包尝试借用 v。然而这有一个问题：Rust 不知道这个新建线程会执行多久，所以无法知晓 v 的引用是否一直有效。</p>
<p>示例 16-4 展示了一个 v 的引用很有可能不再有效的场景：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let handle = thread::spawn(|| &#123;</span><br><span class="line">        println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    drop(v); // oh no!</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在闭包之前增加 move 关键字，我们强制闭包获取其使用的值的所有权，而不是任由 Rust 推断它应该借用值。示例 16-5 中展示的对示例 16-3 代码的修改，可以按照我们的预期编译并运行：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let handle = thread::spawn(move || &#123;</span><br><span class="line">        println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-5: 使用 move 关键字强制获取它使用的值的所有权</p>
<h2 id="使用消息传递来跨线程传递数据"><a href="#使用消息传递来跨线程传递数据" class="headerlink" title="使用消息传递来跨线程传递数据"></a>使用消息传递来跨线程传递数据</h2><p>一个日益流行的确保安全并发的方式是 <strong>消息传递</strong>（<em>message passing</em>），这里线程或 actor 通过发送包含数据的消息来相互沟通。这个思想来源于 [Go 编程语言文档中]的口号：“不要通过共享内存来通讯；而是通过通讯来共享内存。”（“Do not communicate by sharing memory; instead, share memory by communicating.”）</p>
<ul>
<li>线程（或 Actor）通过彼此发送消息（数据）来进行通信</li>
<li>Rust: Channel(标准库提供)</li>
</ul>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul>
<li>Channel 包含：发送端，接收端</li>
<li>调用发送端的方法，发送数据</li>
<li>接收端会检查和接收到达的数据</li>
<li>如果发送端，接收端中任意一端被丢弃了，那么 Channel 就被“关闭”了</li>
</ul>
<h3 id="创建-Channel"><a href="#创建-Channel" class="headerlink" title="创建 Channel"></a>创建 Channel</h3><ul>
<li>使用<strong>mpsc::channel</strong> 函数来创建 Channel</li>
</ul>
<ol>
<li>mpsc 表示 multiple producer,single consumer(多个生产者，一个消费者)</li>
<li>返回一个 tuple(元组):里面元素分别是发送端，接收端</li>
</ol>
<p>让我们将发送端移动到一个新建线程中并发送一个字符串，这样新建线程就可以和主线程通讯了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let val = String::from(&quot;hi&quot;);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">    let received = rx.recv().unwrap();</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-7: 将 tx 移动到一个新建的线程中并发送 “hi”</p>
<p>这里再次使用 thread::spawn 来创建一个新线程并使用 move 将 tx 移动到闭包中这样新建线程就拥有 tx 了。新建线程需要拥有信道的发送端以便能向信道发送消息。</p>
<p>信道的发送端有一个 send 方法用来获取需要放入信道的值。send 方法返回一个 Result<T, E> 类型，所以<strong>如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误</strong>。在这个例子中，出错的时候调用 unwrap 产生 panic。不过对于一个真实程序，需要合理地处理它</p>
<p><strong>接收端的 recv 方法</strong></p>
<ul>
<li>信道的接收端有两个有用的方法：recv 和 try_recv。</li>
<li>这里，我们使用了 recv，它是 <em>receive</em> 的缩写。这个方法会<strong>阻塞主线程执行直到从信道中接收一个值</strong>。一旦发送了一个值，recv 会在一个 Result<T, E> 中返回它。当信道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了。</li>
<li>try_recv 不会阻塞，相反它立刻返回一个 Result<T, E>：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 try_recv 很有用：可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</li>
</ul>
<h3 id="信道与所有权转移"><a href="#信道与所有权转移" class="headerlink" title="信道与所有权转移"></a>信道与所有权转移</h3><p>现在让我们做一个试验来看看信道与所有权如何一同协作以避免产生问题：我们将尝试在新建线程中的信道中发送完 val 值 <strong>之后</strong> 再使用它。尝试编译示例 16-9 中的代码并看看为何这是不允许的：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let val = String::from(&quot;hi&quot;);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        println!(&quot;val is &#123;&#125;&quot;, val);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let received = rx.recv().unwrap();</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-9: 在我们已经发送到信道中后，尝试使用 val 引用</p>
<p>这里尝试在通过 tx.send 发送 val 到信道中之后将其打印出来。允许这么做是一个坏主意：</p>
<p><strong>一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃。其他线程对值可能的修改会由于不一致或不存在的数据而导致错误或意外的结果</strong>。</p>
<p>然而，尝试编译示例 16-9 的代码时，Rust 会给出一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling message-passing v0.1.0 (file:///projects/message-passing)</span><br><span class="line">error[E0382]: borrow of moved value: `val`</span><br><span class="line">  --&gt; src/main.rs:10:31</span><br><span class="line">   |</span><br><span class="line">8  |         let val = String::from(&quot;hi&quot;);</span><br><span class="line">   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">9  |         tx.send(val).unwrap();</span><br><span class="line">   |                 --- value moved here</span><br><span class="line">10 |         println!(&quot;val is &#123;&#125;&quot;, val);</span><br><span class="line">   |                               ^^^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `message-passing` due to previous error</span><br></pre></td></tr></table></figure>
<p>我们的并发错误会造成一个编译时错误。send 函数获取其参数的所有权并移动这个值归接收者所有。这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则。</p>
<h3 id="发送多个值并观察接收者的等待"><a href="#发送多个值并观察接收者的等待" class="headerlink" title="发送多个值并观察接收者的等待"></a>发送多个值并观察接收者的等待</h3><p>示例 16-8 中的代码可以编译和运行，不过它并没有明确的告诉我们两个独立的线程通过信道相互通讯。</p>
<p>示例 16-10 则有一些改进会证明示例 16-8 中的代码是并发执行的</p>
<p>新建线程现在会发送多个消息并在每个消息之间暂停一秒钟。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for received in rx &#123;</span><br><span class="line">        println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-10: 发送多个消息，并在每次发送后暂停一段时间</p>
<p>这一次，在新建线程中有一个字符串 vector 希望发送到主线程。我们遍历他们，单独的发送每一个字符串并通过一个 Duration 值调用 thread::sleep 函数来暂停一秒。</p>
<p>在主线程中，不再显式调用 recv 函数：而是将 rx 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当信道被关闭时，迭代器也将结束。</p>
<p>当运行示例 16-10 中的代码时，将看到如下输出，每一行都会暂停一秒：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: from</span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br></pre></td></tr></table></figure>
<p>因为主线程中的 for 循环里并没有任何暂停或等待的代码，所以可以说主线程是在等待从新建线程中接收值。</p>
<h3 id="通过克隆发送者来创建多个生产者"><a href="#通过克隆发送者来创建多个生产者" class="headerlink" title="通过克隆发送者来创建多个生产者"></a>通过克隆发送者来创建多个生产者</h3><p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// --snip--</span><br><span class="line"></span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    let tx1 = tx.clone();</span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx1.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;more&quot;),</span><br><span class="line">            String::from(&quot;messages&quot;),</span><br><span class="line">            String::from(&quot;for&quot;),</span><br><span class="line">            String::from(&quot;you&quot;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for received in rx &#123;</span><br><span class="line">        println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // --snip--</span><br></pre></td></tr></table></figure>
<p>示例 16-11: 从多个生产者发送多个消息</p>
<p>这一次，在创建新线程之前，我们对信道的发送端调用了 clone 方法。这会给我们一个<strong>可以传递给第一个新建线程的发送端句柄</strong>。我们会将原始的信道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向信道的接收端发送不同的消息。</p>
<p>如果运行这些代码，你 <strong>可能</strong> 会看到这样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: more</span><br><span class="line">Got: from</span><br><span class="line">Got: messages</span><br><span class="line">Got: for</span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br><span class="line">Got: you</span><br></pre></td></tr></table></figure>
<p>虽然你可能会看到这些值以不同的顺序出现；这依赖于你的系统。这也就是并发既有趣又困难的原因。如果通过 thread::sleep 做实验，在不同的线程中提供不同的值，就会发现他们的运行更加不确定，且每次都会产生不同的输出。</p>
<h2 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h2><ul>
<li>在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。</li>
<li>共享内存类似于多所有权：多个线程可以同时访问相同的内存位置</li>
</ul>
<h3 id="互斥器一次只允许一个线程访问数据"><a href="#互斥器一次只允许一个线程访问数据" class="headerlink" title="互斥器一次只允许一个线程访问数据"></a>互斥器一次只允许一个线程访问数据</h3><p><strong>互斥器</strong>（<em>mutex</em>）是 <em>mutual exclusion</em> 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p>
<p>互斥器以难以使用著称，因为你不得不记住：</p>
<ol>
<li>在使用数据之前尝试获取锁。</li>
<li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li>
</ol>
<p>在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。</p>
<h3 id="Mutex-的-API"><a href="#Mutex-的-API" class="headerlink" title="Mutex 的 API"></a>Mutex 的 API</h3><p>作为展示如何使用互斥器的例子，让我们从在单线程上下文使用互斥器开始，如示例 16-12 所示：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::Mutex;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let m = Mutex::new(5);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let mut num = m.lock().unwrap();</span><br><span class="line">        *num = 6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;m = &#123;:?&#125;&quot;, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-12: 出于简单的考虑，在一个单线程上下文中探索 Mutex<T> 的 API</p>
<p>像很多类型一样，我们使用关联函数 new 来创建一个 Mutex<T>。使用 lock 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。</p>
<p>一旦获取了锁，就可以将返回值（在这里是 num）<strong>视为一个其内部数据的可变引用</strong>了。类型系统确保了我们在使用 m 中的值之前获取锁：Mutex<i32> 并不是一个 i32，所以 <strong>必须</strong> 获取锁才能使用这个 i32 值。我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 i32 值。</p>
<p>Mutex<T> 是一个智能指针。更准确的说，lock 调用 <strong>返回</strong> 一个叫做 MutexGuard 的智能指针。这个智能指针实现了 Deref 来指向其内部数据；其也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁，这正发生于示例 16-12 内部作用域的结尾。为此，我们不会忘记释放锁并阻塞互斥器为其它线程所用的风险，因为<strong>锁的释放是自动发生的</strong>。</p>
<h3 id="在线程间共享-Mutex"><a href="#在线程间共享-Mutex" class="headerlink" title="在线程间共享 Mutex"></a>在线程间共享 Mutex</h3><p>现在让我们尝试使用 Mutex<T> 在多个线程间共享值。我们将启动十个线程，并在各个线程中对同一个计数器值加一，这样计数器将从 0 变为 10。示例 16-13 中的例子会出现编译错误，而我们将通过这些错误来学习如何使用 Mutex<T>，以及 Rust 又是如何帮助我们正确使用的。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::Mutex;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let counter = Mutex::new(0);</span><br><span class="line">    let mut handles = vec![];</span><br><span class="line"></span><br><span class="line">    for _ in 0..10 &#123;</span><br><span class="line">        let handle = thread::spawn(move || &#123;</span><br><span class="line">            let mut num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-13: 程序启动了 10 个线程，每个线程都通过 Mutex<T> 来增加计数器的值</p>
<p>这里创建了一个 counter 变量来存放内含 i32 的 Mutex<T>，类似示例 16-12 那样。接下来遍历 range 创建了 10 个线程。使用了 thread::spawn 并对所有线程使用了相同的闭包：他们每一个都将调用 lock 方法来获取 Mutex<T> 上的锁，接着将互斥器中的值加一。当一个线程结束执行，num 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。</p>
<p>在主线程中，我们像示例 16-2 那样收集了所有的 join 句柄，调用它们的 join 方法来确保所有线程都会结束。这时，主线程会获取锁并打印出程序的结果。</p>
<p>编译失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0382]: use of moved value: `counter`</span><br><span class="line">  --&gt; src/main.rs:9:36</span><br><span class="line">   |</span><br><span class="line">5  |     let counter = Mutex::new(0);</span><br><span class="line">   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait</span><br><span class="line">...</span><br><span class="line">9  |         let handle = thread::spawn(move || &#123;</span><br><span class="line">   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop</span><br><span class="line">10 |             let mut num = counter.lock().unwrap();</span><br><span class="line">   |                           ------- use occurs due to use in closure</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure>
<p>错误信息表明 counter 值在上一次循环中被移动了。所以 Rust 告诉我们<strong>不能将</strong> <strong>counter</strong> <strong>锁的所有权移动到多个线程中</strong>。</p>
<h3 id="多线程和多所有权"><a href="#多线程和多所有权" class="headerlink" title="多线程和多所有权"></a>多线程和多所有权</h3><p>通过使用智能指针 Rc<T> 来创建引用计数的值，可以拥有多所有者。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">use std::rc::Rc;</span><br><span class="line">use std::sync::Mutex;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let counter = Rc::new(Mutex::new(0));</span><br><span class="line">    let mut handles = vec![];</span><br><span class="line"></span><br><span class="line">    for _ in 0..10 &#123;</span><br><span class="line">        let counter = Rc::clone(&amp;counter);</span><br><span class="line">        let handle = thread::spawn(move || &#123;</span><br><span class="line">            let mut num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-14: 尝试使用 Rc<T> 来允许多个线程拥有 Mutex<T></p>
<p>再一次编译并…出现了不同的错误！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">   --&gt; src/main.rs:11:22</span><br><span class="line">    |</span><br><span class="line">11  |           let handle = thread::spawn(move || &#123;</span><br><span class="line">    |  ______________________^^^^^^^^^^^^^_-</span><br><span class="line">    | |                      |</span><br><span class="line">    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">12  | |             let mut num = counter.lock().unwrap();</span><br><span class="line">13  | |</span><br><span class="line">14  | |             *num += 1;</span><br><span class="line">15  | |         &#125;);</span><br><span class="line">    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">    |</span><br><span class="line">    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</span><br><span class="line">    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">note: required by a bound in `spawn`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure>
<p>第一行错误表明 Rc<Mutex<i32>&gt;<code>cannot be sent between threads safely</code>。编译器也告诉了我们原因 <code>the trait</code>Send<code>is not implemented for</code>Rc<Mutex<i32>&gt;。下一部分会讲到 Send：这是确保所使用的类型可以用于并发环境的 trait 之一。</p>
<p>不幸的是，<strong>Rc<T></strong> <strong>并不能安全的在线程间共享</strong>。当 Rc<T> 管理引用计数时，它必须在每一个 clone 调用时增加计数，并在每一个克隆被丢弃时减少计数。<strong>Rc<T></strong> <strong>并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断</strong>。在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个完全类似 Rc<T>，又以一种线程安全的方式改变引用计数的类型。</p>
<h3 id="原子引用计数-Arc"><a href="#原子引用计数-Arc" class="headerlink" title="原子引用计数 Arc"></a>原子引用计数 Arc<T></h3><p>Arc<T><strong>正是</strong> 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。字母 “a” 代表 <strong>原子性</strong>（<em>atomic</em>），所以这是一个 <strong>原子引用计数</strong>（<em>atomically reference counted</em>）类型.</p>
<p>为什么不是所有的原始类型都是原子性的？为什么不是所有标准库中的类型都默认使用 Arc<T> 实现？</p>
<p>原因在于线程安全带有性能惩罚，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let counter = Arc::new(Mutex::new(0));</span><br><span class="line">    let mut handles = vec![];</span><br><span class="line"></span><br><span class="line">    for _ in 0..10 &#123;</span><br><span class="line">        let counter = Arc::clone(&amp;counter);</span><br><span class="line">        let handle = thread::spawn(move || &#123;</span><br><span class="line">            let mut num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 16-15: 使用 Arc<T> 包装一个 Mutex<T> 能够实现在多线程之间共享所有权</p>
<p>这会打印出：</p>
<p>Result: 10</p>
<h3 id="RefCell-Rc-与-Mutex-Arc-的相似性"><a href="#RefCell-Rc-与-Mutex-Arc-的相似性" class="headerlink" title="RefCell/Rc 与 Mutex/Arc 的相似性"></a>RefCell/Rc 与 Mutex/Arc 的相似性</h3><ul>
<li>因为 counter 是不可变的，不过可以获取其内部值的可变引用；这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。正如使用 RefCell<T> 可以改变 Rc<T> 中的内容那样，同样的可以使用 Mutex<T> 来改变 Arc<T> 中的内容。</li>
<li>Rust 不能避免使用 Mutex<T> 的全部逻辑错误。回忆一下使用 Rc<T> 就有造成引用循环的风险，这时两个 Rc<T> 值相互引用，造成内存泄漏。同理，Mutex<T> 也有造成 <strong>死锁</strong>（<em>deadlock</em>） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。</li>
</ul>
<h2 id="使用-Sync-和-Send-trait-的可扩展并发"><a href="#使用-Sync-和-Send-trait-的可扩展并发" class="headerlink" title="使用 Sync 和 Send trait 的可扩展并发"></a>使用 Sync 和 Send trait 的可扩展并发</h2><p>Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 <strong>甚少</strong>。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。</p>
<p>然而有两个并发概念是<strong>内嵌于语言中</strong>的：std::marker 中的 Sync 和 Send trait。</p>
<h3 id="通过-Send-允许在线程间转移所有权"><a href="#通过-Send-允许在线程间转移所有权" class="headerlink" title="通过 Send 允许在线程间转移所有权"></a>通过 Send 允许在线程间转移所有权</h3><ul>
<li>Send 标记 trait 表明实现了 Send 的类型值的所有权可以在线程间传送。</li>
<li>几乎所有的 Rust 类型都是 Send 的，</li>
<li>不过有一些例外，包括 Rc<T>：这是不能 Send 的，</li>
</ul>
<p>因为如果克隆了 Rc<T> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，Rc<T> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。</p>
<ul>
<li>Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 Rc<T> 在线程间发送。当尝试在示例 16-14 中这么做的时候，会得到错误 the trait Send is not implemented for Rc<Mutex<i32>&gt;。而使用标记为 Send 的 Arc<T> 时，就没有问题了。</li>
<li>任何完全由 Send 的类型组成的类型也会自动被标记为 Send。几乎所有基本类型都是 Send 的，除了裸指针（raw pointer）。</li>
</ul>
<h3 id="Sync-允许多线程访问"><a href="#Sync-允许多线程访问" class="headerlink" title="Sync 允许多线程访问"></a>Sync 允许多线程访问</h3><ul>
<li>Sync 标记 trait 表明一个实现了 Sync 的类型可以<strong>安全的在多个线程中拥有其值的引用</strong>。</li>
<li>换一种方式来说，对于任意类型 T，如果 &amp;T（T 的不可变引用）是 Send 的话 T 就是 Sync 的，这意味着其引用就可以安全的发送到另一个线程。</li>
<li>类似于 Send 的情况，基本类型是 Sync 的，完全由 Sync 的类型组成的类型也是 Sync 的。</li>
<li>智能指针 Rc<T> 也不是 Sync 的，出于其不是 Send 相同的原因。RefCell<T>和 Cell<T> 系列类型不是 Sync 的。RefCell<T> 在运行时所进行的借用检查也不是线程安全的。</li>
<li>Mutex<T> 是 Sync 的，正如 “在线程间共享 Mutex”部分所讲的它可以被用来在多线程中共享访问。</li>
</ul>
<h3 id="手动实现-Send-和-Sync-是不安全的"><a href="#手动实现-Send-和-Sync-是不安全的" class="headerlink" title="手动实现 Send 和 Sync 是不安全的"></a>手动实现 Send 和 Sync 是不安全的</h3><ul>
<li>通常并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。</li>
<li>因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。</li>
<li>手动实现这些标记 trait 涉及到编写不安全的 Rust 代码，</li>
</ul>
<p>当前重要的是，在创建新的由不是 Send 和 Sync 的部分构成的并发类型时需要多加小心，以确保维持其安全保证。<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a> 中有更多关于这些保证以及如何维持他们的信息。</p>
<h1 id="Rust-的面向对象特性"><a href="#Rust-的面向对象特性" class="headerlink" title="Rust 的面向对象特性"></a>Rust 的面向对象特性</h1><h2 id="面向对象语言的特点"><a href="#面向对象语言的特点" class="headerlink" title="面向对象语言的特点"></a>面向对象语言的特点</h2><ul>
<li><strong>对象包含数据和行为</strong></li>
</ul>
<p>在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 <strong>称为</strong> 对象，但是他们提供了与对象相同的功能，</p>
<ul>
<li><strong>封装隐藏了实现细节</strong></li>
</ul>
<p><strong>封装</strong>（<em>encapsulation</em>）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。</p>
<p>Rust 中可以使用 pub 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的。</p>
<p>举例：</p>
<p>比如，我们可以定义一个包含一个 i32 类型 vector 的结构体 AveragedCollection。结构体也可以有一个字段，该字段保存了 vector 中所有值的平均值。这样，希望知道结构体中的 vector 的平均值的人可以随时获取它，而无需自己计算。换句话说，AveragedCollection 会为我们缓存平均值结果。示例 17-1 有 AveragedCollection 结构体的定义：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub struct AveragedCollection &#123;</span><br><span class="line">    list: Vec&lt;i32&gt;,</span><br><span class="line">    average: f64,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-1: AveragedCollection 结构体维护了一个整型列表和集合中所有元素的平均值。</p>
<p>注意，结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 add、remove 和 average 方法来做到这一点，如示例 17-2 所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">impl AveragedCollection &#123;</span><br><span class="line">    pub fn add(&amp;mut self, value: i32) &#123;</span><br><span class="line">        self.list.push(value);</span><br><span class="line">        self.update_average();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">        let result = self.list.pop();</span><br><span class="line">        match result &#123;</span><br><span class="line">            Some(value) =&gt; &#123;</span><br><span class="line">                self.update_average();</span><br><span class="line">                Some(value)</span><br><span class="line">            &#125;</span><br><span class="line">            None =&gt; None,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn average(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        self.average</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn update_average(&amp;mut self) &#123;</span><br><span class="line">        let total: i32 = self.list.iter().sum();</span><br><span class="line">        self.average = total as f64 / self.list.len() as f64;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-2: 在 AveragedCollection 结构体上实现了 add、remove 和 average 公有方法</p>
<p>公有方法 add、remove 和 average 是修改 AveragedCollection 实例的唯一方式。当使用 add 方法把一个元素加入到 list 或者使用 remove 方法来删除时，这些方法的实现同时会调用私有的 update_average 方法来更新 average 字段。</p>
<p>list 和 average 是私有的，所以没有其他方式来使得外部的代码直接向 list 增加或者删除元素，否则 list 改变时可能会导致 average 字段不同步。average 方法返回 average 字段的值，这使得外部的代码只能读取 average 而不能修改它。</p>
<p>因为我们已经封装好了 AveragedCollection 的实现细节，将来可以轻松改变类似数据结构这些方面的内容。例如，可以使用 HashSet<i32> 代替 Vec<i32> 作为 list 字段的类型。只要 add、remove 和 average 公有函数的签名保持不变，使用 AveragedCollection 的代码就无需改变。相反如果使得 list 为公有，就未必都会如此了： HashSet<i32> 和 Vec<i32> 使用不同的方法增加或移除项，所以如果要想直接修改 list 的话，外部的代码可能不得不做出修改。</p>
<p>如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。在代码中不同的部分使用 pub 与否可以封装其实现细节。</p>
<ul>
<li><strong>继承，作为类型系统与代码共享</strong></li>
</ul>
<p><strong>继承</strong>（<em>Inheritance</em>）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。</p>
<p><strong>如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的。**</strong>无法定义一个结构体继承父结构体的成员和方法**。然而，如果你过去常常在你的编程工具箱使用继承，根据你最初考虑继承的原因，Rust 也提供了其他的解决方案。</p>
<p>选择继承有两个主要的原因。</p>
<ol>
<li>第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。相反 Rust 代码可以使用默认 trait 方法实现来进行共享，</li>
<li>第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 <strong>多态</strong>（<em>polymorphism</em>），这意味着如果多种对象共享特定的属性，则可以相互替代使用。</li>
</ol>
<p>近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。</p>
<h2 id="顾及不同类型值得-trait-对象"><a href="#顾及不同类型值得-trait-对象" class="headerlink" title="顾及不同类型值得 trait 对象"></a>顾及不同类型值得 trait 对象</h2><p>vector 只能存储同种类型元素的局限。示例 8-10 中提供了一个定义 SpreadsheetCell 枚举来储存整型，浮点型和文本成员的替代方案。这意味着可以在每个单元中储存不同类型的数据，并仍能拥有一个代表一排单元的 vector。这在当编译代码时就知道希望可以交替使用的类型为固定集合的情况下是完全可行的。</p>
<p><strong>然而有时我们希望库用户在特定情况下能够扩展有效的类型集合。</strong></p>
<p>为了展示如何实现这一点，这里将创建一个图形用户接口（Graphical User Interface， GUI）工具的例子，它通过遍历列表并调用每一个项目的 draw 方法来将其绘制到屏幕上 —— 此乃一个 GUI 工具的常见技术。我们将要创建一个叫做 gui 的库 crate，它含一个 GUI 库的结构。这个 GUI 库包含一些可供开发者使用的类型，比如 Button 或 TextField。在此之上，gui 的用户希望创建自定义的可以绘制于屏幕上的类型：比如，一个程序员可能会增加 Image，另一个可能会增加 SelectBox。</p>
<p>这个例子中并不会实现一个功能完善的 GUI 库，不过会展示其中各个部分是如何结合在一起的。编写库的时候，我们不可能知晓并定义所有其他程序员希望创建的类型。我们所知晓的是 gui 需要记录一系列不同类型的值，并需要能够对其中每一个值调用 draw 方法。这里无需知道调用 draw 方法时具体会发生什么，只要该值会有那个方法可供我们调用。</p>
<p>在拥有继承的语言中，可以定义一个名为 Component 的类，该类上有一个 draw 方法。其他的类比如 Button、Image 和 SelectBox 会从 Component 派生并因此继承 draw 方法。它们各自都可以覆盖 draw 方法来定义自己的行为，但是框架会把所有这些类型当作是 Component 的实例，并在其上调用 draw。</p>
<p>不过 Rust 并没有继承，我们得另寻出路。</p>
<h2 id="定义通用行为的-trait"><a href="#定义通用行为的-trait" class="headerlink" title="定义通用行为的 trait"></a>定义通用行为的 trait</h2><p>为了实现 gui 所期望的行为，让我们定义一个 Draw trait，其中包含名为 draw 的方法。接着可以定义一个存放 <strong>trait 对象</strong>（<strong>*trait object*</strong>） 的 vector。trait 对象指向一个实现了我们指定 trait 的类型的实例，以及一个用于在运行时查找该类型的 trait 方法的表。我们通过指定某种指针来创建 trait 对象，例如 &amp; 引用或 Box<T> 智能指针，还有 dyn keyword， 以及指定相关的 trait（ [“动态大小类型和 Sized trait”] 部分会介绍 trait 对象必须使用指针的原因）。我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。如此便无需在编译时就知晓所有可能的类型。</p>
<p>Rust 刻意不将结构体与枚举称为 “对象”，以便与其他语言中的对象相区别。在结构体或枚举中，结构体字段中的数据和 impl 块中的行为是分开的，不同于其他语言中将数据和行为组合进一个称为对象的概念中。</p>
<p>trait 对象将数据和行为两者相结合，从这种意义上说 <strong>则</strong> 其更类似其他语言中的对象。不过 trait 对象不同于传统的对象，因为不能向 trait 对象增加数据。trait 对象并不像其他语言中的对象那么通用：其（trait 对象）具体的作用是允许对通用行为进行抽象。</p>
<p>示例 17-3 展示了如何定义一个带有 draw 方法的 trait Draw：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub trait Draw &#123;</span><br><span class="line">    fn draw(&amp;self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-3：Draw trait 的定义</p>
<p>示例 17-4 定义了一个存放了名叫 components 的 vector 的结构体 Screen。这个 vector 的类型是 Box<dyn Draw>，此为一个 trait 对象：它是 Box 中任何实现了 Draw trait 的类型的替身。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub struct Screen &#123;</span><br><span class="line">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-4: 一个 Screen 结构体的定义，它带有一个字段 components，其包含实现了 Draw trait 的 trait 对象的 vector</p>
<p>在 Screen 结构体上，我们将定义一个 run 方法，该方法会对其 components 上的每一个组件调用 draw 方法，如示例 17-5 所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl Screen &#123;</span><br><span class="line">    pub fn run(&amp;self) &#123;</span><br><span class="line">        for component in self.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-5：在 Screen 上实现一个 run 方法，该方法在每个 component 上调用 draw 方法</p>
<p>这与定义使用了带有 trait bound 的泛型类型参数的结构体不同。<strong>泛型类型参数一次只能替代一个具体类型</strong>，而 <strong>trait 对象则允许在运行时替代多种具体类型</strong>。例如，可以定义 Screen 结构体来使用泛型和 trait bound，如示例 17-6 所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pub trait Draw &#123;</span><br><span class="line">    fn draw(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">pub struct Screen&lt;T: Draw&gt; &#123;</span><br><span class="line">    pub components: Vec&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Draw,</span><br><span class="line">&#123;</span><br><span class="line">    pub fn run(&amp;self) &#123;</span><br><span class="line">        for component in self.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-6: 一种 Screen 结构体的替代实现，其 run 方法使用泛型和 trait bound</p>
<p>这<strong>限制了</strong>Screen 实例必须拥有一个全是 Button 类型或者全是 TextField 类型的组件列表。如果只需要<strong>同质（相同类型）集合</strong>，则倾向于使用泛型和 trait bound，因为其定义会在编译时采用具体类型进行单态化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pub trait Draw &#123;</span><br><span class="line">    fn draw(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">pub struct Screen &#123;</span><br><span class="line">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">impl Screen &#123;</span><br><span class="line">    pub fn run(&amp;self) &#123;</span><br><span class="line">        for component in self.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，通过使用 trait 对象的方法，一个 Screen 实例可以存放一个既能包含 Box<Button>，也能包含 Box<TextField> 的 Vec<T>。</p>
<p><strong>实现 trait</strong></p>
<p>现在来增加一些实现了 Draw trait 的类型。我们将提供 Button 类型。再一次重申，真正实现 GUI 库超出了范畴，所以 draw 方法体中不会有任何有意义的实现。为了想象一下这个实现看起来像什么，一个 Button 结构体可能会拥有 width、height 和 label 字段，如示例 17-7 所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub struct Button &#123;</span><br><span class="line">    pub width: u32,</span><br><span class="line">    pub height: u32,</span><br><span class="line">    pub label: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Draw for Button &#123;</span><br><span class="line">    fn draw(&amp;self) &#123;</span><br><span class="line">        // code to actually draw a button</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-7: 一个实现了 Draw trait 的 Button 结构体</p>
<p>在 Button 上的 width、height 和 label 字段会和其他组件不同，比如 TextField 可能有 width、height、label 以及 placeholder 字段。每一个我们希望能在屏幕上绘制的类型都会使用不同的代码来实现 Draw trait 的 draw 方法来定义如何绘制特定的类型，像这里的 Button 类型（并不包含任何实际的 GUI 代码，这超出了本章的范畴）。除了实现 Draw trait 之外，比如 Button 还可能有另一个包含按钮点击如何响应的方法的 impl 块。这类方法并不适用于像 TextField 这样的类型。</p>
<p>如果一些库的使用者决定实现一个包含 width、height 和 options 字段的结构体 SelectBox，并且也为其实现了 Draw trait，如示例 17-8 所示：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use gui::Draw;</span><br><span class="line"></span><br><span class="line">struct SelectBox &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">    options: Vec&lt;String&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Draw for SelectBox &#123;</span><br><span class="line">    fn draw(&amp;self) &#123;</span><br><span class="line">        // code to actually draw a select box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-8: 另一个使用 gui 的 crate 中，在 SelectBox 结构体上实现 Draw trait</p>
<p>库使用者现在可以在他们的 main 函数中创建一个 Screen 实例。至此可以通过将 SelectBox 和 Button 放入 Box<T> 转变为 trait 对象来增加组件。接着可以调用 Screen 的 run 方法，它会调用每个组件的 draw 方法。示例 17-9 展示了这个实现：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">use gui::&#123;Button, Screen&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let screen = Screen &#123;</span><br><span class="line">        components: vec![</span><br><span class="line">            Box::new(SelectBox &#123;</span><br><span class="line">                width: 75,</span><br><span class="line">                height: 10,</span><br><span class="line">                options: vec![</span><br><span class="line">                    String::from(&quot;Yes&quot;),</span><br><span class="line">                    String::from(&quot;Maybe&quot;),</span><br><span class="line">                    String::from(&quot;No&quot;),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            Box::new(Button &#123;</span><br><span class="line">                width: 50,</span><br><span class="line">                height: 10,</span><br><span class="line">                label: String::from(&quot;OK&quot;),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-9: 使用 trait 对象来存储实现了相同 trait 的不同类型的值</p>
<p>当编写库的时候，我们不知道何人会在何时增加 SelectBox 类型，不过 Screen 的实现能够操作并绘制这个新类型，因为 SelectBox 实现了 Draw trait，这意味着它实现了 draw 方法。</p>
<p>这个概念 —— 只关心值所反映的信息而不是其具体类型 —— 类似于动态类型语言中称为 <strong>鸭子类型</strong>（<em>duck typing</em>）的概念：如果它走起来像一只鸭子，叫起来像一只鸭子，那么它就是一只鸭子！在示例 17-5 中 Screen 上的 run 实现中，run 并不需要知道各个组件的具体类型是什么。<strong>它并不检查组件是</strong> <strong>Button</strong> <strong>或者</strong> <strong>SelectBox</strong> <strong>的实例</strong>。<strong>通过指定</strong> <strong>Box<dyn Draw></strong> <strong>作为</strong> <strong>components</strong> <strong>vector 中值的类型</strong>，我们就定义了 Screen 为需要可以在其上调用 draw 方法的值。</p>
<p>使用 trait 对象和 Rust 类型系统来进行类似鸭子类型操作的优势是无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现 trait 对象所需的 trait 则 Rust 不会编译这些代码。</p>
<p>例如，示例 17-10 展示了当创建一个使用 String 做为其组件的 Screen 时发生的情况：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use gui::Screen;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let screen = Screen &#123;</span><br><span class="line">        components: vec![Box::new(String::from(&quot;Hi&quot;))],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 17-10: 尝试使用一种没有实现 trait 对象的 trait 的类型</p>
<p>我们会遇到这个错误，因为 String 没有实现 rust_gui::Draw trait：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling gui v0.1.0 (file:///projects/gui)</span><br><span class="line">error[E0277]: the trait bound `String: Draw` is not satisfied</span><br><span class="line"> --&gt; src/main.rs:5:26</span><br><span class="line">  |</span><br><span class="line">5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],</span><br><span class="line">  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`</span><br><span class="line">  |</span><br><span class="line">  = note: required for the cast to the object type `dyn Draw`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure>
<p>这告诉了我们，要么是我们传递了并不希望传递给 Screen 的类型并应该提供其他类型，要么应该在 String 上实现 Draw 以便 Screen 可以调用其上的 draw。</p>
<h2 id="trait-对象执行动态分发"><a href="#trait-对象执行动态分发" class="headerlink" title="trait 对象执行动态分发"></a>trait 对象执行动态分发</h2><ul>
<li>对泛型使用 trait bound 时编译器所执行的单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了函数和方法的非泛型实现。单态化产生的代码在执行 <strong>静态分发</strong>（<em>static dispatch</em>）。</li>
<li>静态分发发生于编译器在编译时就知晓调用了什么方法的时候。</li>
<li><strong>动态分发</strong> （<em>dynamic dispatch</em> 编译器在编译时无法知晓调用了什么方法。</li>
<li>在动态分发的场景下，编译器生成的代码到运行时才能确定调用了什么方法。</li>
</ul>
<p><strong>当使用 trait 对象时，Rust 必须使用动态分发</strong>。编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。<strong>动态分发也阻止编译器有选择的内联方法代码</strong>，这会相应的<strong>禁用一些优化</strong>。尽管在编写示例 17-5 和可以支持示例 17-9 中的代码的过程中确实获得了额外的灵活性，但仍然需要权衡取舍。</p>
<h2 id="trait-对象需要类型安全"><a href="#trait-对象需要类型安全" class="headerlink" title="trait 对象需要类型安全"></a>trait 对象需要类型安全</h2><p><strong>只有对象安全（object-safe）的 trait 可以实现为 特征(dyn)对象</strong> 。</p>
<p>这里有一些复杂的规则来实现 trait 的对象安全，但在实践中，只有两个相关的规则。</p>
<p><strong>如果一个 trait 中定义的所有方法都符合以下规则，则该 trait 是对象安全的：</strong></p>
<ul>
<li>返回值不是 Self</li>
<li>没有泛型类型的参数</li>
</ul>
<p>Self 关键字是我们在 trait 与方法上的实现的别称，trait 对象必须是对象安全的，因为一旦使用 trait 对象，Rust 将不再知晓该实现的返回类型。如果一个 trait 的方法返回了一个 Self 类型，但是该 trait 对象忘记了 Self 的确切类型，那么该方法将不能使用原本的类型。当 trait 使用具体类型填充的泛型类型时也一样：具体类型成为实现 trait 的对象的一部分，当使用 trait 对象却忘了类型是什么时，无法知道应该用什么类型来填充泛型类型。</p>
<p><strong>一个非对象安全的 trait 例子是标准库中的</strong> <strong>Clone</strong> <strong>trait</strong>。Clone trait 中的 clone 方法的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub trait Clone &#123;</span><br><span class="line">    fn clone(&amp;self) -&gt; Self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String 类型实现了 Clone trait，当我们在 String 的实例对象上调用 clone 方法时，我们会得到一个 String 类型实例对象。相似地，如果我们调用 Vec<T> 实例对象上的 clone 方法，我们会得到一个 Vec<T> 类型的实例对象。clone 方法的标签需要知道哪个类型是 Self 类型，因为 Self 是它的返回类型。</p>
<p>当我们尝试编译一些违反 trait 对象的对象安全规则的代码时，我们会收到编译器的提示。例如，我们想实现 17-4 的 Screen 结构体来保存一个实现了 Clone trait 而不是 Draw trait 的类型，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub struct Screen &#123;</span><br><span class="line">    pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将会收到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling gui v0.1.0 (file:///projects/gui)</span><br><span class="line">error[E0038]: the trait `Clone` cannot be made into an object</span><br><span class="line"> --&gt; src/lib.rs:2:29</span><br><span class="line">  |</span><br><span class="line">2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,</span><br><span class="line">  |                             ^^^^^^^^^ `Clone` cannot be made into an object</span><br><span class="line">  |</span><br><span class="line">  = note: the trait cannot be made into an object because it requires `Self: Sized`</span><br><span class="line">  = note: for a trait to be &quot;object safe&quot; it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0038`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure>
<p>这个错误意味着我们不能将此 trait 用于 trait 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 使用至少两种方法让代码工作</span><br><span class="line">// 不要添加/删除任何代码行</span><br><span class="line">trait MyTrait &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for u32 &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self &#123; 42 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for String &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self &#123; self.clone() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn my_function(x: Box&lt;dyn MyTrait&gt;)  &#123;</span><br><span class="line">    x.f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    my_function(Box::new(13_u32));</span><br><span class="line">    my_function(Box::new(String::from(&quot;abc&quot;)));</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种方式修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait MyTrait &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for u32 &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; u32 &#123; 42 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for String &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; String &#123; self.clone() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn my_function(x: impl MyTrait) -&gt; impl MyTrait  &#123;</span><br><span class="line">    x.f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    my_function(13_u32);</span><br><span class="line">    my_function(String::from(&quot;abc&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait MyTrait &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for u32 &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(42) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for String &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(self.clone()) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn my_function(x: Box&lt;dyn MyTrait&gt;) -&gt; Box&lt;dyn MyTrait&gt; &#123;</span><br><span class="line">    x.f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    my_function(Box::new(13_u32));</span><br><span class="line">    my_function(Box::new(String::from(&quot;abc&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象设计模式的实现"><a href="#面向对象设计模式的实现" class="headerlink" title="面向对象设计模式的实现"></a>面向对象设计模式的实现</h2><ul>
<li><strong>状态模式</strong>（<em>state pattern</em>）是一个面向对象设计模式。该模式的关键在于一个值有某些内部状态，体现为一系列的 <strong>状态对象</strong>，同时值的行为随着其内部状态而改变</li>
<li>状态对象共享功能：在 Rust 中使用结构体和 trait 而不是对象和继承。每一个状态对象负责其自身的行为，以及该状态何时应当转移至另一个状态。持有一个状态对象的值对于不同状态的行为以及何时状态转移毫不知情。</li>
<li>使用状态模式意味着当程序的业务需求改变时，无需改变值持有状态或者使用值的代码。我们只需更新某个状态对象中的代码来改变其规则，或者是增加更多的状态对象。</li>
</ul>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://kaisery.github.io/trpl-zh-cn/ch17-03-oo-design-patterns.html#面向对象设计模式的实现">https://kaisery.github.io/trpl-zh-cn/ch17-03-oo-design-patterns.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0</a></p>
<h1 id="模式与模式匹配"><a href="#模式与模式匹配" class="headerlink" title="模式与模式匹配"></a>模式与模式匹配</h1><p><strong>模式：</strong></p>
<ul>
<li>模式是 Rust 中的一种特殊语法，用于匹配复杂和简单类型的结构</li>
<li>将模式与匹配表达式和其它构造结合使用，可以更好地控制程序的控制流</li>
<li>模式由以下元素(的一些组合)组成：</li>
</ul>
<p>—— 字面值</p>
<p>—— 解构的数组，enum,struct 和 tuple</p>
<p>—— 变量</p>
<p>—— 通配符</p>
<p>—— 占位符</p>
<h2 id="match-的-Arm"><a href="#match-的-Arm" class="headerlink" title="match 的 Arm"></a>match 的 Arm</h2><ul>
<li>match VALUE{PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,}</li>
<li>表达式的要求：</li>
</ul>
<p>—— 详尽（包含所有的可能性）</p>
<ul>
<li>一个特殊的模式：_ (下划线)—— 它不会匹配任何东西—— 不会绑定到变量—— 通常用于 match 的最后一个 arm，或用于忽略某些值</li>
</ul>
<h2 id="条件-if-let-表达式"><a href="#条件-if-let-表达式" class="headerlink" title="条件 if let 表达式"></a>条件 if let 表达式</h2><ul>
<li>if let 表达式主要是作为一种简短的方式来等价的替代只有一个匹配项的 match</li>
<li>if let 可选的可以拥有 else，包括：</li>
</ul>
<p>—— else if</p>
<p>—— else if let</p>
<ul>
<li>但，if let 不会检查穷举性例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let favorite_color: Option&lt;&amp;str&gt; = None;</span><br><span class="line">    let is_tuesday = false;</span><br><span class="line">    let age: Result&lt;u8,_&gt; = &quot;34&quot;.parse();</span><br><span class="line"></span><br><span class="line">    if let Some(color) = favorite_color&#123;</span><br><span class="line">        print!(&quot;Using your favorite color,&#123;&#125;,as the background&quot;,color);</span><br><span class="line">    &#125; else if is_tuesday&#123;</span><br><span class="line">        println!(&quot;Tuesday is green day!&quot;);</span><br><span class="line">    &#125; else if let Ok(age) = age &#123;</span><br><span class="line">        if age &gt; 30 &#123;</span><br><span class="line">            println!(&quot;Using purple as the background color&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;Using orange as the background color&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;Using blue as the background color&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a>while let 条件循环</h2><ul>
<li>只要模式继续满足匹配的条件，那它允许 while 循环一直运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut stack = Vec::new();</span><br><span class="line">    stack.push(1);</span><br><span class="line">    stack.push(2);</span><br><span class="line">    stack.push(3);</span><br><span class="line"></span><br><span class="line">    while let Some(top) = stack.pop() &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><ul>
<li>for 循环是 Rust 中最常见的循环</li>
<li>for 循环中，模式就是紧随 for 关键字后的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let v = vec![&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];</span><br><span class="line">   for (index,value) in v.iter().enumerate()&#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is at index &#123;&#125;&quot;,value,index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iter().enumerate()返回的是一个元组</p>
<h2 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a>let 语句</h2><ul>
<li>let 语句也是模式</li>
<li>let PARTTERN = EXPRESSION</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 5;</span><br><span class="line">let (x,y,z) = (1,2,3);</span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul>
<li>函数的参数也可以是模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn foo(x: i32)&#123;</span><br><span class="line">    println!(&quot;function foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fn print_coordinates(&amp;(x,y): &amp;(i32,i32)) &#123;</span><br><span class="line">    println!(&quot;Current location: (&#123;&#125;,&#123;&#125;)&quot;,x,y);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let point = (3,5);</span><br><span class="line">    print_coordinates(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可辨驳性：模式是否会无法匹配"><a href="#可辨驳性：模式是否会无法匹配" class="headerlink" title="可辨驳性：模式是否会无法匹配"></a>可辨驳性：模式是否会无法匹配</h2><ul>
<li>模式的两种形式：可辨驳的，无可辩驳的</li>
<li>能匹配任何可能传值的模式：无可辩驳的 入 let x= 4;</li>
<li>对某些可能的值，无法进行匹配的模式:可辨驳的 例如：if let Some(x) = a_value</li>
<li><strong>函数参数，let 语句，for 循环只接受无可辩驳的模式</strong></li>
<li><strong>if let 和 while let 接受可辨驳和无可辩驳的模式</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a: Option&lt;i32&gt; = Some(5);</span><br><span class="line">    let Some(x) = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0005]: refutable pattern in local binding: `None` not covered</span><br><span class="line">   --&gt; src\main.rs:3:9</span><br><span class="line">    |</span><br><span class="line">3   |     let Some(x) = a;</span><br><span class="line">    |         ^^^^^^^ pattern `None` not covered</span><br><span class="line">    |</span><br><span class="line">    = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant</span><br><span class="line">    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html</span><br></pre></td></tr></table></figure>
<p>无法匹配，因为模式没有覆盖 None 这种情况</p>
<p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a: Option&lt;i32&gt; = Some(5);</span><br><span class="line">    if let Some(x) = a&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match 除了最后一个分支，其它的分支都是可辨驳的，最后一个分支是不可辩驳的，因为它需要匹配所有剩余的情况</p>
<h2 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x = 1;</span><br><span class="line">    match x &#123;</span><br><span class="line">        1 =&gt; println!(&quot;one&quot;),</span><br><span class="line">        2 =&gt; println!(&quot;two&quot;),</span><br><span class="line">        3 =&gt; println!(&quot;three&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;anything&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h2><ul>
<li>命名的变量是可匹配任何值的无可辩驳模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x = Some(5);</span><br><span class="line">    let y = 10;</span><br><span class="line">    match x &#123;</span><br><span class="line">        Some(50) =&gt; println!(&quot;Got 50&quot;),</span><br><span class="line">        Some(y) =&gt; println!(&quot;Matched,y=&#123;:?&#125;&quot;,y),</span><br><span class="line">        _ =&gt; println!(&quot;Default Case,x=&#123;:?&#125;&quot;,x),</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;at the end: x=&#123;:?&#125;,y=&#123;:?&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 match 的第二个 arm 中<strong>y 是一个新的变量</strong>，存在于该 arm 的作用域</p>
<h2 id="匹配一个可变引用"><a href="#匹配一个可变引用" class="headerlink" title="匹配一个可变引用"></a>匹配一个可变引用</h2><p>使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V<strong>是一个值</strong>，而<strong>不是可变引用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = String::from(&quot;hello,&quot;);</span><br><span class="line">    let r = &amp;mut v;</span><br><span class="line"></span><br><span class="line">    match r &#123;</span><br><span class="line">        // The type of value is &amp;mut String</span><br><span class="line">       value =&gt; value.push_str(&quot; world!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重模式"><a href="#多重模式" class="headerlink" title="多重模式"></a>多重模式</h2><ul>
<li>在 match 表达式中，使用 | 语法（就是或的意思）可以匹配多种模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x= 1;</span><br><span class="line">    match x &#123;</span><br><span class="line">        1 | 2 =&gt; println!(&quot;one or two&quot;),</span><br><span class="line">        3 =&gt; println!(&quot;three&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;anything&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-来匹配某个范围的值"><a href="#使用-来匹配某个范围的值" class="headerlink" title="使用..=来匹配某个范围的值"></a>使用..=来匹配某个范围的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x= 5;</span><br><span class="line">    match x&#123;</span><br><span class="line">        1..=5 =&gt; println!(&quot;one through five&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;something else&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">    let x = &#x27;c&#x27;;</span><br><span class="line">    match x &#123;</span><br><span class="line">        &#x27;a&#x27;..=&#x27;j&#x27; =&gt; println!(&quot;early ASCII letter&quot;),</span><br><span class="line">        &#x27;k&#x27;..=&#x27;z&#x27; =&gt; println!(&quot;late ASCII letter&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;something else&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数字或字符都可以</p>
<h2 id="解构以分解值"><a href="#解构以分解值" class="headerlink" title="解构以分解值"></a>解构以分解值</h2><ul>
<li>可以使用模式来结构 struct,enum,tuple，从而引用这些类型值的不同部分</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let (x, y);</span><br><span class="line">    (x,..) = (3, 4);</span><br><span class="line">    [.., y] = [1, 2];</span><br><span class="line">    assert_eq!([x,y],[3,2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构元组"><a href="#解构元组" class="headerlink" title="解构元组"></a>解构元组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let (mut x, y) = (1, 2);</span><br><span class="line">    x += 2;</span><br><span class="line"></span><br><span class="line">    assert_eq!(x, 3);</span><br><span class="line">    assert_eq!(y, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Point&#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let p = Point&#123;x:0,y:7&#125;;</span><br><span class="line">    let Point &#123;x:a,y:b&#125;=p;</span><br><span class="line">    assert_eq!(0,a);</span><br><span class="line">    assert_eq!(7,b);</span><br><span class="line"></span><br><span class="line">    //简写形式</span><br><span class="line">    let Point&#123;x,y&#125; = p;</span><br><span class="line">    assert_eq!(0,x);</span><br><span class="line">    assert_eq!(7,y);</span><br><span class="line"></span><br><span class="line">    match p &#123;</span><br><span class="line">        Point &#123;x,y:0&#125;=&gt; println!(&quot;On the x axis at &#123;&#125;&quot;,x),//要求y必须为0</span><br><span class="line">        Point &#123;x:0,y&#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;,y),//要求x必须为0</span><br><span class="line">        Point &#123;x,y&#125; =&gt; println!(&quot;On neither axis:(&#123;&#125;,&#123;&#125;)&quot;,x,y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum Message&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:i32,y:i32&#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32,i32,i32),</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let msg = Message::ChangeColor(0, 160, 255);</span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            println!(&quot;The Quit variant has no data to destructure&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Write(text)=&gt;&#123;</span><br><span class="line">            println!(&quot;Text message:&#123;&#125;&quot;,text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::ChangeColor(r, g, b)=&gt;&#123;</span><br><span class="line">            println!(&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">    Rgb(i32,i32,i32),</span><br><span class="line">    Hsv(i32,i32,i32),</span><br><span class="line">&#125;</span><br><span class="line">enum Message&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:i32,y:i32&#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(Color),</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));</span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::ChangeColor(Color::Rgb(r, g, b))=&gt;&#123;</span><br><span class="line">            println!(&quot;Change the color to red &#123;&#125;,green &#123;&#125;,and blue &#123;&#125;&quot;,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::ChangeColor(Color::Hsv(h, s, v))=&gt;&#123;</span><br><span class="line">            println!(&quot;Change the color to hue &#123;&#125;,saturation &#123;&#125;,and value &#123;&#125;&quot;,h,s,v);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let ((feet,inches),Point&#123;x,y&#125;) = ((3,10),Point&#123;x:3,y:-10&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在模式中忽略值"><a href="#在模式中忽略值" class="headerlink" title="在模式中忽略值"></a>在模式中忽略值</h2><ul>
<li>有几种方式可以在模式中忽略整个值或部分值:</li>
</ul>
<h3 id="忽略整个值"><a href="#忽略整个值" class="headerlink" title="_ 忽略整个值"></a><strong>_ 忽略整个值</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn foo(_:i32,y:i32)&#123;</span><br><span class="line">    println!(&quot;y is &#123;&#125;&quot;,y);</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    foo(3, 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用嵌套-忽略值的一部分"><a href="#使用嵌套-忽略值的一部分" class="headerlink" title="使用嵌套_忽略值的一部分"></a><strong>使用嵌套_忽略值的一部分</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let mut setting_value = Some(5);</span><br><span class="line">    let new_setting_value = Some(10);</span><br><span class="line">    match (setting_value,new_setting_value) &#123;</span><br><span class="line">        (Some(_),Some(_))=&gt;&#123;</span><br><span class="line">            println!(&quot;Can&#x27;t overwrite an existing customized value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt;&#123;</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;setting is &#123;:?&#125;&quot;,setting_value);</span><br><span class="line"></span><br><span class="line">    let numbers = (3,4,8,16,32);</span><br><span class="line">    match numbers &#123;</span><br><span class="line">        (first,_,third,_,fifth)=&gt;&#123;</span><br><span class="line">            println!(&quot;Some numbers:&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;,first,third,fifth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用以-开头命名来忽略未使用的变量"><a href="#使用以-开头命名来忽略未使用的变量" class="headerlink" title="使用以_开头命名来忽略未使用的变量"></a><strong>使用以_开头命名来忽略未使用的变量</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let _x = 5;</span><br><span class="line">    let y = 10;//编译器警告未使用的变量</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let s = Some(String::from(&quot;Hello!&quot;));</span><br><span class="line">    if let Some(_s) = s &#123;</span><br><span class="line">        println!(&quot;found a string&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模式匹配中_s 是一个新的变量，模式匹配把 s 所有权移动到_s,后面再访问 s 就会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let s = Some(String::from(&quot;Hello!&quot;));</span><br><span class="line">    if let Some(_) = s &#123;</span><br><span class="line">        println!(&quot;found a string&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_ ，不会发生绑定，不会移动所有权</p>
<h3 id="忽略值的剩余部分"><a href="#忽略值的剩余部分" class="headerlink" title="..(忽略值的剩余部分)"></a><strong>..(忽略值的剩余部分)</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">    z: i32,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let origin = Point&#123;x:0,y:0,z:0&#125;;</span><br><span class="line">    match origin &#123;</span><br><span class="line">        Point &#123;x,..&#125; =&gt; println!(&quot;x is &#123;&#125;&quot;,x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let numbers = (2,4,8,16,32);</span><br><span class="line">    match numbers &#123;</span><br><span class="line">        (first,..,last)=&gt;&#123;</span><br><span class="line">            println!(&quot;Some numbers: &#123;&#125;,&#123;&#125;&quot;,first,last)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要加逗号,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);</span><br><span class="line"></span><br><span class="line">    match numbers &#123;</span><br><span class="line">        (first,..,last) =&gt; &#123;</span><br><span class="line">           assert_eq!(first, 2);</span><br><span class="line">           assert_eq!(last, 2048);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-match-守卫来提供额外的条件"><a href="#使用-match-守卫来提供额外的条件" class="headerlink" title="使用 match 守卫来提供额外的条件"></a>使用 match 守卫来提供额外的条件</h2><ul>
<li>match 守卫就是 match arm 模式后额外的 if 条件，想要匹配该条件也必须满足</li>
<li>match 守卫适合更复杂的场景</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let num = Some(4);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Some(x) if x &lt; 5 =&gt; println!(&quot;less than five:&#123;&#125;&quot;,x),</span><br><span class="line">        Some(x) =&gt; println!(&quot;&#123;&#125;&quot;,x),</span><br><span class="line">        None =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let x = Some(5);</span><br><span class="line">    let y = 10;</span><br><span class="line"></span><br><span class="line">    match x &#123;</span><br><span class="line">        Some(50) =&gt; println!(&quot;Got 50&quot;),</span><br><span class="line">        Some(n) if n==y =&gt; println!(&quot;Matched,n = &#123;:?&#125;&quot;,n),//这里if n==y不是一个模式，不会引用新的变量</span><br><span class="line">        _ =&gt;println!(&quot;Default case,x =&#123;:?&#125;&quot;,x),</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;at the end:x=&#123;:?&#125;,y=&#123;:?&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let x= 4;</span><br><span class="line">    let y = false;</span><br><span class="line">    match x &#123;</span><br><span class="line">        4 | 5 | 6 if y=&gt; println!(&quot;yes&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;no&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h2><ul>
<li>@ 符号可以让我们可以创建一个变量，该变量可以在测试某个值是否与模式匹配的同时保存该值</li>
</ul>
<p>就相当于一个等号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">enum Message&#123;</span><br><span class="line">    Hello &#123;id:i32&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let msg = Message::Hello &#123; id: 5 &#125;;</span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Hello &#123; id: id_variable @ 3..=7, &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Found an id in range:&#123;&#125;&quot;,id_variable);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id: 10..=12 &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Found an id in another range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Found some other id:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // fill in the blank to let p match the second arm</span><br><span class="line">    let p = Point &#123; x: 2, y: 20 &#125;; // x can be [0, 5], y can be 10 20 or 30</span><br><span class="line"></span><br><span class="line">    match p &#123;</span><br><span class="line">        Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x),</span><br><span class="line">        // second arm</span><br><span class="line">        Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景：</p>
<p>下面这段代码会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Hello &#123; id: i32 &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let msg = Message::Hello &#123; id: 5 &#125;;</span><br><span class="line"></span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id:  3..=7,</span><br><span class="line">        &#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id),//Error cannot find value `id` in this scope</span><br><span class="line">        Message::Hello &#123; id: newid@10 | 11 | 12 &#125; =&gt; &#123;//Error variable `newid` is not bound in all patterns pattern doesn&#x27;t bind `newid`</span><br><span class="line">            println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修复错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Hello &#123; id: i32 &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let msg = Message::Hello &#123; id: 5 &#125;;</span><br><span class="line"></span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id: id @3..=7,</span><br><span class="line">        &#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id),</span><br><span class="line">        Message::Hello &#123; id: newid@(10 | 11 | 12) &#125; =&gt; &#123;</span><br><span class="line">            println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="unsafe-Rust"><a href="#unsafe-Rust" class="headerlink" title="unsafe Rust"></a>unsafe Rust</h1><ul>
<li>隐藏着第二个语言，它没有强制内存安全保证：unsafe Rust(不安全的 Rust)</li>
</ul>
<p>和普通的 Rust 一样，但提供了额外的超能力</p>
<ul>
<li>Unsafe Rust 存在的原因:</li>
</ul>
<ol>
<li>静态分析是保守的，使用 unsafe rust 就相当于告诉编译器：我知道自己在做什么，并承担相应的风险</li>
<li>计算机硬件本身就是不安全的，Rust 需要能够进行底层系统编程</li>
</ol>
<h2 id="unsafe-超能力"><a href="#unsafe-超能力" class="headerlink" title="unsafe 超能力"></a>unsafe 超能力</h2><ul>
<li>使用 unsafe 关键字来切换到 unsafe Rust，开启一个块，里面放着 unsafe 代码</li>
<li>unsafe Rust 里执行的四个动作（unsafe 超能力):</li>
</ul>
<ol>
<li>解引用原始指针</li>
<li>调用 unsafe 函数或方法</li>
<li>访问或修改可变的静态变量</li>
<li>实现 unsafe trait</li>
</ol>
<ul>
<li>注意：</li>
</ul>
<p>unsafe 并没有关系借用检查或停用其它安全的安全检查</p>
<p>任何内存安全相关的而错误必须留在 unsafe 块里</p>
<p>尽可能隔离 unsafe 代码，最好将其封装在安全的抽象里，提供安全的 API</p>
<h2 id="解引用原始指针"><a href="#解引用原始指针" class="headerlink" title="解引用原始指针"></a>解引用原始指针</h2><ul>
<li>原始指针</li>
</ul>
<p>可变的： *mut T</p>
<p>不可变的： *const T，意味着指针在解引用后不能直接对其进行赋值</p>
<p>注意：这里的*不是解引用符号，它是类型名的一部分</p>
<ul>
<li>与引用不同，原始指针:</li>
</ul>
<ol>
<li><strong>允许通过同时具有可变和不可变指针或指向同一位置的可变指针来忽略借用规则</strong></li>
<li>无法保证能指向合理的内存</li>
<li>允许为 null</li>
<li>不实现任何自动清理</li>
</ol>
<ul>
<li>放弃保证的安全，换取更好的性能/与其它语言或硬件接口的能力</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let mut num=5;</span><br><span class="line">    let r1 = &amp;num as *const i32;</span><br><span class="line">    let r2 = &amp;mut num as *mut i32;</span><br><span class="line">    let address = 0x012345usize;</span><br><span class="line">    let r = address as *const i32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在安全代码块里创建原始指针，但不能够解引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let mut num=5;</span><br><span class="line">    let r1 = &amp;num as *const i32;</span><br><span class="line">    let r2 = &amp;mut num as *mut i32;</span><br><span class="line"></span><br><span class="line">    unsafe&#123;</span><br><span class="line">        println!(&quot;r1:&#123;&#125;&quot;,*r1);</span><br><span class="line">        println!(&quot;r2:&#123;&#125;&quot;,*r2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let address = 0x012345usize;</span><br><span class="line">    let r = address as *const i32;</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        println!(&quot;r:&#123;&#125;&quot;,*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用原始指针？</p>
<ul>
<li>与 C 语言进行接口</li>
<li>构建借用检查器无法理解的安全抽象</li>
</ul>
<h2 id="调用-unsafe-函数或方法"><a href="#调用-unsafe-函数或方法" class="headerlink" title="调用 unsafe 函数或方法"></a>调用 unsafe 函数或方法</h2><ul>
<li>unsafe 函数或方法：在定义前加上了 unsafe 关键字</li>
</ul>
<p>——调用前需手动满足一些条件（主要靠看文档），因为 Rust 无法对这些条件进行验证</p>
<p>——需要在 unsafe 块里进行调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsafe fn dangerous()&#123;&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        dangerous();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-unsafe-代码的安全抽象"><a href="#创建-unsafe-代码的安全抽象" class="headerlink" title="创建 unsafe 代码的安全抽象"></a>创建 unsafe 代码的安全抽象</h2><ul>
<li>函数包含 unsafe 代码并不意味着需要将整个函数标记为 unsafe</li>
<li>将 unsafe 代码包裹在安全函数中是一个常见的抽象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use std::vec;</span><br><span class="line"></span><br><span class="line">fn split_at_mut(slice:&amp;mut[i32],mid:usize)-&gt;(&amp;mut [i32],&amp;mut[i32])&#123;</span><br><span class="line">    let len = slice.len();</span><br><span class="line">    assert!(mid&lt;=len);</span><br><span class="line">    (&amp;mut slice[..mid],&amp;mut slice[mid..])</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let mut v= vec![1,2,3,4,5,6];</span><br><span class="line">    let r = &amp;mut v[..];</span><br><span class="line">    let (a,b) = r.split_at_mut(3);</span><br><span class="line">    assert_eq!(a,&amp;mut [1,2,3]);</span><br><span class="line">    assert_eq!(b,&amp;mut [4,5,6]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `*slice` as mutable more than once at a time</span><br><span class="line"> --&gt; src\main.rs:6:29</span><br><span class="line">  |</span><br><span class="line">3 | fn split_at_mut(slice:&amp;mut[i32],mid:usize)-&gt;(&amp;mut [i32],&amp;mut[i32])&#123;</span><br><span class="line">  |                       - let&#x27;s call the lifetime of this reference `&#x27;1`</span><br><span class="line">...</span><br><span class="line">6 |     (&amp;mut slice[..mid],&amp;mut slice[mid..])</span><br><span class="line">  |     ------------------------^^^^^--------</span><br><span class="line">  |     |     |                 |</span><br><span class="line">  |     |     |                 second mutable borrow occurs here</span><br><span class="line">  |     |     first mutable borrow occurs here</span><br><span class="line">  |     returning this value requires that `*slice` is borrowed for `&#x27;1`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br></pre></td></tr></table></figure>
<p>使用 unfase 代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::slice;</span><br><span class="line">fn split_at_mut(slice: &amp;mut [i32],mid: usize)-&gt;(&amp;mut [i32],&amp;mut [i32])&#123;</span><br><span class="line">    let len = slice.len();</span><br><span class="line">    let ptr = slice.as_mut_ptr();</span><br><span class="line">    assert!(mid&lt;=len);</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        (</span><br><span class="line">            slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">            slice::from_raw_parts_mut(ptr.add(mid), len-mid)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let mut v= vec![1,2,3,4,5,6];</span><br><span class="line">    let r = &amp;mut v[..];</span><br><span class="line">    let (a,b) = r.split_at_mut(3);</span><br><span class="line">    assert_eq!(a,&amp;mut [1,2,3]);</span><br><span class="line">    assert_eq!(b,&amp;mut [4,5,6]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 extern 函数调用外部代码</h2><ul>
<li>extern 关键字：简化创建和使用外部函数接口（FFI）的过程</li>
<li>外部函数接口(FFI，Foreign Function Interface) : 它允许一种编程语言定义函数，并让其它编程语言能调用这些函数</li>
<li>extern 块中声明的函数在 Rust 代码中总是不安全的。因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;&#123;//&quot;C&quot;指明外部函数应用的二进制接口abi(application binary interface)</span><br><span class="line">    fn abs(input: i32) -&gt;i32;//想要调用的外部函数的签名</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        println!(&quot;Absolute value of -3 according to C:&#123;&#125;&quot;,abs(-3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应用二进制接口(ABI，Application Binary Interface):定义函数在汇编层的调用方式</li>
<li>“C” ABI 是最常见的 ABI,它遵循 C 语言的 ABI</li>
</ul>
<h2 id="从其它语言调用-Rust-函数"><a href="#从其它语言调用-Rust-函数" class="headerlink" title="从其它语言调用 Rust 函数"></a>从其它语言调用 Rust 函数</h2><ul>
<li>可以使用 extern 创建接口，其它语言通过它们可以调用 Rust 函数</li>
<li>在 fn 前添加 extern 关键字，并指定 ABI</li>
<li>还需添加#[no_mangle]注解：避免 Rust 在编译时改变它的名称</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn call_from_c()&#123;</span><br><span class="line">    println!(&quot;Just called a Rust function from C!&quot;);//编译链接后就可被c语言访问了，extern 的使用无需 unsafe。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问或修改一个可变的静态变量"><a href="#访问或修改一个可变的静态变量" class="headerlink" title="访问或修改一个可变的静态变量"></a>访问或修改一个可变的静态变量</h2><ul>
<li>Rust 支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争</li>
<li>在 Rust 里，全局变量叫做静态(static)变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;name is: &#123;&#125;&quot;, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态（static）变量类似常量。</li>
<li>通常静态变量的名称采用 SCREAMING_SNAKE_CASE 写法。</li>
<li>静态变量只能储存拥有 ‘static 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。</li>
<li>访问<strong>不可变静态变量</strong>是安全的。</li>
</ul>
<p>静态变量和常量的区别：</p>
<ul>
<li>静态变量中的值<strong>有一个固定的内存地址</strong>。使用这个值总是会访问相同的地址。常量则允许在任何被用到的时候<strong>复制其数据</strong>。</li>
<li>静态变量可以是可变的。访问和修改可变静态变量都是 <strong>不安全</strong> 的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static mut COUNTER: u32 = 0;</span><br><span class="line"></span><br><span class="line">fn add_to_count(inc: u32) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    add_to_count(3);</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">        println!(&quot;COUNTER: &#123;&#125;&quot;, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何读写 COUNTER 的代码都必须位于 unsafe 块中。这段代码可以编译并如期打印出 COUNTER: 3，因为这是单线程的。拥有多个线程访问 COUNTER 则可能导致数据竞争。</p>
<p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，优先使用智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的。</p>
<h2 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h2><ul>
<li>当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。</li>
<li>可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsafe trait Foo &#123;</span><br><span class="line">    // methods go here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsafe impl Foo for i32 &#123;</span><br><span class="line">    // method implementations go here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Sync 和 Send 标记 trait，编译器会自动为完全由 Send 和 Sync 类型组成的类型自动实现他们。如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe。Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 unsafe 表明。</p>
<h2 id="访问联合体中的字段"><a href="#访问联合体中的字段" class="headerlink" title="访问联合体中的字段"></a>访问联合体中的字段</h2><p>仅适用于 unsafe 的最后一个操作是访问 <strong>联合体</strong> 中的字段，union 和 struct 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互。访问联合体的字段是不安全的，因为 Rust 无法保证当前存储在联合体实例中数据的类型。可以查看 (<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doc.rust-lang.org/reference/items/unions.html">https://doc.rust-lang.org/reference/items/unions.html</a>) 了解有关联合体的更多信息。</p>
<h2 id="何时使用不安全的代码"><a href="#何时使用不安全的代码" class="headerlink" title="何时使用不安全的代码"></a>何时使用不安全的代码</h2><p>使用 unsafe 来进行这五个操作（超能力）之一是没有问题的，甚至是不需要深思熟虑的，不过使得 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全。当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注可以更容易地在错误发生时追踪问题的源头。</p>
<h1 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h1><h2 id="在-trait-定义中使用关联类型来指定占位类型"><a href="#在-trait-定义中使用关联类型来指定占位类型" class="headerlink" title="在 trait 定义中使用关联类型来指定占位类型"></a>在 trait 定义中使用关联类型来指定占位类型</h2><ul>
<li>关联类型(associate type)是 trait 中的类型占位符，它可以用于 trait 的方法签名中：</li>
</ul>
<p>——可以定义出包含某些类型的 trait，而在实现前无需知道这些类型是什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self)-&gt;Option&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联类型与泛型的区别"><a href="#关联类型与泛型的区别" class="headerlink" title="关联类型与泛型的区别"></a>关联类型与泛型的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>泛型</strong></th>
<th><strong>关联类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>每次实现 Trait 时标注类型</td>
<td>无需标注类型</td>
</tr>
<tr>
<td>可以为一个类型多次实现某个 Trait(不同的泛型参数)</td>
<td>无法为单个类型多次实现某个 Trait</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line">pub trait Iterator2&lt;T&gt;&#123;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line">struct Counter&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">impl Iterator for Counter&#123;//只能实现一次</span><br><span class="line">    type Item=u32;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// impl Iterator for Counter&#123;//只能实现一次,第二次为String实现报错</span><br><span class="line">//     type Item=String;</span><br><span class="line">//     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">//         None</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">impl Iterator2&lt;String&gt; for Counter &#123;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;String&gt; &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Iterator2&lt;u32&gt; for Counter &#123;//可以为不同的类型实现多次</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关联类型主要用于提升代码的可读性，例如以下代码 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable &#123;</span><br><span class="line">  type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash;</span><br><span class="line">  fn is_null(&amp;self) -&gt; bool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比 AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash， Address 的使用可以极大的减少其它类型在实现该特征时所需的模版代码.</p>
<p>例子：使用关联类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct Container(i32, i32);</span><br><span class="line"></span><br><span class="line">// 使用关联类型实现重新实现以下特征</span><br><span class="line">// trait Contains &#123;</span><br><span class="line">//    type A;</span><br><span class="line">//    type B;</span><br><span class="line"></span><br><span class="line">trait Contains&lt;A, B&gt; &#123;</span><br><span class="line">    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool;</span><br><span class="line">    fn first(&amp;self) -&gt; i32;</span><br><span class="line">    fn last(&amp;self) -&gt; i32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Contains&lt;i32, i32&gt; for Container &#123;</span><br><span class="line">    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123;</span><br><span class="line">        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    // Grab the first number.</span><br><span class="line">    fn first(&amp;self) -&gt; i32 &#123; self.0 &#125;</span><br><span class="line"></span><br><span class="line">    // Grab the last number.</span><br><span class="line">    fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn difference&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) -&gt; i32 &#123;</span><br><span class="line">    container.last() - container.first()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number_1 = 3;</span><br><span class="line">    let number_2 = 10;</span><br><span class="line"></span><br><span class="line">    let container = Container(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.contains(&amp;number_1, &amp;number_2));</span><br><span class="line">    println!(&quot;First number: &#123;&#125;&quot;, container.first());</span><br><span class="line">    println!(&quot;Last number: &#123;&#125;&quot;, container.last());</span><br><span class="line"></span><br><span class="line">    println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct Container(i32, i32);</span><br><span class="line"></span><br><span class="line">// A trait which checks if 2 items are stored inside of container.</span><br><span class="line">// Also retrieves first or last value.</span><br><span class="line">trait Contains &#123;</span><br><span class="line">    // Define generic types here which methods will be able to utilize.</span><br><span class="line">    type A;</span><br><span class="line">    type B;</span><br><span class="line"></span><br><span class="line">    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;</span><br><span class="line">    fn first(&amp;self) -&gt; i32;</span><br><span class="line">    fn last(&amp;self) -&gt; i32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Contains for Container &#123;</span><br><span class="line">    // Specify what types `A` and `B` are. If the `input` type</span><br><span class="line">    // is `Container(i32, i32)`, the `output` types are determined</span><br><span class="line">    // as `i32` and `i32`.</span><br><span class="line">    type A = i32;</span><br><span class="line">    type B = i32;</span><br><span class="line"></span><br><span class="line">    // `&amp;Self::A` and `&amp;Self::B` are also valid here.</span><br><span class="line">    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123;</span><br><span class="line">        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    // Grab the first number.</span><br><span class="line">    fn first(&amp;self) -&gt; i32 &#123; self.0 &#125;</span><br><span class="line"></span><br><span class="line">    // Grab the last number.</span><br><span class="line">    fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 &#123;</span><br><span class="line">    container.last() - container.first()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number_1 = 3;</span><br><span class="line">    let number_2 = 10;</span><br><span class="line"></span><br><span class="line">    let container = Container(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.contains(&amp;number_1, &amp;number_2));</span><br><span class="line">    println!(&quot;First number: &#123;&#125;&quot;, container.first());</span><br><span class="line">    println!(&quot;Last number: &#123;&#125;&quot;, container.last());</span><br><span class="line"></span><br><span class="line">    println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认泛型参数和运算符重载"><a href="#默认泛型参数和运算符重载" class="headerlink" title="默认泛型参数和运算符重载"></a>默认泛型参数和运算符重载</h2><ul>
<li>可以在使用泛型参数时为泛型指定一个默认的具体类型</li>
<li>语法：<PlaceholderType=ConcreteType></li>
<li>这种结束常用于运算符重载（operator overloading）</li>
<li>Rust 不允许创建自己的运算符及重载任意的运算符</li>
<li>但可以通过实现 std::ops 中列出的那些 trait 来重载一部分相应的运算符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Add;</span><br><span class="line"></span><br><span class="line">#[derive(Debug, PartialEq)]</span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">impl Add for Point &#123;</span><br><span class="line">    type Output = Point;</span><br><span class="line">    fn add(self, other: Point) -&gt; Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: self.x + other.x,</span><br><span class="line">            y: self.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!(</span><br><span class="line">        Point &#123; x: 1, y: 0 &#125; + Point &#123; x: 2, y: 3 &#125;,</span><br><span class="line">        Point &#123; x: 3, y: 3 &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的是 add 的默认泛型参数 self</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Add;</span><br><span class="line">struct Millimeters(u32);</span><br><span class="line">struct Meter(u32);</span><br><span class="line">impl Add&lt;Meter&gt; for Millimeters &#123;</span><br><span class="line">    type Output = Millimeters;</span><br><span class="line">    fn add(self, rhs: Meter) -&gt; Self::Output &#123;</span><br><span class="line">        Millimeters(self.0+(other.0*1000))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里指定泛型参数</p>
<h2 id="默认泛型参数的主要应用场景"><a href="#默认泛型参数的主要应用场景" class="headerlink" title="默认泛型参数的主要应用场景"></a>默认泛型参数的主要应用场景</h2><ul>
<li>扩展一个类型而不破坏现有的代码</li>
<li>允许在大部分用户都不需要的特定场景下进行自定义</li>
</ul>
<h2 id="完全限定语法-Fully-Qualified-Syntax"><a href="#完全限定语法-Fully-Qualified-Syntax" class="headerlink" title="完全限定语法(Fully Qualified Syntax)"></a>完全限定语法(Fully Qualified Syntax)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">trait Pilot &#123;</span><br><span class="line">    fn fly(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">trait Wizard &#123;</span><br><span class="line">    fn fly(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">struct Human;</span><br><span class="line"></span><br><span class="line">impl Pilot for Human &#123;</span><br><span class="line">    fn fly(&amp;self) &#123;</span><br><span class="line">        println!(&quot;This is your captain speaking&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Wizard for Human &#123;</span><br><span class="line">    fn fly(&amp;self) &#123;</span><br><span class="line">        println!(&quot;Up!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Human &#123;</span><br><span class="line">    fn fly(&amp;self)&#123;</span><br><span class="line">        println!(&quot;*waving arms furiously*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let person = Human;</span><br><span class="line">    person.fly();//调用本身的方法</span><br><span class="line">    Pilot::fly(&amp;person);//调用Pilot trait中的方法</span><br><span class="line">    Wizard::fly(&amp;person);//调用Wizard trait中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无参的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait Animal &#123;</span><br><span class="line">    fn baby_name()-&gt;String;</span><br><span class="line">&#125;</span><br><span class="line">struct Dog;</span><br><span class="line"></span><br><span class="line">impl Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String&#123;</span><br><span class="line">        String::from(&quot;Spot&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Animal for Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String &#123;</span><br><span class="line">        String::from(&quot;puppy&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,Dog::baby_name());</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,Animal::baby_name());//报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 baby_name 没有参数，编译器不知道是哪个 Dog 调用</p>
<ul>
<li>完全限定语法：<Type as Trait>::function(receiver_if_method,netx_arg,..) ;</li>
<li>可以在任何调用函数或方法的地方使用</li>
<li>允许忽略那些从其他上下文能推导出来的部分</li>
<li>当 Rust 无法区分你期望调用哪个具体实现的时候，才需要使用这种语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait Animal &#123;</span><br><span class="line">    fn baby_name()-&gt;String;</span><br><span class="line">&#125;</span><br><span class="line">struct Dog;</span><br><span class="line"></span><br><span class="line">impl Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String&#123;</span><br><span class="line">        String::from(&quot;Spot&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Animal for Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String &#123;</span><br><span class="line">        String::from(&quot;puppy&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,Dog::baby_name());</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,&lt;Dog as Animal&gt;::baby_name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-supertrait-来要求-trait-附带其它-trait-的功能"><a href="#使用-supertrait-来要求-trait-附带其它-trait-的功能" class="headerlink" title="使用 supertrait 来要求 trait 附带其它 trait 的功能"></a>使用 supertrait 来要求 trait 附带其它 trait 的功能</h2><ul>
<li>需要在一个 trait 中使用其它 trait 的功能</li>
</ul>
<p>——需要被依赖的 trait 也被实现</p>
<p>——那个被间接以来的 trait 就是当前 trait 的 supertrait</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::&#123;self, write&#125;;</span><br><span class="line">trait OutlinePrint: fmt::Display&#123;</span><br><span class="line">    fn outline_print(&amp;self)&#123;</span><br><span class="line">        let output = self.to_string();</span><br><span class="line">        let len = output.len();</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,&quot;*&quot;.repeat(len+4));</span><br><span class="line">        println!(&quot;*&#123;&#125;*&quot;,&quot; &quot;.repeat(len+2));</span><br><span class="line">        println!(&quot;* &#123;&#125; *&quot;,output);</span><br><span class="line">        println!(&quot;*&#123;&#125;*&quot;,&quot; &quot;.repeat(len+2));</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,&quot;*&quot;.repeat(len+4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Point&#123;</span><br><span class="line">    x:i32,</span><br><span class="line">    y:i32,</span><br><span class="line">&#125;</span><br><span class="line">impl OutlinePrint for Point &#123;</span><br><span class="line">&#125;</span><br><span class="line">impl fmt::Display for Point &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f, &quot;(&#123;&#125;,&#123;&#125;)&quot;,self.x,self.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-newtype-模式在外部类型上实现外部-trait"><a href="#使用-newtype-模式在外部类型上实现外部-trait" class="headerlink" title="使用 newtype 模式在外部类型上实现外部 trait"></a>使用 newtype 模式在外部类型上实现外部 trait</h2><ul>
<li>孤儿类型：只有当 trait 或类型定义在本地包时，才能为该类型实现这个 trait</li>
<li>可以通过 newtype 模式来绕过这一规则</li>
</ul>
<p>——利用 tuple struct（元组结构体）创建一个新的类型</p>
<p>（例子）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt;</span><br><span class="line">struct Wrapper(Vec&lt;String&gt;);</span><br><span class="line"></span><br><span class="line">impl fmt::Display for Wrapper&#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f,&quot;[&#123;&#125;]&quot;,self.0.join(&quot;, &quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let w = Wrapper(vec![String::from(&quot;hello&quot;),String::from(&quot;world&quot;)]);</span><br><span class="line">    println!(&quot;w=&#123;&#125;&quot;,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="使用-newtype-模式实现类型安全和抽象"><a href="#使用-newtype-模式实现类型安全和抽象" class="headerlink" title="使用 newtype 模式实现类型安全和抽象"></a>使用 newtype 模式实现类型安全和抽象</h2><ul>
<li>newtype 模式可以：</li>
</ul>
<p>——用来静态的保证各种值之间不会混淆并表明值的单位</p>
<p>——为类型的某些细节提供抽象能力</p>
<p>——通过轻量级的封装来隐藏内部实现细节</p>
<h2 id="适用类型别名创建类型同义词"><a href="#适用类型别名创建类型同义词" class="headerlink" title="适用类型别名创建类型同义词"></a>适用类型别名创建类型同义词</h2><ul>
<li>Rust 提供了类型别名的功能：——为现有的类型生产另外的名称（同义词）——并不是一个独立的类型——使用 type 关键字</li>
<li>主要用途：减少代码的字符重复</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn takes_long_type(f: Box&lt;dyn Fn()+Send+&#x27;static&gt;)&#123;</span><br><span class="line">    //snip</span><br><span class="line">&#125;</span><br><span class="line">fn returns_long_type()-&gt;Box&lt;dyn Fn()+Send+&#x27;static&gt;&#123;</span><br><span class="line">    Box::new(|| println!(&quot;hi&quot;))</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let f:Box&lt;dyn Fn()+Send+&#x27;static&gt; = Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类型别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Thunk = Box&lt;dyn Fn()+Send+&#x27;static&gt;;</span><br><span class="line">fn takes_long_type(f: Thunk)&#123;</span><br><span class="line">    //snip</span><br><span class="line">&#125;</span><br><span class="line">fn returns_long_type()-&gt;Thunk&#123;</span><br><span class="line">    Box::new(|| println!(&quot;hi&quot;))</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let f:Thunk = Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line">&#125;</span><br><span class="line">use std::io::Error;</span><br><span class="line">use std::fmt;</span><br><span class="line">pub trait Write &#123;</span><br><span class="line">    fn write(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;usize,Error&gt;;</span><br><span class="line">    fn flush(&amp;mut self)-&gt;Result&lt;(),Error&gt;;</span><br><span class="line">    fn write_all(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;(),Error&gt;;</span><br><span class="line">    fn write_fmt(&amp;mut self,fmt: fmt::Arguments)-&gt;Result&lt;(),Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类型别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use std::io::Error;</span><br><span class="line">use std::fmt;</span><br><span class="line">// type Result&lt;T&gt; = Result&lt;T,std::io::Error&gt;;标准库中定义了这个</span><br><span class="line">type Result&lt;T&gt; = std::io::Result&lt;T&gt;;</span><br><span class="line">pub trait Write &#123;</span><br><span class="line">    fn write(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;usize&gt;;</span><br><span class="line">    fn flush(&amp;mut self)-&gt;Result&lt;()&gt;;</span><br><span class="line">    fn write_all(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;()&gt;;</span><br><span class="line">    fn write_fmt(&amp;mut self,fmt: fmt::Arguments)-&gt;Result&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><ul>
<li>有一个名为！的特殊类型：</li>
</ul>
<p>——它没有任何值，行话成为空类型（empty type）</p>
<p>——我们倾向于叫它 never 类型，因为它在不反悔的函数中充当返回类型</p>
<ul>
<li>不返回值的函数也被称作发散函数（diverging fuction)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn bar() -&gt; !&#123;</span><br><span class="line">    //return (),返回了单元类型,但是不可能创建出返回!类型的函数</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let guess = &quot;&quot;;</span><br><span class="line">    loop&#123;</span><br><span class="line">        let guess:u32 = match guess.trim().parse() &#123;</span><br><span class="line">            Ok(num) =&gt; num,</span><br><span class="line">            Err(_) =&gt; continue,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match 表达式要求各个分支返回的类型是相同的，而 continue 会返回 never 类型，该类型可以安全地强制转换为 num 所对应的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T&gt; Option&lt;T&gt;&#123;</span><br><span class="line">    pub fn unwrap(self) -&gt; T&#123;</span><br><span class="line">        match self&#123;</span><br><span class="line">            Some(val) =&gt; val,</span><br><span class="line">            None=&gt;panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>panic！返回 never 类型</p>
<h2 id="动态大小和-Sized-Trait"><a href="#动态大小和-Sized-Trait" class="headerlink" title="动态大小和 Sized Trait"></a>动态大小和 Sized Trait</h2><ul>
<li>Rust 需要在编译时确定为一个特定类型的值分配多少空间</li>
<li>动态大小的类型（Dynamically Sized Types,DST）的概念:</li>
</ul>
<p>—— 编写代码时使用只有在运行时才能确定大小的值</p>
<ul>
<li>str 是动态大小的类型（注意不是&amp;str）:只有运行时才能确定字符串的长度</li>
</ul>
<p>—— 以下代码无法正常工作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1:str = &quot;Hello therel&quot;;</span><br><span class="line">let s2:str = &quot;How is it going&quot;;</span><br></pre></td></tr></table></figure>
<p>因为他们都是同一个类型，需要的空间应该一样，但是这里声明时没有确定共同的空间</p>
<p>解决办法: 使用&amp;str 字符串切片类型</p>
<h2 id="Rust-使用动态大小类型的通用方式"><a href="#Rust-使用动态大小类型的通用方式" class="headerlink" title="Rust 使用动态大小类型的通用方式"></a>Rust 使用动态大小类型的通用方式</h2><ul>
<li>附带一些额外的元数据来存储动态信息的大小—— 使用动态大小类型时总会把它的值放在某种指针后面</li>
</ul>
<h2 id="另外一种动态大小的类型：trait"><a href="#另外一种动态大小的类型：trait" class="headerlink" title="另外一种动态大小的类型：trait"></a>另外一种动态大小的类型：trait</h2><ul>
<li>每个 trait 都是一个动态大小的类型，可以通过名称对其进行引用</li>
<li>为了将 trait 用作 trait 对象，必须将它放置在某种指针之后</li>
</ul>
<p>—— 例如 &amp;dyn Trait 或 Box<dyn Trait> (Rc<dyn Trait>) 之后</p>
<h2 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h2><ul>
<li>为了处理动态大小的类型，Rust 提供了一个 Sized trait 来确定一个类型的大小在编译时是否已知——<strong>编译时可计算出大小的类型会自动实现这一 trait</strong>——<strong>Rust 还会为每一个泛型函数隐式的添加 Sized 约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T&gt;(t:T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn generic&lt;T: Sized&gt;(t:T)&#123;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，泛型函数只能被用于编译时已经知道大小的类型，可以通过特殊语法来解除这一限制</li>
</ul>
<h2 id="Sized-trait-约束"><a href="#Sized-trait-约束" class="headerlink" title="?Sized trait 约束"></a>?Sized trait 约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T: ?Sized&gt;(t:&amp;T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T 可能是也可能不是 Sized</li>
<li>这个语法只能用在 Sized 上面，不能被用于其它 trait</li>
</ul>
<h1 id="高级函数和闭包"><a href="#高级函数和闭包" class="headerlink" title="高级函数和闭包"></a>高级函数和闭包</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li>可以将函数传递给其它函数</li>
<li>函数在传递过程中会被强制转换为 fn 类型</li>
<li>fn 类型就是 <strong>函数指针(function pointer)</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn add_one(x:i32)-&gt;i32&#123;</span><br><span class="line">    x+1</span><br><span class="line">&#125;</span><br><span class="line">fn do_twice(f: fn(i32)-&gt;i32,arg:i32)-&gt;i32&#123;</span><br><span class="line">    f(arg) + f(arg)</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let answer = do_twice(add_one, 5);</span><br><span class="line">    println!(&quot;The answer is:&#123;&#125;&quot;,answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针与闭包的不同"><a href="#函数指针与闭包的不同" class="headerlink" title="函数指针与闭包的不同"></a>函数指针与闭包的不同</h2><ul>
<li>fn 是一个类型而不是一个 trait</li>
</ul>
<p>——可以直接指定 fn 为参数类型，不用声明一个以 Fn trait 为约束的泛型参数</p>
<ul>
<li>函数指针实现了全部 3 种闭包 trait（Fn,FnMut,FnOnce）:</li>
</ul>
<p>——总是可以把函数指针用作参数传递给一个接受闭包的参数</p>
<p>——所以，倾向于搭配闭包 trait 的泛型来编写函数：可以同时接收闭包和普通函数</p>
<ul>
<li>某些情景，只想接收 fn 而不接收闭包</li>
</ul>
<p>——与外部不支持闭包的代码交互：C 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let list_of_numbers = vec![1,2,3];</span><br><span class="line">    let list_of_strings:Vec&lt;String&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(|i| i.to_string())</span><br><span class="line">    .collect();</span><br><span class="line"></span><br><span class="line">    let list_of_numbers = vec![1,2,3];</span><br><span class="line">    let list_of_strings: Vec&lt;String&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(ToString::to_string)</span><br><span class="line">    .collect();</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    enum Status&#123;</span><br><span class="line">        Value(u32),</span><br><span class="line">        Stop,</span><br><span class="line">    &#125;</span><br><span class="line">    let v = Status::Value(3);</span><br><span class="line">    let list_of_statuses:Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h2><ul>
<li>闭包使用 trait 进行表达，无法在函数中直接返回一个闭包，可以将一个实现了该 trait 的具体类型作为返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// fn returns_closure()-&gt;Fn(i32)-&gt;i32&#123;//返回类型大小不固定</span><br><span class="line">//     |x| x+1</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">fn returns_closure() -&gt; Box&lt;dyn Fn(i32)-&gt;i32&gt;&#123;</span><br><span class="line">    Box::new(|x| x+1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html#宏">https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html#%E5%AE%8F</a></p>
<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice</span><br><span class="line">    assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2), &quot;21&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;1&#125;&#123;&#125;&#123;0&#125;&#123;&#125;&quot;, 1, 2), &quot;2112&quot;);</span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot;</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, name = 2), &quot;21&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;);</span><br><span class="line"></span><br><span class="line">    // named argument must be placed after other arguments</span><br><span class="line">    println!(&quot;&#123;abc&#125; &#123;0&#125;&quot;, 2, abc = &quot;def&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h2><p>默认情况下，通过空格来填充字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // the following two are padding with 5 spaces</span><br><span class="line">    println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt;  &quot;Hello x    !&quot;</span><br><span class="line">    println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt;  &quot;Hello x    !&quot;</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;1:0$&#125;!&quot;, 5, &quot;x&quot;), &quot;Hello x    !&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:width$&#125;!&quot;, &quot;x&quot;, width = 5), &quot;Hello x    !&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左对齐, 右对齐, 使用指定的字符填充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // left align</span><br><span class="line">    println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x    !</span><br><span class="line">    // right align</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:&gt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello     x!&quot;);</span><br><span class="line">    // center align</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:^5&#125;!&quot;, &quot;x&quot;), &quot;Hello   x  !&quot;);</span><br><span class="line"></span><br><span class="line">    // left align, pad with &#x27;&amp;&#x27;</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x&amp;&amp;&amp;&amp;!&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还能使用 0 来填充数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Hello &#123;:5&#125;!&quot;, 5); // =&gt; Hello     5!</span><br><span class="line">    println!(&quot;Hello &#123;:+&#125;!&quot;, 5); // =&gt;  Hello +5!</span><br><span class="line">    println!(&quot;Hello &#123;:05&#125;!&quot;, 5); // =&gt; Hello 00005!</span><br><span class="line">    println!(&quot;Hello &#123;:05&#125;!&quot;, -5); // =&gt; Hello -0005!</span><br><span class="line"></span><br><span class="line">    assert!(format!(&quot;&#123;number:0&gt;width$&#125;&quot;, number=1, width=6) == &quot;000001&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>浮点数精度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = 3.1415926;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;&#123;:.2&#125;&quot;, v), &quot;3.14&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:+.2&#125;&quot;, v), &quot;+3.14&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:.0&#125;&quot;, v), &quot;3&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;Hello, world!&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;1:.0$&#125;!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制，八进制，十六进制"><a href="#二进制，八进制，十六进制" class="headerlink" title="二进制，八进制，十六进制"></a>二进制，八进制，十六进制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#b&#125;&quot;, 27), &quot;0b11011&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#o&#125;&quot;, 27), &quot;0o33&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#x&#125;&quot;, 27), &quot;0x1b&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#X&#125;&quot;, 27), &quot;0x1B&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:x&#125;!&quot;, 27); // hex with no prefix =&gt; 1b</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:#010b&#125;&quot;, 27); // pad binary with 0, width = 10,  =&gt; 0b00011011</span><br><span class="line"></span><br><span class="line">   println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="捕获环境中的值"><a href="#捕获环境中的值" class="headerlink" title="捕获环境中的值"></a>捕获环境中的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn get_person() -&gt; String &#123;</span><br><span class="line">    String::from(&quot;sunface&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn get_format() -&gt; (usize, usize) &#123;</span><br><span class="line">    (4, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let person = get_person();</span><br><span class="line">    println!(&quot;Hello, &#123;person&#125;!&quot;);</span><br><span class="line"></span><br><span class="line">    let (width, precision) = get_format();</span><br><span class="line">    let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)];</span><br><span class="line">    /* Make it print:</span><br><span class="line">    sunface:   99.1</span><br><span class="line">    jack:   60.3</span><br><span class="line">    */</span><br><span class="line">    for (name, score) in scores &#123;</span><br><span class="line">        println!(&quot;&#123;name&#125;: &#123;score:width$.precision$&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指数，指针地址，转义"><a href="#指数，指针地址，转义" class="headerlink" title="指数，指针地址，转义"></a>指数，指针地址，转义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 指数</span><br><span class="line">    println!(&quot;&#123;:2e&#125;&quot;, 1000000000); // =&gt; 1e9</span><br><span class="line">    println!(&quot;&#123;:2E&#125;&quot;, 1000000000); // =&gt; 1E9</span><br><span class="line"></span><br><span class="line">    // 指针地址</span><br><span class="line">    let v= vec![1, 2, 3];</span><br><span class="line">    println!(&quot;&#123;:p&#125;&quot;, v.as_ptr()); // =&gt; 0x600002324050</span><br><span class="line"></span><br><span class="line">    // 转义</span><br><span class="line">    println!(&quot;Hello &#123;&#123;&#125;&#125;&quot;); // =&gt; Hello &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="1-错误处理："><a href="#1-错误处理：" class="headerlink" title="1.错误处理："></a>1.错误处理：</h2><h3 id="unreachable"><a href="#unreachable" class="headerlink" title="unreachable!()"></a>unreachable!()</h3><p>这是标记程序不应输入的路径的标准宏。如果程序进入这些路径，程序将 panicked 并返回”‘internal error: entered unreachable code’”错误消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">level</span> = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stage</span> = <span class="keyword">match</span> level &#123;</span><br><span class="line">        <span class="number">1</span>...<span class="number">5</span> =&gt; <span class="string">&quot;beginner&quot;</span>,</span><br><span class="line">        <span class="number">6</span>...<span class="number">10</span> =&gt; <span class="string">&quot;intermediate&quot;</span>,</span><br><span class="line">        <span class="number">11</span>...<span class="number">20</span> =&gt; <span class="string">&quot;expert&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, stage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code<span class="string">&#x27;, src/main.rs:7:20</span></span><br></pre></td></tr></table></figure>
<p>我们也可以为此设置自定义错误消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- with a custom message ---</span></span><br><span class="line">_ =&gt; <span class="built_in">unreachable!</span>(<span class="string">&quot;Custom message&quot;</span>),</span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: Custom message<span class="string">&#x27;, src/main.rs:7:20</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// --- with debug data ---</span></span><br><span class="line"><span class="string">_ =&gt; unreachable!(&quot;level is &#123;&#125;&quot;, level),</span></span><br><span class="line"><span class="string">// -------------- Compile time error --------------</span></span><br><span class="line"><span class="string">thread &#x27;</span>main<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: level is <span class="number">22</span><span class="string">&#x27;, src/main.rs:7:14</span></span><br></pre></td></tr></table></figure>
<h2 id="2-misconception-corollaries"><a href="#2-misconception-corollaries" class="headerlink" title="2.misconception corollaries"></a>2.misconception corollaries</h2><h3 id="2-1-if-T-39-static-then-T-must-be-valid-for-the-entire-program"><a href="#2-1-if-T-39-static-then-T-must-be-valid-for-the-entire-program" class="headerlink" title="2.1 if T: &#39;static then T must be valid for the entire program"></a>2.1 if <code>T: &#39;static</code> then <code>T</code> must be valid for the entire program</h3><p><strong>Misconception Corollaries</strong></p>
<ul>
<li><code>T: &#39;static</code> should be read as <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em></li>
<li><code>&amp;&#39;static T</code> and <code>T: &#39;static</code> are the same thing</li>
<li>if <code>T: &#39;static</code> then <code>T</code> must be immutable</li>
<li>if <code>T: &#39;static</code> then <code>T</code> can only be created at compile time</li>
</ul>
<p>Most Rust beginners get introduced to the <code>&#39;static</code> lifetime for the first time in a code example that looks something like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_literal</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;str literal&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>They get told that <code>&quot;str literal&quot;</code> is hardcoded into the compiled binary and is loaded into read-only memory at run-time so it’s immutable and valid for the entire program and that’s what makes it <code>&#39;static</code>. These concepts are further reinforced by the rules surrounding defining <code>static</code> variables using the <code>static</code> keyword.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This example is purely for illustrative purposes.</span></span><br><span class="line"><span class="comment">// Never use `static mut`. It&#x27;s a footgun. There are</span></span><br><span class="line"><span class="comment">// safe patterns for global mutable singletons in Rust but</span></span><br><span class="line"><span class="comment">// those are outside the scope of this article.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MUT_BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// ❌ - mutating static is unsafe</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">99</span>, MUT_BYTES[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Regarding <code>static</code> variables</p>
<ul>
<li>they can only be created at compile-time</li>
<li>they should be immutable, mutating them is unsafe</li>
<li>they’re valid for the entire program</li>
</ul>
<p>The <code>&#39;static</code> lifetime was probably named after the default lifetime of <code>static</code> variables, right? So it makes sense that the <code>&#39;static</code> lifetime has to follow all the same rules, right?</p>
<p>Well yes, but a type <em>with</em> a <code>&#39;static</code> lifetime is different from a type <em>bounded by</em> a <code>&#39;static</code> lifetime. The latter can be dynamically allocated at run-time, can be safely and freely mutated, can be dropped, and can live for arbitrary durations.</p>
<p>It’s important at this point to distinguish <code>&amp;&#39;static T</code> from <code>T: &#39;static</code>.</p>
<p><code>&amp;&#39;static T</code> is an immutable reference to some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. This is only possible if <code>T</code> itself is immutable and does not move <em>after the reference was created</em>. <code>T</code> does not need to be created at compile-time. It’s possible to generate random dynamically allocated data at run-time and return <code>&#39;static</code> references to it at the cost of leaking memory, e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate random &#x27;static str refs at run-time</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rand_str_generator</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(rand_string.<span class="title function_ invoke__">into_boxed_str</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T: &#39;static</code> is some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. <code>T: &#39;static</code> includes all <code>&amp;&#39;static T</code> however it also includes all owned types, like <code>String</code>, <code>Vec</code>, etc. The owner of some data is guaranteed that data will never get invalidated as long as the owner holds onto it, therefore the owner can safely hold onto the data indefinitely long, including up until the end of the program. <code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em> not <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em>. A program to help illustrate these concepts:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">drop_static</span>&lt;T: <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand::<span class="title function_ invoke__">random</span>() &#123;</span><br><span class="line">            <span class="comment">// all the strings are randomly generated</span></span><br><span class="line">            <span class="comment">// and dynamically allocated at run-time</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            strings.<span class="title function_ invoke__">push</span>(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strings are owned types so they&#x27;re bounded by &#x27;static</span></span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">mut</span> string <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// all the strings are mutable</span></span><br><span class="line">        string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;a mutation&quot;</span>);</span><br><span class="line">        <span class="comment">// all the strings are droppable</span></span><br><span class="line">        <span class="title function_ invoke__">drop_static</span>(string); <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all the strings have been invalidated before the end of the program</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am the end of the program&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Key Takeaways</strong></p>
<ul>
<li><p><code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em></p>
</li>
<li><p>if <code>T: &#39;static</code> then <code>T</code> can be a borrowed type with a <code>&#39;static</code> lifetime <em>or</em> an owned type</p>
</li>
<li><p>since</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">T:</span> <span class="comment">&#x27;static</span></span><br></pre></td></tr></table></figure>
<p>includes owned types that means</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">T</span></span><br></pre></td></tr></table></figure>
<ul>
<li>can be dynamically allocated at run-time</li>
<li>does not have to be valid for the entire program</li>
<li>can be safely and freely mutated</li>
<li>can be dynamically dropped at run-time</li>
<li>can have lifetimes of different durations</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/42871/">https://even629.com/posts/42871/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/programming/">programming</a></div><div class="post-share"><div class="social-share" data-image="/images/rust_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3227/" title="leetcode每日一题 P3227 字符串元音游戏"><img class="cover" src="/images/leetcode_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">leetcode每日一题 P3227 字符串元音游戏</div></div><div class="info-2"><div class="info-item-1">状态分析</div></div></div></a><a class="pagination-related" href="/posts/2785/" title="leetcode每日一题 P2785 将字符串中的元音字母排序"><img class="cover" src="/images/leetcode_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">leetcode每日一题 P2785 将字符串中的元音字母排序</div></div><div class="info-2"><div class="info-item-1">计数排序</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/43000/" title="C++"><img class="cover" src="/images/cpp.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-19</div><div class="info-item-2">C++</div></div><div class="info-2"><div class="info-item-1">C++ language</div></div></div></a><a class="pagination-related" href="/posts/42882/" title="C"><img class="cover" src="/images/C_lang.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-07-19</div><div class="info-item-2">C</div></div><div class="info-2"><div class="info-item-1">C language</div></div></div></a><a class="pagination-related" href="/posts/43001/" title="数据结构"><img class="cover" src="/images/data_structure.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-14</div><div class="info-item-2">数据结构</div></div><div class="info-2"><div class="info-item-1">数据结构</div></div></div></a><a class="pagination-related" href="/posts/50010/" title="Golang"><img class="cover" src="/images/golang_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-14</div><div class="info-item-2">Golang</div></div><div class="info-2"><div class="info-item-1">golang笔记</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center" id="my-custom-card-author"><div class="avatar-img"><img src="/img/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/even629"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告：欢迎留言~</span></div><div class="announcement_content">--- ZH ❤️ YW ---</div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">安装与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">1.2.</span> <span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cargo"><span class="toc-number">2.</span> <span class="toc-text">Cargo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">创建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-Cargo-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.2.</span> <span class="toc-text">构建 Cargo 项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C-Cargo-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.3.</span> <span class="toc-text">构建和运行 Cargo 项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cargo-check"><span class="toc-number">2.4.</span> <span class="toc-text">cargo check</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%9E%84%E5%BB%BA"><span class="toc-number">2.5.</span> <span class="toc-text">发布构建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">变量与可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F-shadow"><span class="toc-number">3.0.3.</span> <span class="toc-text">隐藏(shadow)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.4.</span> <span class="toc-text">允许未使用的变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">标量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97"><span class="toc-number">4.1.3.</span> <span class="toc-text">序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.5.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.6.</span> <span class="toc-text">单元类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">元组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">数组类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-as-%E8%BF%9B%E8%A1%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.1.</span> <span class="toc-text">使用 as 进行基本类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-Into"><span class="toc-number">4.3.2.</span> <span class="toc-text">From&#x2F;Into</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0-From-%E7%89%B9%E5%BE%81"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">为自定义类型实现 From 特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TryFrom-TryInto"><span class="toc-number">4.3.3.</span> <span class="toc-text">TryFrom &#x2F; TryInto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.4.</span> <span class="toc-text">其它转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%88%90-String"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">将任何类型转换成 String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-String"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">解析 String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0-FromStr-%E7%89%B9%E5%BE%81"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">自定义实现 FromStr 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transmute"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">transmute</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">语句与表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.4.3.</span> <span class="toc-text">返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%BA"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">返回类型为()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%BA-never"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">返回类型为 never</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0%EF%BC%88Diverging-function%EF%BC%89"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">发散函数（Diverging function）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">4.5.</span> <span class="toc-text">控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.5.1.</span> <span class="toc-text">if 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-let-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8-if"><span class="toc-number">4.5.2.</span> <span class="toc-text">在 let 语句中使用 if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.5.3.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loop"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">loop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%BE%AA%E7%8E%AF%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.5.3.1.1.</span> <span class="toc-text">从循环中返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%A0%87%E7%AD%BE"><span class="toc-number">4.5.3.1.2.</span> <span class="toc-text">循环标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while"><span class="toc-number">4.5.4.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">4.5.5.</span> <span class="toc-text">for</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E5%92%8C%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">通过索引和值的方式迭代数组</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%8C%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">所有权，引用与借用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B8%8E%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">栈（Stack）与堆（Heap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">所有权规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB%E6%97%B6%EF%BC%8C%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%9A%8F%E4%B9%8B%E6%94%B9%E5%8F%98%E3%80%82"><span class="toc-number">5.2.1.</span> <span class="toc-text">当所有权转移时，可变性也可以随之改变。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.3.</span> <span class="toc-text">变量与作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#str-%E5%92%8C-amp-str"><span class="toc-number">5.4.</span> <span class="toc-text">str 和&amp;str</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">String 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D"><span class="toc-number">5.6.</span> <span class="toc-text">内存与分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">变量与数据交互的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#move"><span class="toc-number">5.7.1.</span> <span class="toc-text">move</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86-move"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">部分 move</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-number">5.7.2.</span> <span class="toc-text">clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy"><span class="toc-number">5.7.3.</span> <span class="toc-text">copy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">5.8.</span> <span class="toc-text">所有权与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.8.1.</span> <span class="toc-text">返回值与作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8"><span class="toc-number">5.9.</span> <span class="toc-text">引用与借用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rust-%E4%BC%9A%E5%9C%A8%E6%9F%90%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">5.9.1.</span> <span class="toc-text">rust 会在某些情况下自动解引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="toc-number">5.9.2.</span> <span class="toc-text">可变引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%AC%E7%A9%BA%E5%BC%95%E7%94%A8%EF%BC%88%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8-Dangling-References"><span class="toc-number">5.9.3.</span> <span class="toc-text">悬空引用（悬垂引用 Dangling References)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-number">5.9.4.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%A7%84%E5%88%99-%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99-%E6%80%BB%E7%BB%93"><span class="toc-number">5.9.5.</span> <span class="toc-text">引用规则(借用规则)总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#None-Lexical-Lifetimes-NLL"><span class="toc-number">5.9.6.</span> <span class="toc-text">None Lexical Lifetimes(NLL)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B-Slice"><span class="toc-number">5.10.</span> <span class="toc-text">切片类型 Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87-string-slice"><span class="toc-number">5.10.1.</span> <span class="toc-text">字符串切片 string slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B0%B1%E6%98%AF-slice"><span class="toc-number">5.10.2.</span> <span class="toc-text">字符串字面值就是 slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">5.10.3.</span> <span class="toc-text">字符串 slice 作为参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84-slice"><span class="toc-number">5.10.4.</span> <span class="toc-text">其他类型的 slice</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.1.</span> <span class="toc-text">定义结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-number">6.3.</span> <span class="toc-text">访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AE%80%E5%86%99"><span class="toc-number">6.4.</span> <span class="toc-text">字段初始化简写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Struct-%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">Struct 更新语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple-Struct-%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.6.</span> <span class="toc-text">Tuple Struct 元组结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%AD%97%E6%AE%B5%E7%9A%84%E7%B1%BB%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88unit-like-structs%EF%BC%89"><span class="toc-number">6.7.</span> <span class="toc-text">没有任何字段的类单元结构体（unit-like structs）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">6.8.</span> <span class="toc-text">struct 中的所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0-struct"><span class="toc-number">6.9.</span> <span class="toc-text">打印 struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.10.</span> <span class="toc-text">struct 的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.11.</span> <span class="toc-text">方法调用的运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">6.12.</span> <span class="toc-text">关联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.13.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.1.</span> <span class="toc-text">定义枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="toc-number">7.2.</span> <span class="toc-text">枚举值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E9%99%84%E5%8A%A0%E5%88%B0%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%8F%98%E4%BD%93%E4%B8%AD"><span class="toc-number">7.3.</span> <span class="toc-text">将数据附加到枚举的变体中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">枚举中定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Option-%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.5.</span> <span class="toc-text">Option 枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8"><span class="toc-number">7.6.</span> <span class="toc-text">枚举实现链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">8.</span> <span class="toc-text">模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#match-%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">match 控制流结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#matches"><span class="toc-number">8.1.1.</span> <span class="toc-text">matches!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%80%BC%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text">绑定值的模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D-Option"><span class="toc-number">8.1.3.</span> <span class="toc-text">匹配 Option</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#match-%E5%8C%B9%E9%85%8D%E5%BF%85%E9%A1%BB%E7%A9%B7%E4%B8%BE%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="toc-number">8.1.4.</span> <span class="toc-text">match 匹配必须穷举所有的可能性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-let-%E7%AE%80%E6%B4%81%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">8.2.</span> <span class="toc-text">if let 简洁控制流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BD"><span class="toc-number">8.3.</span> <span class="toc-text">模式匹配中的变量遮蔽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Workspace-Package-Crate-Module"><span class="toc-number">9.</span> <span class="toc-text">Workspace, Package,Crate,Module</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cargo-%E7%9A%84%E6%83%AF%E4%BE%8B"><span class="toc-number">9.1.</span> <span class="toc-text">Cargo 的惯例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-module-%E6%9D%A5%E6%8E%A7%E5%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%A7%81%E6%9C%89%E6%80%A7"><span class="toc-number">9.2.</span> <span class="toc-text">定义 module 来控制作用域和私有性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-number">9.3.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E8%BE%B9%E7%95%8C%EF%BC%88privacy-boundary"><span class="toc-number">9.4.</span> <span class="toc-text">私有边界（privacy boundary)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super"><span class="toc-number">9.5.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pub-struct"><span class="toc-number">9.6.</span> <span class="toc-text">pub struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pub-enum"><span class="toc-number">9.7.</span> <span class="toc-text">pub enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#use-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.8.</span> <span class="toc-text">use 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#use-%E7%9A%84%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-number">9.9.</span> <span class="toc-text">use 的习惯用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-as-%E5%85%B3%E9%94%AE%E5%AD%97%E6%8F%90%E4%BE%9B%E6%96%B0%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">9.10.</span> <span class="toc-text">使用 as 关键字提供新的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pub-use-%E9%87%8D%E5%AF%BC%E5%87%BA"><span class="toc-number">9.11.</span> <span class="toc-text">pub use 重导出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pub-in-Crate"><span class="toc-number">9.12.</span> <span class="toc-text">pub(in Crate)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8C%85-package"><span class="toc-number">9.13.</span> <span class="toc-text">使用外部包(package)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E8%B7%AF%E5%BE%84%E6%B8%85%E7%90%86%E5%A4%A7%E9%87%8F%E7%9A%84-use-%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.14.</span> <span class="toc-text">使用嵌套路径清理大量的 use 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">9.15.</span> <span class="toc-text">通配符*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%A8%A1%E5%9D%97%E6%8B%86%E5%88%86%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">9.16.</span> <span class="toc-text">将模块拆分为不同的文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88"><span class="toc-number">10.</span> <span class="toc-text">常见集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector"><span class="toc-number">10.1.</span> <span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-vector"><span class="toc-number">10.1.1.</span> <span class="toc-text">创建 vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">10.1.2.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-Vector"><span class="toc-number">10.1.3.</span> <span class="toc-text">删除 Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-Vector-%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">10.1.4.</span> <span class="toc-text">读取 Vector 中的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">10.1.5.</span> <span class="toc-text">引用借用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-Vector"><span class="toc-number">10.1.6.</span> <span class="toc-text">遍历 Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-Vector"><span class="toc-number">10.1.7.</span> <span class="toc-text">扩展 Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-enum-%E6%9D%A5%E4%BD%BF-Vec-%E5%AD%98%E5%82%A8%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.1.8.</span> <span class="toc-text">使用 enum 来使 Vec 存储多种数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BD%BF-Vec-%E5%AD%98%E5%82%A8%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.1.9.</span> <span class="toc-text">使用特征对象来使 Vec 存储多种数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86-X-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-From-Into-%E7%89%B9%E5%BE%81-%E6%88%90-Vec"><span class="toc-number">10.1.10.</span> <span class="toc-text">将 X 类型转换(From&#x2F;Into 特征)成 Vec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">10.1.11.</span> <span class="toc-text">切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F"><span class="toc-number">10.1.12.</span> <span class="toc-text">容量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">10.2.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.2.1.</span> <span class="toc-text">字符串是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.2.2.</span> <span class="toc-text">其它字符串类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E4%B8%8E-amp-str-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.2.3.</span> <span class="toc-text">String 与&amp;str 的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89"><span class="toc-number">10.2.4.</span> <span class="toc-text">字符串转义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-String"><span class="toc-number">10.2.5.</span> <span class="toc-text">创建一个新的 String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0-String"><span class="toc-number">10.2.6.</span> <span class="toc-text">更新 String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#push-str"><span class="toc-number">10.2.6.1.</span> <span class="toc-text">push_str()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push"><span class="toc-number">10.2.6.2.</span> <span class="toc-text">push()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.2.6.3.</span> <span class="toc-text">+连接字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#format"><span class="toc-number">10.2.6.4.</span> <span class="toc-text">format!</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AEString"><span class="toc-number">10.2.7.</span> <span class="toc-text">按索引的形式进行访问String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.2.8.</span> <span class="toc-text">字节字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82-%E6%A0%87%E9%87%8F%E5%80%BC-%E5%AD%97%E5%9E%8B%E7%B0%87"><span class="toc-number">10.2.9.</span> <span class="toc-text">字节,标量值,字型簇</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E5%89%B2-String"><span class="toc-number">10.2.10.</span> <span class="toc-text">切割 String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.2.11.</span> <span class="toc-text">遍历字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">10.3.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-HashMap"><span class="toc-number">10.3.1.</span> <span class="toc-text">创建 HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">10.3.2.</span> <span class="toc-text">HashMap 和所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-HashMap-%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">10.3.3.</span> <span class="toc-text">访问 HashMap 中的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0-HashMap"><span class="toc-number">10.3.4.</span> <span class="toc-text">更新 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="toc-number">10.3.4.1.</span> <span class="toc-text">覆盖一个值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8%E9%94%AE%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E5%80%BC%E6%97%B6%E6%8F%92%E5%85%A5"><span class="toc-number">10.3.4.2.</span> <span class="toc-text">只在键没有对应值时插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%97%A7%E5%80%BC%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="toc-number">10.3.4.3.</span> <span class="toc-text">根据旧值更新一个值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.4.4.</span> <span class="toc-text">哈希函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-key-%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">10.3.5.</span> <span class="toc-text">HashMap key 的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F-1"><span class="toc-number">10.3.6.</span> <span class="toc-text">容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">10.3.7.</span> <span class="toc-text">所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9-Hash-%E5%BA%93"><span class="toc-number">10.3.8.</span> <span class="toc-text">第三方 Hash 库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%8E-panic"><span class="toc-number">11.1.</span> <span class="toc-text">不可恢复的错误与 panic!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panic-%E2%80%98abort%E2%80%99"><span class="toc-number">11.1.1.</span> <span class="toc-text">panic &#x3D; ‘abort’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8-panic-%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9E%E6%BA%AF%E4%BF%A1%E6%81%AF%E6%9D%A5%E5%AE%9A%E4%BD%8D%E5%BC%95%E8%B5%B7%E9%97%AE%E9%A2%98%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">11.1.2.</span> <span class="toc-text">通过调用 panic!的函数的回溯信息来定位引起问题的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Result-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">11.2.</span> <span class="toc-text">Result 枚举与可恢复的错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">11.2.1.</span> <span class="toc-text">匹配不同的错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unwrap"><span class="toc-number">11.2.2.</span> <span class="toc-text">unwrap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expect"><span class="toc-number">11.2.3.</span> <span class="toc-text">expect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF"><span class="toc-number">11.3.</span> <span class="toc-text">传播错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%9F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">11.4.</span> <span class="toc-text">？运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%9F%E4%B8%8E-from-%E5%87%BD%E6%95%B0"><span class="toc-number">11.5.</span> <span class="toc-text">？与 from 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%9F%E4%B8%8E-main-%E5%87%BD%E6%95%B0"><span class="toc-number">11.6.</span> <span class="toc-text">？与 main 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%EF%BC%8Cand-then"><span class="toc-number">11.7.</span> <span class="toc-text">map，and_then</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6-panic"><span class="toc-number">11.8.</span> <span class="toc-text">何时 panic!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E5%8E%9F%E5%88%99"><span class="toc-number">11.8.1.</span> <span class="toc-text">总体原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">11.8.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="toc-number">11.8.3.</span> <span class="toc-text">创建自定义类型进行有效性验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-fn-main-%E4%B8%AD%E4%BD%BF%E7%94%A8-Result"><span class="toc-number">11.9.</span> <span class="toc-text">在 fn main 中使用 Result</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.1.</span> <span class="toc-text">函数中定义泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.2.</span> <span class="toc-text">结构体中定义泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.3.</span> <span class="toc-text">枚举中定义泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.4.</span> <span class="toc-text">方法定义中的泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.5.</span> <span class="toc-text">const 泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">12.6.</span> <span class="toc-text">泛型代码的性能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Trait%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%85%B1%E5%90%8C%E8%A1%8C%E4%B8%BA"><span class="toc-number">13.</span> <span class="toc-text">Trait：定义共同行为</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-trait"><span class="toc-number">13.1.</span> <span class="toc-text">定义一个 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0-trait"><span class="toc-number">13.2.</span> <span class="toc-text">在类型上实现 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-trait-%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">13.3.</span> <span class="toc-text">实现 trait 的约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.4.</span> <span class="toc-text">trait 中的函数的默认实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">13.5.</span> <span class="toc-text">trait 作为参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#impl-triat-%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">13.5.1.</span> <span class="toc-text">impl triat 语法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trait-bound-%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">13.5.2.</span> <span class="toc-text">trait bound 语法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA-traint-bound"><span class="toc-number">13.5.3.</span> <span class="toc-text">使用+指定多个 traint bound</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-where-%E7%AE%80%E5%8C%96-trait-bound"><span class="toc-number">13.5.4.</span> <span class="toc-text">使用 where 简化 trait bound</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AE%9E%E7%8E%B0%E4%BA%86-trait-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.6.</span> <span class="toc-text">返回实现了 trait 的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1-%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.7.</span> <span class="toc-text">特征对象,在数组中使用特征对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-dyn-%E5%92%8C-Box"><span class="toc-number">13.8.</span> <span class="toc-text">&amp;dyn 和 Box</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91-Static-and-Dynamic-dispatch"><span class="toc-number">13.9.</span> <span class="toc-text">静态分发和动态分发 Static and Dynamic dispatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-trait-bounds-%E6%9D%A5%E4%BF%AE%E5%A4%8D-largest-%E5%87%BD%E6%95%B0"><span class="toc-number">13.10.</span> <span class="toc-text">使用 trait bounds 来修复 largest 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-trait-bound-%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">13.11.</span> <span class="toc-text">使用 trait bound 有条件地实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Derive-%E5%AE%8F%E6%B4%BE%E7%94%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.12.</span> <span class="toc-text">Derive 宏派生实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">14.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%E5%99%A8"><span class="toc-number">14.1.</span> <span class="toc-text">借用检查器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">14.2.</span> <span class="toc-text">函数中的泛型生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">14.3.</span> <span class="toc-text">生命周期标注语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="toc-number">14.4.</span> <span class="toc-text">深入理解声明周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3"><span class="toc-number">14.5.</span> <span class="toc-text">结构体定义中的生命周期注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%9C%81%E7%95%A5"><span class="toc-number">14.6.</span> <span class="toc-text">生命周期的省略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="toc-number">14.7.</span> <span class="toc-text">方法定义中的生命周期标注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">14.8.</span> <span class="toc-text">静态生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E3%80%81trait-bounds-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">14.9.</span> <span class="toc-text">结合泛型类型参数、trait bounds 和生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">15.</span> <span class="toc-text">编写自动化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E5%89%96%E6%9E%90"><span class="toc-number">15.1.</span> <span class="toc-text">测试函数剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-number">15.1.1.</span> <span class="toc-text">编写测试函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">15.1.2.</span> <span class="toc-text">运行测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%A4%B1%E8%B4%A5"><span class="toc-number">15.1.3.</span> <span class="toc-text">测试失败</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%EF%BC%88Assert%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">断言（Assert）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-assert-%E5%AE%8F%E6%A3%80%E6%9F%A5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">15.2.1.</span> <span class="toc-text">使用 assert!宏检查测试结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-assert-eq-%E5%92%8C-assert-ne-%E5%AE%8F%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9B%B8%E7%AD%89"><span class="toc-number">15.2.2.</span> <span class="toc-text">使用 assert_eq! 和 assert_ne! 宏来测试相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">15.2.3.</span> <span class="toc-text">自定义错误信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">15.3.</span> <span class="toc-text">验证错误处理的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9-should-panic-%E6%9B%B4%E7%B2%BE%E7%A1%AE"><span class="toc-number">15.3.1.</span> <span class="toc-text">让 should_panic 更精确</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E4%BD%BF%E7%94%A8-Result"><span class="toc-number">15.4.</span> <span class="toc-text">在测试中使用 Result</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C"><span class="toc-number">15.5.</span> <span class="toc-text">控制测试运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">15.5.1.</span> <span class="toc-text">并行运行测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%94test-threads-%E5%8F%82%E6%95%B0"><span class="toc-number">15.5.1.1.</span> <span class="toc-text">—test-threads 参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA"><span class="toc-number">15.5.2.</span> <span class="toc-text">显式函数输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%90%8D%E7%A7%B0%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%9A%84%E5%AD%90%E9%9B%86"><span class="toc-number">15.5.3.</span> <span class="toc-text">按名称运行测试的子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%8D%95%E4%B8%AA%E6%B5%8B%E8%AF%95"><span class="toc-number">15.5.3.1.</span> <span class="toc-text">运行单个测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E6%B5%8B%E8%AF%95"><span class="toc-number">15.5.3.2.</span> <span class="toc-text">过滤运行多个测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">15.5.3.3.</span> <span class="toc-text">忽略某些测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%84%E7%BB%87"><span class="toc-number">15.6.</span> <span class="toc-text">测试组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">15.6.1.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E5%87%BD%E6%95%B0"><span class="toc-number">15.6.1.1.</span> <span class="toc-text">测试私有函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">15.6.2.</span> <span class="toc-text">集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tests-%E7%9B%AE%E5%BD%95"><span class="toc-number">15.6.2.1.</span> <span class="toc-text">tests 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%8C%87%E5%AE%9A%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">15.6.2.2.</span> <span class="toc-text">运行指定的集成测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%AD%90%E6%A8%A1%E5%9D%97"><span class="toc-number">15.6.2.3.</span> <span class="toc-text">集成测试中的子模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9-binary-crate-%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">15.6.2.4.</span> <span class="toc-text">针对 binary crate 的集成测试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-%E9%A1%B9%E7%9B%AE-%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">16.</span> <span class="toc-text">IO 项目:构建命令行程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">16.1.</span> <span class="toc-text">接收命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%85%B3%E6%B3%A8%E4%B8%8E%E5%88%86%E7%A6%BB"><span class="toc-number">16.2.</span> <span class="toc-text">二进制项目的关注与分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TDD-%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">16.3.</span> <span class="toc-text">TDD 测试驱动开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99-minigrep-%E4%BB%A3%E7%A0%81"><span class="toc-number">16.4.</span> <span class="toc-text">编写 minigrep 代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">17.</span> <span class="toc-text">函数式语言特性:迭代器和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">17.1.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">17.1.1.</span> <span class="toc-text">闭包的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">17.1.2.</span> <span class="toc-text">闭包的类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E9%97%AD%E5%8C%85"><span class="toc-number">17.1.3.</span> <span class="toc-text">泛型参数闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9-struct-%E6%8C%81%E6%9C%89%E9%97%AD%E5%8C%85"><span class="toc-number">17.1.3.1.</span> <span class="toc-text">如何让 struct 持有闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cacher-%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">17.1.3.2.</span> <span class="toc-text">Cacher 实现的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BC%9A%E6%8D%95%E8%8E%B7%E5%85%B6%E7%8E%AF%E5%A2%83"><span class="toc-number">17.1.4.</span> <span class="toc-text">闭包会捕获其环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BB%8E%E6%89%80%E5%9C%A8%E7%8E%AF%E5%A2%83%E6%8D%95%E8%8E%B7%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">17.1.4.1.</span> <span class="toc-text">闭包从所在环境捕获值的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#move-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">17.1.4.2.</span> <span class="toc-text">move 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">17.1.4.3.</span> <span class="toc-text">最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">17.2.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-trait"><span class="toc-number">17.2.1.</span> <span class="toc-text">Iterator trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.1.1.</span> <span class="toc-text">几个迭代方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%80%97%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.2.</span> <span class="toc-text">消耗迭代器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%85%B6%E5%AE%83%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.3.</span> <span class="toc-text">产生其它迭代器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83"><span class="toc-number">17.2.4.</span> <span class="toc-text">使用闭包捕获环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">17.2.5.</span> <span class="toc-text">创建自定义迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B-I-O-%E9%A1%B9%E7%9B%AE"><span class="toc-number">17.2.6.</span> <span class="toc-text">改进 I&#x2F;O 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B9%B6%E5%8E%BB%E6%8E%89-clone"><span class="toc-number">17.2.6.1.</span> <span class="toc-text">使用迭代器并去掉 clone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-env-args-%E8%BF%94%E5%9B%9E%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">17.2.6.2.</span> <span class="toc-text">直接使用 env::args 返回的迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83-%E5%BE%AA%E7%8E%AF-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">17.2.7.</span> <span class="toc-text">性能比较 循环&#x2F;迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cargo-%E5%92%8C-crates-io"><span class="toc-number">18.</span> <span class="toc-text">Cargo 和 crates.io</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA"><span class="toc-number">18.1.</span> <span class="toc-text">采用发布配置自定义构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-profile"><span class="toc-number">18.1.1.</span> <span class="toc-text">自定义 profile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">18.2.</span> <span class="toc-text">文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3"><span class="toc-number">18.2.1.</span> <span class="toc-text">生成文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3%E5%B9%B6%E6%B5%8F%E8%A7%88"><span class="toc-number">18.2.2.</span> <span class="toc-text">生成文档并浏览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AB%A0%E8%8A%82"><span class="toc-number">18.2.3.</span> <span class="toc-text">常用章节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E4%BD%9C%E4%B8%BA%E6%B5%8B%E8%AF%95"><span class="toc-number">18.2.4.</span> <span class="toc-text">文档注释作为测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%8C%85%E5%90%AB%E6%B3%A8%E9%87%8A%E7%9A%84%E9%A1%B9%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">18.2.5.</span> <span class="toc-text">为包含注释的项添加文档注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-pub-use-%E5%AF%BC%E5%87%BA%E6%96%B9%E4%BE%BF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%AC%E5%85%B1-API"><span class="toc-number">18.3.</span> <span class="toc-text">使用 pub use 导出方便使用的公共 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-Crate"><span class="toc-number">18.4.</span> <span class="toc-text">发布 Crate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%B7%B2%E5%AD%98%E5%9C%A8-crate-%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC"><span class="toc-number">18.5.</span> <span class="toc-text">发布已存在 crate 的新版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-cargo-yank-%E4%BB%8E-Crates-io-%E6%92%A4%E5%9B%9E%E7%89%88%E6%9C%AC"><span class="toc-number">18.6.</span> <span class="toc-text">使用 cargo yank 从 Crates.io 撤回版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%EF%BC%88Workspaces%EF%BC%89"><span class="toc-number">18.7.</span> <span class="toc-text">Cargo 工作空间（Workspaces）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><span class="toc-number">18.7.1.</span> <span class="toc-text">创建工作空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-CRATES-IO-%E5%AE%89%E8%A3%85%E4%BA%8C%E8%BF%9B%E5%88%B6-crate"><span class="toc-number">18.8.</span> <span class="toc-text">从 CRATES.IO 安装二进制 crate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cargo-install"><span class="toc-number">18.8.1.</span> <span class="toc-text">cargo install</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95-cargo"><span class="toc-number">18.9.</span> <span class="toc-text">使用自定义命令扩展 cargo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">19.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B6%E5%AE%83%E4%B8%8D%E5%90%8C"><span class="toc-number">19.1.</span> <span class="toc-text">引用和智能指针的其它不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box%E6%8C%87%E5%90%91%E5%A0%86%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">19.2.</span> <span class="toc-text">使用 Box指向堆上的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box-%E8%B5%8B%E8%83%BD%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.3.</span> <span class="toc-text">使用 Box 赋能递归类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cons-List"><span class="toc-number">19.4.</span> <span class="toc-text">Cons List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%9D%9E%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">19.5.</span> <span class="toc-text">计算非递归类型的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box%E7%BB%99%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">19.6.</span> <span class="toc-text">使用 Box给递归类型一个已知的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dref-Trait"><span class="toc-number">19.7.</span> <span class="toc-text">Dref Trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">19.8.</span> <span class="toc-text">解引用运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A-Box%E5%BD%93%E4%BD%9C%E5%BC%95%E7%94%A8"><span class="toc-number">19.9.</span> <span class="toc-text">把 Box当作引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">19.10.</span> <span class="toc-text">定义自己的智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0-Deref-trait-%E5%B0%86%E6%9F%90%E7%B1%BB%E5%9E%8B%E5%83%8F%E5%BC%95%E7%94%A8%E4%B8%80%E6%A0%B7%E5%A4%84%E7%90%86"><span class="toc-number">19.11.</span> <span class="toc-text">通过实现 Deref trait 将某类型像引用一样处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E5%BC%8F%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BD%AC%E5%8C%96%EF%BC%88Deref-Coercion%EF%BC%89"><span class="toc-number">19.12.</span> <span class="toc-text">函数和方法的隐式解引用转化（Deref Coercion）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">19.13.</span> <span class="toc-text">解引用与可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drop-Trait"><span class="toc-number">19.14.</span> <span class="toc-text">Drop Trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-std-mem-drop-%E6%9D%A5%E6%8F%90%E5%89%8D-drop-%E5%80%BC"><span class="toc-number">19.14.1.</span> <span class="toc-text">使用 std::mem::drop 来提前 drop 值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rc%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">19.15.</span> <span class="toc-text">Rc引用计数智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%8B%E9%9A%86-Rc%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">19.16.</span> <span class="toc-text">克隆 Rc会增加引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RefCell%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">19.17.</span> <span class="toc-text">RefCell和内部可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%EF%BC%88interior-mutability"><span class="toc-number">19.17.1.</span> <span class="toc-text">内部可变性（interior mutability)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefCell%E4%B8%8E-Box%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.17.2.</span> <span class="toc-text">RefCell与 Box的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%9F%A5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">19.17.3.</span> <span class="toc-text">借用规则在不同阶段进行检查的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-Box%EF%BC%8CRc%EF%BC%8CRefCell%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="toc-number">19.17.4.</span> <span class="toc-text">选择 Box，Rc，RefCell的依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%EF%BC%9A%E5%8F%AF%E5%8F%98%E7%9A%84%E5%80%9F%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%80%BC"><span class="toc-number">19.17.5.</span> <span class="toc-text">内部可变性：可变的借用一个不可变的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RefCell%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AE%B0%E5%BD%95%E5%80%9F%E7%94%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">19.17.6.</span> <span class="toc-text">使用 RefCell在运行时记录借用信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88-Rc-%E5%92%8C-RefCell-%E6%9D%A5%E6%8B%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%89%80%E6%9C%89%E8%80%85"><span class="toc-number">19.17.7.</span> <span class="toc-text">结合 Rc 和 RefCell 来拥有多个可变数据所有者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%8F%AF%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.18.</span> <span class="toc-text">其它可实现内部可变性的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">19.19.</span> <span class="toc-text">循环引用导致内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF%EF%BC%9A%E5%B0%86-Rc-%E5%8F%98%E4%B8%BA-Weak"><span class="toc-number">19.19.1.</span> <span class="toc-text">避免引用循环：将 Rc 变为 Weak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strong-VS-Weak"><span class="toc-number">19.19.2.</span> <span class="toc-text">Strong VS Weak</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%B8%A6%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84-Node"><span class="toc-number">19.19.2.1.</span> <span class="toc-text">创建树形数据结构：带有子节点的 Node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%BB%8E%E5%AD%90%E5%88%B0%E7%88%B6%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">19.19.2.2.</span> <span class="toc-text">增加从子到父的引用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91"><span class="toc-number">20.</span> <span class="toc-text">无畏并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">20.1.</span> <span class="toc-text">使用线程同时运行代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-spawn-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">20.2.</span> <span class="toc-text">通过 spawn 创建新线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-join-Handle-%E6%9D%A5%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%8C%E6%88%90"><span class="toc-number">20.3.</span> <span class="toc-text">通过 join Handle 来等待所有线程的完成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-move-%E9%97%AD%E5%8C%85"><span class="toc-number">20.4.</span> <span class="toc-text">使用 move 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9D%A5%E8%B7%A8%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">20.5.</span> <span class="toc-text">使用消息传递来跨线程传递数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-number">20.5.1.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Channel"><span class="toc-number">20.5.2.</span> <span class="toc-text">创建 Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E4%B8%8E%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="toc-number">20.5.3.</span> <span class="toc-text">信道与所有权转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%B9%B6%E8%A7%82%E5%AF%9F%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E7%AD%89%E5%BE%85"><span class="toc-number">20.5.4.</span> <span class="toc-text">发送多个值并观察接收者的等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%85%8B%E9%9A%86%E5%8F%91%E9%80%81%E8%80%85%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">20.5.5.</span> <span class="toc-text">通过克隆发送者来创建多个生产者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E5%B9%B6%E5%8F%91"><span class="toc-number">20.6.</span> <span class="toc-text">共享状态并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%99%A8%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE"><span class="toc-number">20.6.1.</span> <span class="toc-text">互斥器一次只允许一个线程访问数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutex-%E7%9A%84-API"><span class="toc-number">20.6.2.</span> <span class="toc-text">Mutex 的 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB-Mutex"><span class="toc-number">20.6.3.</span> <span class="toc-text">在线程间共享 Mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">20.6.4.</span> <span class="toc-text">多线程和多所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-Arc"><span class="toc-number">20.6.5.</span> <span class="toc-text">原子引用计数 Arc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefCell-Rc-%E4%B8%8E-Mutex-Arc-%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7"><span class="toc-number">20.6.6.</span> <span class="toc-text">RefCell&#x2F;Rc 与 Mutex&#x2F;Arc 的相似性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Sync-%E5%92%8C-Send-trait-%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91"><span class="toc-number">20.7.</span> <span class="toc-text">使用 Sync 和 Send trait 的可扩展并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Send-%E5%85%81%E8%AE%B8%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">20.7.1.</span> <span class="toc-text">通过 Send 允许在线程间转移所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sync-%E5%85%81%E8%AE%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE"><span class="toc-number">20.7.2.</span> <span class="toc-text">Sync 允许多线程访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0-Send-%E5%92%8C-Sync-%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">20.7.3.</span> <span class="toc-text">手动实现 Send 和 Sync 是不安全的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rust-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="toc-number">21.</span> <span class="toc-text">Rust 的面向对象特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">21.1.</span> <span class="toc-text">面向对象语言的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BE%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%80%BC%E5%BE%97-trait-%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.2.</span> <span class="toc-text">顾及不同类型值得 trait 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%80%9A%E7%94%A8%E8%A1%8C%E4%B8%BA%E7%9A%84-trait"><span class="toc-number">21.3.</span> <span class="toc-text">定义通用行为的 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait-%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91"><span class="toc-number">21.4.</span> <span class="toc-text">trait 对象执行动态分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait-%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">21.5.</span> <span class="toc-text">trait 对象需要类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">21.6.</span> <span class="toc-text">面向对象设计模式的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">22.</span> <span class="toc-text">模式与模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#match-%E7%9A%84-Arm"><span class="toc-number">22.1.</span> <span class="toc-text">match 的 Arm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6-if-let-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">22.2.</span> <span class="toc-text">条件 if let 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-let-%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">22.3.</span> <span class="toc-text">while let 条件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">22.4.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E8%AF%AD%E5%8F%A5"><span class="toc-number">22.5.</span> <span class="toc-text">let 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">22.6.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%A8%E9%A9%B3%E6%80%A7%EF%BC%9A%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E4%BC%9A%E6%97%A0%E6%B3%95%E5%8C%B9%E9%85%8D"><span class="toc-number">22.7.</span> <span class="toc-text">可辨驳性：模式是否会无法匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">22.8.</span> <span class="toc-text">匹配字面值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F"><span class="toc-number">22.9.</span> <span class="toc-text">匹配命名变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="toc-number">22.10.</span> <span class="toc-text">匹配一个可变引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">22.11.</span> <span class="toc-text">多重模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E6%9D%A5%E5%8C%B9%E9%85%8D%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E7%9A%84%E5%80%BC"><span class="toc-number">22.12.</span> <span class="toc-text">使用..&#x3D;来匹配某个范围的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E4%BB%A5%E5%88%86%E8%A7%A3%E5%80%BC"><span class="toc-number">22.13.</span> <span class="toc-text">解构以分解值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">22.13.1.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%85%83%E7%BB%84"><span class="toc-number">22.13.2.</span> <span class="toc-text">解构元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">22.13.3.</span> <span class="toc-text">解构结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">22.13.4.</span> <span class="toc-text">解构枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="toc-number">22.13.5.</span> <span class="toc-text">解构嵌套的结构体和枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%83%E7%BB%84"><span class="toc-number">22.13.6.</span> <span class="toc-text">解构结构体和元组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E5%BF%BD%E7%95%A5%E5%80%BC"><span class="toc-number">22.14.</span> <span class="toc-text">在模式中忽略值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E6%95%B4%E4%B8%AA%E5%80%BC"><span class="toc-number">22.14.1.</span> <span class="toc-text">_ 忽略整个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97-%E5%BF%BD%E7%95%A5%E5%80%BC%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">22.14.2.</span> <span class="toc-text">使用嵌套_忽略值的一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A5-%E5%BC%80%E5%A4%B4%E5%91%BD%E5%90%8D%E6%9D%A5%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">22.14.3.</span> <span class="toc-text">使用以_开头命名来忽略未使用的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E5%80%BC%E7%9A%84%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86"><span class="toc-number">22.14.4.</span> <span class="toc-text">..(忽略值的剩余部分)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-match-%E5%AE%88%E5%8D%AB%E6%9D%A5%E6%8F%90%E4%BE%9B%E9%A2%9D%E5%A4%96%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">22.15.</span> <span class="toc-text">使用 match 守卫来提供额外的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="toc-number">22.16.</span> <span class="toc-text">@绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsafe-Rust"><span class="toc-number">23.</span> <span class="toc-text">unsafe Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-%E8%B6%85%E8%83%BD%E5%8A%9B"><span class="toc-number">23.1.</span> <span class="toc-text">unsafe 超能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="toc-number">23.2.</span> <span class="toc-text">解引用原始指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-unsafe-%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95"><span class="toc-number">23.3.</span> <span class="toc-text">调用 unsafe 函数或方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-unsafe-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%8A%BD%E8%B1%A1"><span class="toc-number">23.4.</span> <span class="toc-text">创建 unsafe 代码的安全抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-extern-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">23.5.</span> <span class="toc-text">使用 extern 函数调用外部代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%85%B6%E5%AE%83%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8-Rust-%E5%87%BD%E6%95%B0"><span class="toc-number">23.6.</span> <span class="toc-text">从其它语言调用 Rust 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">23.7.</span> <span class="toc-text">访问或修改一个可变的静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%AE%89%E5%85%A8-trait"><span class="toc-number">23.8.</span> <span class="toc-text">实现不安全 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E4%BD%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">23.9.</span> <span class="toc-text">访问联合体中的字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">23.10.</span> <span class="toc-text">何时使用不安全的代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-trait"><span class="toc-number">24.</span> <span class="toc-text">高级 trait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-trait-%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%8D%A0%E4%BD%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">24.1.</span> <span class="toc-text">在 trait 定义中使用关联类型来指定占位类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">24.2.</span> <span class="toc-text">关联类型与泛型的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">24.3.</span> <span class="toc-text">默认泛型参数和运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">24.4.</span> <span class="toc-text">默认泛型参数的主要应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95-Fully-Qualified-Syntax"><span class="toc-number">24.5.</span> <span class="toc-text">完全限定语法(Fully Qualified Syntax)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-supertrait-%E6%9D%A5%E8%A6%81%E6%B1%82-trait-%E9%99%84%E5%B8%A6%E5%85%B6%E5%AE%83-trait-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">24.6.</span> <span class="toc-text">使用 supertrait 来要求 trait 附带其它 trait 的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-newtype-%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8-trait"><span class="toc-number">24.7.</span> <span class="toc-text">使用 newtype 模式在外部类型上实现外部 trait</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.</span> <span class="toc-text">高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-newtype-%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%8A%BD%E8%B1%A1"><span class="toc-number">25.1.</span> <span class="toc-text">使用 newtype 模式实现类型安全和抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%90%8C%E4%B9%89%E8%AF%8D"><span class="toc-number">25.2.</span> <span class="toc-text">适用类型别名创建类型同义词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#never-%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.3.</span> <span class="toc-text">never 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E5%92%8C-Sized-Trait"><span class="toc-number">25.4.</span> <span class="toc-text">动态大小和 Sized Trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rust-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">25.5.</span> <span class="toc-text">Rust 使用动态大小类型的通用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9Atrait"><span class="toc-number">25.6.</span> <span class="toc-text">另外一种动态大小的类型：trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sized-trait"><span class="toc-number">25.7.</span> <span class="toc-text">Sized trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sized-trait-%E7%BA%A6%E6%9D%9F"><span class="toc-number">25.8.</span> <span class="toc-text">?Sized trait 约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">26.</span> <span class="toc-text">高级函数和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">26.1.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">26.2.</span> <span class="toc-text">函数指针与闭包的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E9%97%AD%E5%8C%85"><span class="toc-number">26.3.</span> <span class="toc-text">返回闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">27.</span> <span class="toc-text">宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">28.</span> <span class="toc-text">格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">28.1.</span> <span class="toc-text">位置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">28.2.</span> <span class="toc-text">具名参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E9%BD%90"><span class="toc-number">28.3.</span> <span class="toc-text">字符串对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6"><span class="toc-number">28.4.</span> <span class="toc-text">精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%85%AB%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">28.5.</span> <span class="toc-text">二进制，八进制，十六进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">28.6.</span> <span class="toc-text">捕获环境中的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%EF%BC%8C%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%BD%AC%E4%B9%89"><span class="toc-number">28.7.</span> <span class="toc-text">指数，指针地址，转义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Other"><span class="toc-number">29.</span> <span class="toc-text">Other</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">29.1.</span> <span class="toc-text">1.错误处理：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unreachable"><span class="toc-number">29.1.1.</span> <span class="toc-text">unreachable!()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-misconception-corollaries"><span class="toc-number">29.2.</span> <span class="toc-text">2.misconception corollaries</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-if-T-39-static-then-T-must-be-valid-for-the-entire-program"><span class="toc-number">29.2.1.</span> <span class="toc-text">2.1 if T: &#39;static then T must be valid for the entire program</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1625/" title="leetcode每日一题 P1625 执行操作后字典序最小的字符串"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode每日一题 P1625 执行操作后字典序最小的字符串"/></a><div class="content"><a class="title" href="/posts/1625/" title="leetcode每日一题 P1625 执行操作后字典序最小的字符串">leetcode每日一题 P1625 执行操作后字典序最小的字符串</a><time datetime="2025-10-19T07:05:13.000Z" title="发表于 2025-10-19 15:05:13">2025-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3397/" title="leetcode每日一题 P3397 执行操作后不同元素的最大数量"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode每日一题 P3397 执行操作后不同元素的最大数量"/></a><div class="content"><a class="title" href="/posts/3397/" title="leetcode每日一题 P3397 执行操作后不同元素的最大数量">leetcode每日一题 P3397 执行操作后不同元素的最大数量</a><time datetime="2025-10-18T03:27:13.000Z" title="发表于 2025-10-18 11:27:13">2025-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2510160/" title="ARM Exception Model"><img src="/images/arm-chip.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM Exception Model"/></a><div class="content"><a class="title" href="/posts/2510160/" title="ARM Exception Model">ARM Exception Model</a><time datetime="2025-10-16T07:25:13.000Z" title="发表于 2025-10-16 15:25:13">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2598/" title="leetcode每日一题 P2598 执行操作后的最大 MEX"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode每日一题 P2598 执行操作后的最大 MEX"/></a><div class="content"><a class="title" href="/posts/2598/" title="leetcode每日一题 P2598 执行操作后的最大 MEX">leetcode每日一题 P2598 执行操作后的最大 MEX</a><time datetime="2025-10-16T06:05:13.000Z" title="发表于 2025-10-16 14:05:13">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/392/" title="面试经典150题 P392 判断子序列"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经典150题 P392 判断子序列"/></a><div class="content"><a class="title" href="/posts/392/" title="面试经典150题 P392 判断子序列">面试经典150题 P392 判断子序列</a><time datetime="2025-10-15T09:45:13.000Z" title="发表于 2025-10-15 17:45:13">2025-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3350/" title="leetcode每日一题 P3350 检测相邻递增子数组 II"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode每日一题 P3350 检测相邻递增子数组 II"/></a><div class="content"><a class="title" href="/posts/3350/" title="leetcode每日一题 P3350 检测相邻递增子数组 II">leetcode每日一题 P3350 检测相邻递增子数组 II</a><time datetime="2025-10-15T07:47:13.000Z" title="发表于 2025-10-15 15:47:13">2025-10-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a title="GitHub" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/even629"><i class="fab fa-regular fa-github"></i></a><a title="Mail" href="mailto:zhaohang731005515@proton.me" rel="external nofollow noreferrer"><i class="fas fa-regular fa-envelope"></i></a></div><div class="copyright">&copy;2014 - 2025 By even629</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();" rel="external nofollow noreferrer"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();" rel="external nofollow noreferrer"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '897cca6f8ae9ac216873b09aba803b0a'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code      
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'src'
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}"></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/even629/even629.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/pop-up-window.js"></script><script defer src="/js/light.js"></script><script src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('category-bar');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>