<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 输入子系统 | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux 输入子系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 输入子系统">
<meta property="og:url" content="https://even629.com/posts/2512183/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="Linux 输入子系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/linux_cover.webp">
<meta property="article:published_time" content="2025-12-18T12:31:13.000Z">
<meta property="article:modified_time" content="2025-12-18T12:31:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/linux_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/2512183/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 输入子系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.png', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom_card_author.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/newYear.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/beautify_label_h.css"><link rel="stylesheet" href="/css/equipment.css"><link rel="stylesheet" href="/css/liquid_glass.css"><link rel="stylesheet" href="/css/tag_plugin_plus.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="常想一二，不思八九" type="application/atom+xml">
</head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/linux_top_image.jpg);"><nav class="liquidGlass-wrapper" id="nav" style="--glass-border-radius: 2rem;"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box" style="display:flex;align-items:center;justify-content:center;width:100%"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" alt="Logo"></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 菜单项--><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><!-- 显示当前标题名称--><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">常想一二，不思八九</a></center></div></div><!-- 右侧功能区域（新增容器）--><div id="nav-right-container"><!-- 搜索按钮（移动到右侧）--><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><!-- 移动端汉堡菜单按钮--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux 输入子系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-18T12:31:13.000Z" title="发表于 2025-12-18 20:31:13">2025-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-18T12:31:13.000Z" title="更新于 2025-12-18 20:31:13">2025-12-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">27.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>109分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2512183/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-18</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>

<hr>
<h2 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h2><p>在 Linux 中，input 子系统是专门为处理输入类设备而设计的一个子系统或框架。它提供了一套通用的接口和机制，用于驱动开发人员编写和管理输入设备的驱动程序。输入设备包括键盘、鼠标、触摸屏、游戏手柄等。</p>
<p>使用 input 子系统的主要目的是规范和简化输入设备驱动的开发过程，以提高驱动的通用性和兼容性。它通过<strong>将输入设备的共同功能和处理逻辑提取出来，编写成通用的代码，将差异化的代码留给具体的设备驱动开发人员</strong>，这种分工合作的方式使得驱动开发人员可以更专注地处理设备特定的细节，从而大大降低工程师的开发难度。</p>
<p>综上使用 input 子系统的作用如下所示：</p>
<ul>
<li><strong>兼容性</strong>： 输入子系统提供了一个统一的框架和接口，使得不同厂家的输入设备都可以按照相同的规范进行驱动开发。无论是键盘、鼠标还是其他输入设备，只要符合输入子系统定义的接口和事件格式，都可以在 Linux 系统中正常工作。这样一来，工程师不需要针对每个厂家的设备编写和维护不同的驱动代码，大大提高了设备的兼容性。</li>
<li><strong>统一的驱动编程方式</strong>： 输入子系统定义了一套通用的驱动编程方式，工程师只需要按照输入子系统的规范进行开发即可。输入设备的驱动模块需要实现相应的接口函数，如初始化函数、事件处理函数等。这些接口函数的实现方式是相同的，不论是键盘驱动还是鼠标驱动，都可以按照统一的方式进行开发。这样一来，工程师可以更加专注于设备特定的细节，而无需关心通用的驱动框架，简化了开发过程。</li>
<li><strong>统一的应用操作接口</strong>： 输入子系统通过提供一组统一的应用操作接口，如<code>/dev/input/eventX</code>，使得应用程序可以方便地与输入设备进行交互。应用程序可以通过读取这些设备节点，获取输入事件的信息，并进行相应的处理。无论是哪种类型的输入设备，应用程<br>序都可以使用相同的方式进行访问和操作。这样一来，应用程序的开发人员不需要关心底层输入设备的细节，可以更加专注于应用程序的逻辑开发。</li>
</ul>
<h2 id="如何确定输入设备和节点之间的关系"><a href="#如何确定输入设备和节点之间的关系" class="headerlink" title="如何确定输入设备和节点之间的关系"></a>如何确定输入设备和节点之间的关系</h2><p>在输入子系统中，输入设备与设备节点之间有一定的对应关系。以下是判断设备节点与输入设备的方法：</p>
<ol>
<li><strong>设备名</strong>： 输入子系统的设备节点可以分为<strong>通用设备名</strong>和<strong>专用设备名</strong>。专用设备名通常可以从设备名中直接识别出设备类型，例如”keyboard”（键盘）或”mouse”（鼠标）。而通用设备名则不能直接确定设备类型。如下图所示，event0-event4 属于通用设备名，而 mouse0 和mouse2 属于专用设备名。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195155210.png" alt="&#x2F;dev&#x2F;input" loading="lazy"></p>
<ol start="2">
<li>试探性方法： 可以使用”cat”命令打开设备节点文件，然后对物理设备进行操作，观察终 端 是 否 有 输 出 。 例 如 ， 对 于 键 盘 设 备 ， 你 可 以 运 行 <code>cat /dev/input/eventX</code> ， 其 中<code>/dev/input/eventX</code>是设备节点的路径，然后按下键盘按键，观察终端是否输出相应的字符。通过这种试探性的方法，你可以判断设备节点与具体设备之间的对应关系。例如使用以下命令来测试鼠标，如下所示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /dev/input/mouse0</span><br><span class="line"><span class="built_in">sudo</span> hexdump /dev/input/mouse0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看输入设备信息：可以使用以下命令查看<code>/proc/bus/input/devices</code>文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/bus/input/devices</span><br></pre></td></tr></table></figure>


<p>部分打印截图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195158455.png" alt="&#x2F;proc&#x2F;bus&#x2F;input&#x2F;devices" loading="lazy"></p>
<p>该文件记录了当前系统的所有输入设备的信息在该文件中，你可以找到与设备节点相关的信息，例如设备名称、供应商 ID、产品 ID 等。通过对比设备节点的路径和设备信息中的对应字段，可以确定设备节点与特定输入设备之间的关系，例如可以通过上述打印信息查看到，<br>键盘对应的设备节点为<code>/dev/input/event1</code>，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195413467.png" alt="keyboard" loading="lazy"></p>
<ul>
<li><code>I: Bus=0011 Vendor=0001 Product=0001 Version=ab41</code></li>
</ul>
<p>这一行显示了设备的总线类型、供应商 ID、产品 ID 和固件版本。在这个例子中，该设备的总线类型为 0011，供应商 ID 为 0001，<br>产品 ID 为 0001，固件版本为 ab41。</p>
<ul>
<li><code>N: Name=&quot;AT Translated Set 2 keyboard&quot;</code></li>
</ul>
<p>这一行显示了设备的名称。在这个例子中，该设备的名称为”AT Translated Set 2 keyboard”。</p>
<ul>
<li><code>P: Phys=isa0060/serio0/input0</code></li>
</ul>
<p>这一行显示了设备的物理位置。在这个例子中，该设备的物理位置是 <code>isa0060/serio0/input0</code>。</p>
<ul>
<li><code>S: Sysfs=/devices/platform/i8042/serio0/input/input1</code></li>
</ul>
<p>这一行显示了设备在 sysfs 文件系统中的路径。在这个例子中，该设备的路径是<code>/devices/platform/i8042/serio0/input/input1</code>。</p>
<ul>
<li><code>U: Uniq=</code>:</li>
</ul>
<p>这一行显示了设备的唯一标识符。在这个例子中，唯一标识符为空。</p>
<ul>
<li><code>H: Handlers=sysrq kbd event1 leds</code></li>
</ul>
<p> 这一行显示了设备的处理程序。它指示了处理设备输入事件的程序或模块。在这个例子中，设备有 sysrq、kbd、event1 和 leds 这些处理程序，其中 event1就表示设备节点为<code>/dev/input/event1</code>。</p>
<ul>
<li><code>B: PROP=0</code></li>
</ul>
<p> 这一行显示了设备的属性。在这个例子中，设备的属性值为 0。</p>
<ul>
<li><code>B: EV=120013</code></li>
</ul>
<p>这一行显示了设备支持的事件类型。在这个例子中，设备支持 EV_SYN、EV_KEY、EV_MSC 和 EV_LED 这些事件类型。</p>
<ul>
<li><code>B: KEY=402000000 3803078f800d001 feffffdfffefffff fffffffffffffffe</code></li>
</ul>
<p>这一行显示了设备支持的按键。每个按键对应一个位，1 表示按键被按下，0 表示按键未被按下。该行显示了按键的状态，以 16 进制表示。</p>
<ul>
<li><code>B: MSC=10</code></li>
</ul>
<p>这一行显示了设备支持的杂项事件。在这个例子中，设备支持 MSC_SCAN事件。</p>
<ul>
<li><code>B: LED=7</code></li>
</ul>
<p>这一行显示了设备支持的 LED 灯。在这个例子中，设备支持 3 个 LED 灯，使用一个 7 位的二进制数表示灯的状态。</p>
<h2 id="输入子系统框架"><a href="#输入子系统框架" class="headerlink" title="输入子系统框架"></a>输入子系统框架</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195204498.png" alt="输入子系统框架" loading="lazy"></p>
<ul>
<li><strong>事件处理层（Event Handling Layer）</strong></li>
</ul>
<p>事件处理层是输入子系统的最上层，可以<strong>处理输入设备产生的事件并将其传递给上层应用程序</strong>，并<strong>在操作系统中创建设备节点</strong>，以便应用程序可以通过设备节点与输入设备进行通信。它接收来自核心层的输入事件，并根据事件的类型和属性进行相应的处理。</p>
<ul>
<li><p><strong>核心层（Core Layer）</strong></p>
<p>核心层的主要功能是<strong>作为匹配器位于事件处理层和设备驱动层之间</strong>。它起到协调和连接这两个层级的作用，以<strong>确保输入设备的事件能够正确地传递给相应的事件处理程序</strong>。以下是核心层在输入子系统中的主要功能：</p>
<ul>
<li><strong>事件匹配</strong>： 核心层负责<strong>将输入设备产生的原始输入数据与相应的事件处理程序进行匹配</strong>。它会解析原始输入数据，并根据预定义的规则和配置信息，确定应该将输入数据传递给哪个事件处理程序进行处理。</li>
<li><strong>设备管理和控制</strong>： 核心层负责<strong>维护输入设备的状态、属性和配置信息，并提供设备的注册、注销和管理功能</strong>。它与设备驱动层进行交互，接收来自设备驱动层的输入事件，并将其转化为抽象化的事件表示形式。核心层提供一致的接口，使得上层应用程序可以独立于具体的硬件设备进行操作。</li>
<li><strong>事件处理和分发</strong>： 核心层<strong>负责事件的处理和分发，将输入事件传递给对应的事件处理层</strong>。它通过事件队列的机制，接收和缓存来自设备驱动层的输入事件，并按照特定的规则将事件分发给对应的事件处理层或应用程序。这样，事件处理层可以通过核心层提供的接口，获取输入事件并进行相应的处理。</li>
<li><strong>抽象化接口和事件处理机制</strong>： 核心层<strong>为上层应用程序和事件处理层提供了一组抽象化的接口和事件处理机制</strong>。它提供了统一的事件表示形式，使得不同类型的输入设备（如键盘、鼠标、触摸屏等）的事件可以被表示和处理。通过核心层的接口，事件处理层可以注册事件监听器、订阅特定类型的事件，并获取输入设备的状态信息。</li>
</ul>
</li>
<li><p><strong>设备驱动层（Device Driver Layer）</strong></p>
</li>
</ul>
<p>设备驱动层是输入子系统的最底层，负责<strong>与硬件设备进行通信和交互</strong>。它的主要职责是将硬件设备的操作和功能抽象为统一的接口，以便核心层和事件处理层可以与之交互。设备驱动层的代码通常包括硬件的初始化、中断处理、数据传输等操作，以确保输入设备的正常工作。开发者在这一层编写驱动程序，以适配特定的硬件设备。</p>
<p>Linux 源码中已经写好了核心层相关的代码，所以在后续编写输入子系统驱动的时候，<strong>核心层的代码是不需要编写的</strong>，而事件处理层在 Linux 中也为我们提供了一个模板，除了一些例如固定设备节点的需求外，<strong>一般不需要编写事件处理层的代码</strong>，而设备驱动层由于要面对不同的硬件，每个硬件的初始化方式又都都不同，所以<strong>设备驱动层的代码在编写输入子系统驱动的时候是需要填充的</strong>。</p>
<h2 id="输入子系统数据结构"><a href="#输入子系统数据结构" class="headerlink" title="输入子系统数据结构"></a>输入子系统数据结构</h2><p>事件处理层的代码位于 <code>drivers/input/evdev.c</code> 文件中,为上层的应用程序提供了统一的事件处理机制。它定义了处理输入设备事件的函数，并提供了读取事件、控制设备等功能的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/evdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">	.event		= evdev_event, <span class="comment">// 事件处理函数指针，指向名为 evdev_event 的函数，用于处理输入事件</span></span><br><span class="line">	.events		= evdev_events,<span class="comment">// 批量事件处理函数指针，指向名为 evdev_events 的函数，用于处理输入设备的多个事件</span></span><br><span class="line">	.connect	= evdev_connect,</span><br><span class="line">	.disconnect	= evdev_disconnect,</span><br><span class="line">	.legacy_minors	= <span class="literal">true</span>,</span><br><span class="line">	.minor		= EVDEV_MINOR_BASE,</span><br><span class="line">	.name		= <span class="string">&quot;evdev&quot;</span>,<span class="comment">// 设备名称，设置为字符串 &quot;evdev&quot;</span></span><br><span class="line">	.id_table	= evdev_ids,<span class="comment">// 输入设备 ID 表，指向名为 evdev_ids 的表，用于匹配输入设备的 ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">evdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">evdev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	input_unregister_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(evdev_init);</span><br><span class="line">module_exit(evdev_exit);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>input_register_handler</code> 函数会将 <code>evdev handler</code> 添加到输入子系统的 <code>handler</code> 列表中，并分配一个唯一的 <code>handler</code> 编号：</p>
<h3 id="input-register-handler"><a href="#input-register-handler" class="headerlink" title="input_register_handler()"></a>input_register_handler()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_register_handler - register a new input handler</span></span><br><span class="line"><span class="comment"> * @handler: handler to be registered</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function registers a new input handler (interface) for input</span></span><br><span class="line"><span class="comment"> * devices in the system and attaches it to all input devices that</span></span><br><span class="line"><span class="comment"> * are compatible with the handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_register_handler</span><span class="params">(<span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="comment">// 尝试获取输入互斥锁，以确保在注册处理程序时不会被中断</span></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="comment">// 初始化处理程序链表头</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">	<span class="comment">// 将处理程序添加到全局处理程序链表的末尾，使其能够与输入子系统的其他组件进行交互</span></span><br><span class="line">	list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line">	<span class="comment">// 遍历输入设备链表，为每个设备附加处理程序，这样可以为每个输入设备建立与处理程序的连接，以便处理设备发送的输入事件</span></span><br><span class="line">	list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line">	<span class="comment">// 唤醒 procfs 读取器，通知其有新的处理程序注册，以便读取器可以及时获取新的输入事件信息。</span></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 释放输入互斥锁，以允许其他线程继续访问输入子系统</span></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="input-handler-结构体"><a href="#input-handler-结构体" class="headerlink" title="input_handler 结构体"></a>input_handler 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/input.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct input_handler - implements one of interfaces for input devices</span></span><br><span class="line"><span class="comment"> * @private: driver-specific data</span></span><br><span class="line"><span class="comment"> * @event: event handler. This method is being called by input core with</span></span><br><span class="line"><span class="comment"> *	interrupts disabled and dev-&gt;event_lock spinlock held and so</span></span><br><span class="line"><span class="comment"> *	it may not sleep</span></span><br><span class="line"><span class="comment"> * @events: event sequence handler. This method is being called by</span></span><br><span class="line"><span class="comment"> *	input core with interrupts disabled and dev-&gt;event_lock</span></span><br><span class="line"><span class="comment"> *	spinlock held and so it may not sleep</span></span><br><span class="line"><span class="comment"> * @filter: similar to @event; separates normal event handlers from</span></span><br><span class="line"><span class="comment"> *	&quot;filters&quot;.</span></span><br><span class="line"><span class="comment"> * @match: called after comparing device&#x27;s id with handler&#x27;s id_table</span></span><br><span class="line"><span class="comment"> *	to perform fine-grained matching between device and handler</span></span><br><span class="line"><span class="comment"> * @connect: called when attaching a handler to an input device</span></span><br><span class="line"><span class="comment"> * @disconnect: disconnects a handler from input device</span></span><br><span class="line"><span class="comment"> * @start: starts handler for given handle. This function is called by</span></span><br><span class="line"><span class="comment"> *	input core right after connect() method and also when a process</span></span><br><span class="line"><span class="comment"> *	that &quot;grabbed&quot; a device releases it</span></span><br><span class="line"><span class="comment"> * @legacy_minors: set to %true by drivers using legacy minor ranges</span></span><br><span class="line"><span class="comment"> * @minor: beginning of range of 32 legacy minors for devices this driver</span></span><br><span class="line"><span class="comment"> *	can provide</span></span><br><span class="line"><span class="comment"> * @name: name of the handler, to be shown in /proc/bus/input/handlers</span></span><br><span class="line"><span class="comment"> * @id_table: pointer to a table of input_device_ids this driver can</span></span><br><span class="line"><span class="comment"> *	handle</span></span><br><span class="line"><span class="comment"> * @h_list: list of input handles associated with the handler</span></span><br><span class="line"><span class="comment"> * @node: for placing the driver onto input_handler_list</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input handlers attach to input devices and create input handles. There</span></span><br><span class="line"><span class="comment"> * are likely several handlers attached to any given input device at the</span></span><br><span class="line"><span class="comment"> * same time. All of them will get their copy of input event generated by</span></span><br><span class="line"><span class="comment"> * the device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The very same structure is used to implement input filters. Input core</span></span><br><span class="line"><span class="comment"> * allows filters to run first and will not pass event to regular handlers</span></span><br><span class="line"><span class="comment"> * if any of the filters indicate that the event should be filtered (by</span></span><br><span class="line"><span class="comment"> * returning %true from their filter() method).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that input core serializes calls to connect() and disconnect()</span></span><br><span class="line"><span class="comment"> * methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *private;<span class="comment">// 私有数据指针，用于存储特定处理程序的私有数据</span></span><br><span class="line">	<span class="comment">// 事件处理函数指针，当输入事件发生时调用，参数包括输入句柄、事件类型、事件代码和事件值</span></span><br><span class="line">	<span class="type">void</span> (*event)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line">	<span class="comment">// 批量事件处理函数指针，当输入设备有多个事件同时发生时调用，参数包括输入句柄、事件值数组和事件数量</span></span><br><span class="line">    <span class="type">void</span> (*events)(<span class="keyword">struct</span> input_handle *handle,</span><br><span class="line">		       <span class="type">const</span> <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line">	<span class="comment">// 事件过滤函数指针，用于确定是否接收和处理特定类型和代码的事件，返回值为布尔类型，表示是否接受该事件</span></span><br><span class="line">    <span class="type">bool</span> (*filter)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line">	<span class="comment">// 匹配函数指针，用于确定处理程序是否适用于给定的输入设备，返回值为布尔类型，表示是否适用</span></span><br><span class="line">    <span class="type">bool</span> (*match)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev);</span><br><span class="line">	<span class="comment">// 连接函数指针，用于建立输入设备和处理程序之间的连接，返回值为整数类型，表示连接的结果</span></span><br><span class="line">    <span class="type">int</span> (*connect)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev, <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id);</span><br><span class="line">    <span class="comment">// 断开连接函数指针，用于断开输入设备和处理程序之间的连接</span></span><br><span class="line">	<span class="type">void</span> (*disconnect)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line">    <span class="comment">// 启动函数指针，用于启动输入设备的数据传输或处理过程</span></span><br><span class="line">	<span class="type">void</span> (*start)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> legacy_minors;<span class="comment">// 是否使用旧版次设备号</span></span><br><span class="line">	<span class="type">int</span> minor;<span class="comment">// 设备次设备号</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 设备名称</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">// 输入设备 ID 表</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">h_list</span>;</span><span class="comment">// 处理程序链表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">node</span>;</span><span class="comment">// 处理程序链表节点</span></span><br><span class="line"></span><br><span class="line">	ANDROID_KABI_RESERVE(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="input-attach-handler"><a href="#input-attach-handler" class="headerlink" title="input_attach_handler()"></a>input_attach_handler()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_attach_handler</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="comment">// 通过输入设备和处理程序的匹配函数来确定是否适用于该设备</span></span><br><span class="line">    <span class="comment">// 这个函数将在处理程序的输入设备 ID 表中查找与给定的输入设备匹配的 ID，</span></span><br><span class="line">    <span class="comment">// 并返回匹配的 ID。如果没有找到匹配的 ID，则返回 NULL</span></span><br><span class="line">	id = input_match_device(handler, dev);</span><br><span class="line">	<span class="keyword">if</span> (!id)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	<span class="comment">// 调用处理程序的连接函数来建立设备和处理程序之间的连接</span></span><br><span class="line">	error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">	<span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">		pr_err(<span class="string">&quot;failed to attach handler %s to device %s, error: %d\n&quot;</span>,</span><br><span class="line">		       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="input-match-device"><a href="#input-match-device" class="headerlink" title="input_match_device()"></a>input_match_device()</h3><p>这个函数在输入子系统中的作用是在给定的输入事件处理程序（<code>input_handler）</code>中查找与指定输入设备匹配的输入设备 ID（input device ID）。</p>
<p>处理程序的输入设备 ID 表是一个以 <code>struct input_device_id</code> 结构为元素的数组，每个元素表示一个可能的输入设备 ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> input_device_id *<span class="title function_">input_match_device</span><span class="params">(<span class="keyword">struct</span> input_handler *handler,</span></span><br><span class="line"><span class="params">							<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">	<span class="comment">// 遍历处理程序的输入设备 ID 表，直到找到匹配的 ID 或遍历完所有 ID 为止</span></span><br><span class="line">	<span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (input_match_device_id(dev, id) &amp;&amp;<span class="comment">// 使用输入设备 ID 匹配函数判断给定的输入设备是否与当前 ID 匹配</span></span><br><span class="line">		    (!handler-&gt;match || handler-&gt;match(handler, dev))) &#123;<span class="comment">// 如果输入设备与 ID 匹配，并且处理程序的匹配函数返回 true（或者没有匹配函数），则返回该 ID</span></span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="input-match-device-id"><a href="#input-match-device-id" class="headerlink" title="input_match_device_id()"></a>input_match_device_id()</h4><p><code>input_match_device_id(dev, id)</code>调用输入设备 ID 匹配函数来判断给定的输入设备是否与当前 ID 匹配。匹配函数的作用是比较输入设备的属性与 ID 中指定的属性是否一致，例如厂商 ID、产品 ID 等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">input_match_device_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">			   <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_match_device_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="input-dev-结构体"><a href="#input-dev-结构体" class="headerlink" title="input_dev 结构体"></a>input_dev 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input/linux/input.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 设备的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *phys;<span class="comment">// 设备的物理位置</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *uniq;<span class="comment">// 设备的唯一标识符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span><span class="comment">// 输入设备的标识信息</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];<span class="comment">// 设备的属性位图</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)];<span class="comment">// 设备支持的事件类型位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];<span class="comment">// 设备支持的按键位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)];<span class="comment">// 设备支持的相对坐标位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];<span class="comment">// 设备支持的绝对坐标位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];<span class="comment">// 设备支持的杂项事件位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];<span class="comment">// 设备支持的 LED 位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">// 设备支持的声音位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];<span class="comment">// 设备支持的力反馈位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)];<span class="comment">// 设备支持的开关位图</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hint_events_per_packet;<span class="comment">// 每个输入事件报告中的事件数量提示</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> keycodemax;<span class="comment">// 支持的按键编码的最大值</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> keycodesize;<span class="comment">// 按键编码的字节大小</span></span><br><span class="line">	<span class="type">void</span> *keycode;<span class="comment">// 按键编码数据的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*setkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">			  <span class="type">const</span> <span class="keyword">struct</span> input_keymap_entry *ke,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">int</span> *old_keycode);<span class="comment">// 设置按键编码的回调函数</span></span><br><span class="line">	<span class="type">int</span> (*getkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">			  <span class="keyword">struct</span> input_keymap_entry *ke);<span class="comment">// 获取按键编码的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span><span class="comment">// 力反馈设备</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev_poller</span> *<span class="title">poller</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> repeat_key;<span class="comment">// 重复按键的编码</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">// 定时器用于处理重复按键</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> rep[REP_CNT];<span class="comment">// 按键重复设置</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span>;</span><span class="comment">// 多点触摸信息</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span><span class="comment">// 绝对坐标信息</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> key[BITS_TO_LONGS(KEY_CNT)];<span class="comment">// 当前按键状态位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> led[BITS_TO_LONGS(LED_CNT)];<span class="comment">// 当前 LED 状态位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> snd[BITS_TO_LONGS(SND_CNT)];<span class="comment">// 当前声音状态位图</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sw[BITS_TO_LONGS(SW_CNT)];<span class="comment">// 当前开关状态位图</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*open)(<span class="keyword">struct</span> input_dev *dev);<span class="comment">// 打开设备的回调函数</span></span><br><span class="line">	<span class="type">void</span> (*close)(<span class="keyword">struct</span> input_dev *dev);<span class="comment">// 关闭设备的回调函数</span></span><br><span class="line">	<span class="type">int</span> (*flush)(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> file *file);<span class="comment">// 刷新设备的回调函数</span></span><br><span class="line">	<span class="type">int</span> (*event)(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);<span class="comment">// 处理输入事件的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span><span class="comment">// 设备的当前占用者</span></span><br><span class="line"></span><br><span class="line">	<span class="type">spinlock_t</span> event_lock;<span class="comment">// 事件锁，用于保护事件队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">// 互斥锁，用于保护设备状态</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> users;<span class="comment">// 设备的使用者数量</span></span><br><span class="line">	<span class="type">bool</span> going_away;<span class="comment">// 设备是否即将被移除</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">// 设备结构体</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">h_list</span>;</span><span class="comment">// 用于设备管理的链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">node</span>;</span><span class="comment">// 用于设备管理的链表</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_vals;<span class="comment">// 输入值的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_vals;<span class="comment">// 最大输入值的数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">vals</span>;</span><span class="comment">// 输入值的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> devres_managed;<span class="comment">// 是否由设备资源管理</span></span><br><span class="line"></span><br><span class="line">	<span class="type">ktime_t</span> timestamp[INPUT_CLK_MAX];<span class="comment">// 输入事件的时间戳数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_input_dev(d) container_of(d, struct input_dev, dev)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="input-handle-结构体"><a href="#input-handle-结构体" class="headerlink" title="input_handle 结构体"></a>input_handle 结构体</h3><p>在调用 connect 函数（evdev的connect函数）之后，会创建一个 <code>input_handle</code> 结构体，用于记录匹配成功的输入处理程序（<code>input_handler</code>）和输入设备（<code>input_dev</code>），并建立它们之间的关系。下面是 <code>input_handle</code> 结构体的定义（位于 <code>include/linux/input.h</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct input_handle - links input device with an input handler</span></span><br><span class="line"><span class="comment"> * @private: handler-specific data</span></span><br><span class="line"><span class="comment"> * @open: counter showing whether the handle is &#x27;open&#x27;, i.e. should deliver</span></span><br><span class="line"><span class="comment"> *	events from its device</span></span><br><span class="line"><span class="comment"> * @name: name given to the handle by handler that created it</span></span><br><span class="line"><span class="comment"> * @dev: input device the handle is attached to</span></span><br><span class="line"><span class="comment"> * @handler: handler that works with the device through this handle</span></span><br><span class="line"><span class="comment"> * @d_node: used to put the handle on device&#x27;s list of attached handles</span></span><br><span class="line"><span class="comment"> * @h_node: used to put the handle on handler&#x27;s list of handles from which</span></span><br><span class="line"><span class="comment"> *	it gets events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *private;<span class="comment">// 私有数据指针</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> open;<span class="comment">// 打开计数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 名称</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span><span class="comment">// 输入设备</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span><span class="comment">// 输入处理程序</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">d_node</span>;</span><span class="comment">// 指向输入设备链表的节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">h_node</span>;</span><span class="comment">// 指向输入处理程序链表的节点</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="evdev-connect"><a href="#evdev-connect" class="headerlink" title="evdev_connect()"></a>evdev_connect()</h3><p><code>input_handler</code>的connect函数</p>
<p>该函数的主要功能是建立与输入设备的连接，初始化并注册输入句柄，设置设备属性，并添加字符设备到系统中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> open;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span> client_lock; <span class="comment">/* protects client_list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">bool</span> exist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span></span><br><span class="line">	<span class="type">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">input_clock_type</span> <span class="title">clk_type</span>;</span></span><br><span class="line">	<span class="type">bool</span> revoked;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *evmasks[EV_CNT];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bufsize;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create new evdev device. Note that input core serializes calls</span></span><br><span class="line"><span class="comment"> * to connect and disconnect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_connect</span><span class="params">(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">	<span class="type">int</span> minor;</span><br><span class="line">	<span class="type">int</span> dev_no;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="comment">// 获取一个新的次设备号</span></span><br><span class="line">	minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (minor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		error = minor;</span><br><span class="line">		pr_err(<span class="string">&quot;failed to reserve new minor: %d\n&quot;</span>, error);</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 分配并初始化 evdev 结构体</span></span><br><span class="line">	evdev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> evdev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!evdev) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_free_minor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化 evdev 结构体中的成员</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;evdev-&gt;client_list);<span class="comment">// 初始化客户端链表</span></span><br><span class="line">	spin_lock_init(&amp;evdev-&gt;client_lock);<span class="comment">// 初始化客户端链表的自旋锁</span></span><br><span class="line">	mutex_init(&amp;evdev-&gt;mutex);<span class="comment">// 初始化互斥锁</span></span><br><span class="line">	evdev-&gt;exist = <span class="literal">true</span>;<span class="comment">// 设置 evdev 存在标志为 true</span></span><br><span class="line"></span><br><span class="line">	dev_no = minor;</span><br><span class="line">	<span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)<span class="comment">// 如果设备号在旧版范围内，则进行标准化处理</span></span><br><span class="line">		dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">	dev_set_name(&amp;evdev-&gt;dev, <span class="string">&quot;event%d&quot;</span>, dev_no);<span class="comment">// 设置设备名称</span></span><br><span class="line"></span><br><span class="line">	evdev-&gt;handle.dev = input_get_device(dev);<span class="comment">// 设置输入句柄的输入设备</span></span><br><span class="line">	evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);<span class="comment">// 设置输入句柄的名称为设备名称</span></span><br><span class="line">	evdev-&gt;handle.handler = handler;<span class="comment">// 设置输入句柄的处理程序为传入的处理程序</span></span><br><span class="line">	evdev-&gt;handle.private = evdev;<span class="comment">//  设置输入句柄的私有数据指针为 evdev 结构体的指针</span></span><br><span class="line"></span><br><span class="line">	evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);<span class="comment">// 设置设备号</span></span><br><span class="line">	evdev-&gt;dev.class = &amp;input_class;<span class="comment">// 设置设备的类</span></span><br><span class="line">	evdev-&gt;dev.parent = &amp;dev-&gt;dev;<span class="comment">// 设置设备的父设备</span></span><br><span class="line">	evdev-&gt;dev.release = evdev_free;<span class="comment">// 设置设备的释放函数为 evdev_free</span></span><br><span class="line">	device_initialize(&amp;evdev-&gt;dev);<span class="comment">// 初始化设备</span></span><br><span class="line"></span><br><span class="line">	error = input_register_handle(&amp;evdev-&gt;handle);<span class="comment">// 注册输入句柄</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_free_evdev;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);<span class="comment">// 初始化字符设备结构体</span></span><br><span class="line"></span><br><span class="line">	error = cdev_device_add(&amp;evdev-&gt;cdev, &amp;evdev-&gt;dev);<span class="comment">// 添加字符设备</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">	evdev_cleanup(evdev);<span class="comment">// 清理 evdev 结构体</span></span><br><span class="line">	input_unregister_handle(&amp;evdev-&gt;handle);<span class="comment">// 取消注册输入句柄</span></span><br><span class="line"> err_free_evdev:</span><br><span class="line">	put_device(&amp;evdev-&gt;dev);<span class="comment">// 释放设备</span></span><br><span class="line"> err_free_minor:</span><br><span class="line">	input_free_minor(minor);<span class="comment">// 释放次设备号</span></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="input-register-handle"><a href="#input-register-handle" class="headerlink" title="input_register_handle()"></a>input_register_handle()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_register_handle - register a new input handle</span></span><br><span class="line"><span class="comment"> * @handle: handle to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function puts a new input handle onto device&#x27;s</span></span><br><span class="line"><span class="comment"> * and handler&#x27;s lists so that events can flow through</span></span><br><span class="line"><span class="comment"> * it once it is opened using input_open_device().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is supposed to be called from handler&#x27;s</span></span><br><span class="line"><span class="comment"> * connect() method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_register_handle</span><span class="params">(<span class="keyword">struct</span> input_handle *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> =</span> handle-&gt;handler;<span class="comment">// 获取输入处理程序</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> handle-&gt;dev;<span class="comment">// 获取输入设备</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We take dev-&gt;mutex here to prevent race with</span></span><br><span class="line"><span class="comment">	 * input_release_device().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 在这里获取 dev-&gt;mutex 锁，以防止与 input_release_device() 的竞争。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Filters go to the head of the list, normal handlers</span></span><br><span class="line"><span class="comment">	 * to the tail.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 将过滤器添加到链表头部，普通处理程序添加到链表尾部。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">		list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we are supposed to be called from -&gt;connect()</span></span><br><span class="line"><span class="comment">	 * which is mutually exclusive with -&gt;disconnect()</span></span><br><span class="line"><span class="comment">	 * we can&#x27;t be racing with input_unregister_handle()</span></span><br><span class="line"><span class="comment">	 * and so separate lock is not needed here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 由于我们假设被从 -&gt;connect() 调用，这与 -&gt;disconnect() 是互斥的，</span></span><br><span class="line"><span class="comment">	* 所以我们不能与 input_unregister_handle() 竞争，因此此处不需要额外的锁定。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">		handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handle);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数的主要作用是将输入处理程序（<code>input_handler</code>）和输入设备（<code>input_dev</code>）建立关联。对于输入设备来说，可以通过遍历 <code>handler-&gt;h_list</code> 链表来查找与之匹配的输入处理程序。这意味着输入设备可以通过遍历与之相关联的输入处理程序链表来找到相应的处理程序。</p>
<p>对于输入处理程序来说，可以通过遍历 <code>dev-&gt;h_list</code> 链表来查找与之匹配的输入设备。这意味着输入处理程序可以通过遍历与之相关联的输入设备链表来找到相应的设备。这样，通过建立输入处理程序和输入设备之间的关联关系，可以实现输入处理程序对特定输入设备的处理和控制。</p>
<h3 id="input-register-device"><a href="#input-register-device" class="headerlink" title="input_register_device()"></a>input_register_device()</h3><p><code>input_handler</code> 结构体要使用 <code>input_register_handler</code> 来注册;</p>
<p>输入处理程序（<code>input_handler</code>）和输入设备（<code>input_dev</code>）链接的结构体 <code>input_handle</code> 也需要 <code>input_register_handle</code> 函数来注册</p>
<p>输入设备 <code>input_dev</code> 结构体肯定也需要一个函数来注册，<code>input_dev</code> 结构体的注册函数为<code>input_register_device</code>，定义在 <code>drivers/input/input.c</code> 文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> =</span> <span class="literal">NULL</span>;<span class="comment">// 输入设备资源结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span><span class="comment">// 输入处理程序指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> packet_size;<span class="comment">// 数据包大小</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path;<span class="comment">// 设备路径字符串指针</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit) &amp;&amp; !dev-&gt;absinfo) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev,</span><br><span class="line">			<span class="string">&quot;Absolute device without dev-&gt;absinfo, refusing to register\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;<span class="comment">// 如果设备资源是由管理的，则分配设备资源结构体</span></span><br><span class="line">		devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">				      <span class="keyword">sizeof</span>(*devres), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!devres)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		devres-&gt;input = dev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    <span class="comment">/* 每个输入设备都会产生 EV_SYN/SYN_REPORT 事件。 */</span></span><br><span class="line">	__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    <span class="comment">/* KEY_RESERVED 不应传递给用户空间。 */</span></span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    <span class="comment">/* 确保未在 dev-&gt;evbit 中提及的位掩码是干净的。 */</span></span><br><span class="line">	input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">	packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">		dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">	dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">	dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;vals) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_devres_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment">	 * is handled by the driver itself and we don&#x27;t do it in input.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 如果延迟和周期由驱动程序预设，</span></span><br><span class="line"><span class="comment">    * 则自动重复由驱动程序自己处理，我们不在 input.c 中处理。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span><br><span class="line">		input_enable_softrepeat(dev, <span class="number">250</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">		dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">		dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;poller)</span><br><span class="line">		input_dev_poller_finalize(dev-&gt;poller);</span><br><span class="line"></span><br><span class="line">	error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_free_vals;</span><br><span class="line"></span><br><span class="line">	path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">	pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">		dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">		path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">	kfree(path);</span><br><span class="line"></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_device_del;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line">	<span class="comment">// 遍历输入处理程序链表，将输入设备与每个处理程序建立关联</span></span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">		dev_dbg(dev-&gt;dev.parent, <span class="string">&quot;%s: registering %s with devres.\n&quot;</span>,</span><br><span class="line">			__func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">		devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_del:</span><br><span class="line">	device_del(&amp;dev-&gt;dev);</span><br><span class="line">err_free_vals:</span><br><span class="line">	kfree(dev-&gt;vals);</span><br><span class="line">	dev-&gt;vals = <span class="literal">NULL</span>;</span><br><span class="line">err_devres_free:</span><br><span class="line">	devres_free(devres);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>input_register_device</code> 函数用于注册输入设备（<code>input_dev</code>），将输入设备添加到输入子系统中</p>
<h3 id="数据结构关系图"><a href="#数据结构关系图" class="headerlink" title="数据结构关系图"></a>数据结构关系图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195215642.png" alt="输入子系统数据结构图关系图" loading="lazy"></p>
<h2 id="输入子系统源码"><a href="#输入子系统源码" class="headerlink" title="输入子系统源码"></a>输入子系统源码</h2><p>路径：<code>kernel/drivers/input</code></p>
<table>
<thead>
<tr>
<th>文件&#x2F;目录</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>apm-power.c</code></td>
<td>提供与 Advanced Power Management (APM) 相关的输入设备接口。</td>
</tr>
<tr>
<td><code>evbug.c</code></td>
<td>提供用于调试的虚拟输入设备，可以模拟按键、鼠标移动等事件。</td>
</tr>
<tr>
<td><code>evdev.c</code></td>
<td>提供通用的输入事件层，将所有输入设备的事件转化为标准化的输入事件格式，并提供给上层用户空间程序使用。</td>
</tr>
<tr>
<td><code>ff-core.c</code></td>
<td>提供力反馈设备的支持，允许输入设备发送力反馈信息。</td>
</tr>
<tr>
<td><code>ff-memless.c</code></td>
<td>提供一种无需分配内存的力反馈设备支持，适用于资源受限的嵌入式系统。</td>
</tr>
<tr>
<td><code>gameport/</code></td>
<td>包含支持游戏控制器的驱动程序的目录。</td>
</tr>
<tr>
<td><code>input.c</code></td>
<td>提供输入子系统的初始化和事件处理等操作。</td>
</tr>
<tr>
<td><code>input-leds.c</code></td>
<td>提供 LED 指示灯设备的支持，允许控制 LED 指示灯的状态。</td>
</tr>
<tr>
<td><code>joydev.c</code></td>
<td>提供支持游戏杆的驱动程序，处理游戏杆设备的输入事件。</td>
</tr>
<tr>
<td><code>keyboard/</code></td>
<td>包含支持键盘的驱动程序的目录。</td>
</tr>
<tr>
<td><code>misc/</code></td>
<td>包含其他类型输入设备的驱动程序的目录，如红外线遥控器、输入音频等。</td>
</tr>
<tr>
<td><code>remotectl/</code></td>
<td>提供支持远程控制的驱动程序，处理通过遥控器发送的输入事件。</td>
</tr>
<tr>
<td><code>serio/</code></td>
<td>提供支持通过串行端口接入的输入设备的驱动程序，处理串行输入设备的通信和处理。</td>
</tr>
<tr>
<td><code>sensors/</code></td>
<td>包含与传感器相关的驱动程序的目录，用于与各种传感器设备通信和处理。</td>
</tr>
<tr>
<td><code>sparse-keymap.c</code></td>
<td>提供稀疏键映射的支持，允许按任意键码分配键位，适用于具有非标准键盘布局或特殊功能键的设备。</td>
</tr>
<tr>
<td><code>tablet/</code></td>
<td>提供支持绘图板和其他类型图形输入设备的驱动程序，处理绘图板设备的输入事件。</td>
</tr>
<tr>
<td><code>touchscreen/</code></td>
<td>提供支持触摸屏的驱动程序，处理触摸屏设备的输入事件。</td>
</tr>
</tbody></table>
<p>在menuconfig中：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Device</span> <span class="type">Drivers</span> <span class="comment">---&gt;</span></span><br><span class="line">	<span class="type">Input</span> device sup<span class="keyword">port</span> <span class="comment">---&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-*- <span class="type">Generic</span> input layer (needed for keyboard, mouse, ...)//input 核心层</span><br><span class="line">│ │   &lt;*&gt;   <span class="type">Export</span> input device <span class="type">LEDs</span> <span class="keyword">in</span> sysfs</span><br><span class="line">│ │   &lt;*&gt;   <span class="type">Support</span> for memoryless force-feedback devices</span><br><span class="line">│ │   -*-   <span class="type">Polled</span> input device skeleton</span><br><span class="line">│ │   &lt; &gt;   <span class="type">Sparse</span> keymap sup<span class="keyword">port</span> library</span><br><span class="line">│ │   -*-   <span class="type">Matrix</span> keymap sup<span class="keyword">port</span> library</span><br><span class="line">│ │</span><br><span class="line">	*** <span class="type">Userland</span> interfaces ***</span><br><span class="line">│ │  &lt; &gt;     <span class="type">Mouse</span> interface</span><br><span class="line">│ │  &lt; &gt;     <span class="type">Joystick</span> interface</span><br><span class="line">│ │  &lt;*&gt;     <span class="type">Event</span> interface</span><br><span class="line">│ │  &lt; &gt;     <span class="type">Event</span> debugging</span><br><span class="line">│ │</span><br><span class="line">	*** <span class="type">Input</span> <span class="type">Device</span> <span class="type">Drivers</span> ***</span><br><span class="line">│ │  [*]   <span class="type">Keyboards</span>  <span class="comment">---&gt;</span></span><br><span class="line">│ │  [*]   <span class="type">Mice</span>  <span class="comment">---&gt;</span></span><br><span class="line">│ │  [ ]   <span class="type">Joysticks</span>/<span class="type">Gamepads</span>  <span class="comment">----</span></span><br><span class="line">│ │  [ ]   <span class="type">Tablets</span>  <span class="comment">----</span></span><br><span class="line">│ │  [*]   <span class="type">Touchscreens</span>  <span class="comment">---&gt;</span></span><br><span class="line">│ │  &lt;*&gt;   rockchip remotectl  <span class="comment">---&gt;</span></span><br><span class="line">│ │</span><br><span class="line">	*** handle all sensors ***</span><br><span class="line">│ │  &lt; &gt;     handle angle,accel,compass,gyroscope,lsensor psensor etc</span><br><span class="line">│ │  [*]   <span class="type">Miscellaneous</span> devices  <span class="comment">---&gt;</span></span><br><span class="line">│ │  &lt; &gt;     <span class="type">Synaptics</span> <span class="type">RMI4</span> bus sup<span class="keyword">port</span></span><br><span class="line">│ │</span><br><span class="line">│ │     <span class="type">Hardware</span> <span class="type">I</span>/<span class="type">O</span> ports  <span class="comment">---&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想要对内核裁剪和配置，只需要勾选和取消即可。</p>
<h2 id="编写最简单的设备驱动层代码"><a href="#编写最简单的设备驱动层代码" class="headerlink" title="编写最简单的设备驱动层代码"></a>编写最简单的设备驱动层代码</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>步骤一：<strong>创建输入设备结构体变量</strong> 在设备驱动的开发中，首先需要创建一个输入设备的结 构 体 变 量 ， 该 结 构 体 变 量 将 用 于 表 示 和 管 理 设 备 的 属 性 和 状 态 。 可 以 使 用<code>input_allocate_device</code> 函数来分配输入设备结构体的内存。</li>
<li>步骤二：<strong>初始化输入设备结构体变量</strong> 在创建输入设备结构体变量后，需要对其进行初始化。这包括设置设备的名称、支持的事件类型、事件处理函数等。可以使用结构体提供的成员变量和函数来完成初始化过程。</li>
<li>步骤三：<strong>注册输入设备结构体变量</strong> 在初始化输入设备结构体变量后，需要将其注册到系统中，以便系统能够正确地识别和使用该设备。可以使用 input_register_device 函数来注册输入设备结构体变量。在注册过程中，系统将完成设备的匹配和初始化工作。</li>
<li>步骤四：<strong>上报事件</strong> 一旦设备注册成功，就可以通过输入设备结构体变量上报事件。这可以通过调用输入设备结构体提供的函数来完成，例如 input_event 函数。根据设备类型和事件类型，可以生成相应的输入事件，并通过调用该函数将事件发送给系统。</li>
<li>步骤五：<strong>注销和释放输入设备结构体变量</strong> 当设备不再需要使用时，应该进行注销和释放操作，以确保资源的正确释放。可以使用 <code>input_unregister_device</code> 函数来注销输入设备结构体变量，并使用 <code>input_free_device</code> 函数来释放相关资源和内存。</li>
</ol>
<h3 id="input-allocate-device"><a href="#input-allocate-device" class="headerlink" title="input_allocate_device()"></a>input_allocate_device()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_allocate_device - allocate memory for new input device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns prepared struct input_dev or %NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Use input_free_device() to free devices that have not been</span></span><br><span class="line"><span class="comment"> * registered; input_unregister_device() should be used for already</span></span><br><span class="line"><span class="comment"> * registered devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> input_dev *<span class="title function_">input_allocate_device</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">atomic_t</span> input_no = ATOMIC_INIT(<span class="number">-1</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="comment">// 分配输入设备结构体的内存</span></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        <span class="comment">// 设置设备类型和设备类</span></span><br><span class="line">		dev-&gt;dev.type = &amp;input_dev_type;</span><br><span class="line">		dev-&gt;dev.class = &amp;input_class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化设备</span></span><br><span class="line">		device_initialize(&amp;dev-&gt;dev);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化互斥锁和事件自旋锁</span></span><br><span class="line">		mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">		spin_lock_init(&amp;dev-&gt;event_lock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化定时器</span></span><br><span class="line">		timer_setup(&amp;dev-&gt;timer, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化链表头</span></span><br><span class="line">		INIT_LIST_HEAD(&amp;dev-&gt;h_list);</span><br><span class="line">		INIT_LIST_HEAD(&amp;dev-&gt;node);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 设置设备名称，使用原子变量递增来保证唯一性</span></span><br><span class="line">		dev_set_name(&amp;dev-&gt;dev, <span class="string">&quot;input%lu&quot;</span>,</span><br><span class="line">			     (<span class="type">unsigned</span> <span class="type">long</span>)atomic_inc_return(&amp;input_no));</span><br><span class="line">		<span class="comment">// 增加模块引用计数</span></span><br><span class="line">		__module_get(THIS_MODULE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_allocate_device);</span><br></pre></td></tr></table></figure>

<h3 id="初始化input-dev结构体"><a href="#初始化input-dev结构体" class="headerlink" title="初始化input_dev结构体"></a>初始化input_dev结构体</h3><p>在使用 <code>input_allocate_device</code> 函数创建了一个 <code>input_dev</code> 结构体之后，接下来就要初始化<code>input_dev</code> 结构体内容了，在该步骤中又有两个内容，分别为<strong>设置事件类型</strong>和<strong>设置具体类型</strong>。</p>
<h4 id="设置事件类型"><a href="#设置事件类型" class="headerlink" title="设置事件类型"></a>设置事件类型</h4><p>在头文件 <code>include/uapi/linux/input-event-codes.h</code> 中，Linux 内核已经为我们定义了一些输入事件类型，它们的含义如下：</p>
<ul>
<li>EV_SYN (0x00): 用于<strong>同步事件</strong>，表示一组输入事件的结束。</li>
<li>EV_KEY (0x01): 用于<strong>按键事件</strong>，表示按下、释放或重复一个键。</li>
<li>EV_REL (0x02): 用于<strong>相对位移事件</strong>，表示设备的相对位置变化，例如鼠标的移动。</li>
<li>EV_ABS (0x03): 用于<strong>绝对位移事件</strong>，表示设备的绝对位置变化，例如触摸屏的坐标。</li>
<li>EV_MSC (0x04): 用于<strong>杂项事件</strong>，包含一些特殊目的的事件类型，例如设备状态变化等。</li>
<li>EV_SW (0x05): 用于<strong>开关事件</strong>，表示开关的状态变化，例如电源按钮、开合盖等。</li>
<li>EV_LED (0x11): 用于 <strong>LED 事件</strong>，表示 LED 灯的状态变化。</li>
<li>EV_SND (0x12): 用于<strong>声音事件</strong>，表示声音的播放相关事件。</li>
<li>EV_REP (0x14): 用于<strong>重复事件</strong>，表示键盘重复发送事件。</li>
<li>EV_FF (0x15): 用于<strong>力反馈事件</strong>，表示力反馈设备的输出事件。</li>
<li>EV_PWR (0x16): 用于<strong>电源事件</strong>，表示电源状态变化。</li>
<li>EV_FF_STATUS (0x17): 用于<strong>力反馈状态事件</strong>，表示力反馈设备的状态变化。</li>
<li>EV_MAX (0x1f): 输入事件类型的最大值。</li>
<li>EV_CNT: 输入事件类型的数量。</li>
</ul>
<p>而在 <code>input_dev</code> 结构体中定义了一系列的位图，在输入子系统中用于表示输入设备的能力和支持的功能，具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; <span class="comment">// 设备的属性位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">// 设备支持的事件类型位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">// 设备支持的按键位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">// 设备支持的相对坐标位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">// 设备支持的绝对坐标位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">// 设备支持的杂项事件位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">// 设备支持的 LED 位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)]; <span class="comment">// 设备支持的声音位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">// 设备支持的力反馈位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">// 设备支持的开关位图</span></span><br></pre></td></tr></table></figure>

<ul>
<li>evbit（事件类型位图）是一个长度为 EV_CNT 的数组，每个元素对应一个事件类型。通过设置相应的位，可以指示设备支持的事件类型，如按键事件、相对位移事件、绝对位移事件、杂项事件等。</li>
<li>keybit（按键类型位图）表示输入设备支持的按键类型，通常与 EV_KEY 事件类型相关。通过设置相应的位，可以指示设备支持的按键。</li>
<li>relbit（相对位移类型位图）表示输入设备支持的相对位移类型，通常与 EV_REL 事件类型相关。通过设置相应的位，可以指示设备支持的相对位移，例如鼠标的移动。</li>
<li>absbit（绝对位移类型位图）表示输入设备支持的绝对位移类型，通常与 EV_ABS 事件类型相关。通过设置相应的位，可以指示设备支持的绝对位移，例如触摸屏的坐标。</li>
<li>mscbit（杂项类型位图）表示输入设备支持的杂项类型，通常与 EV_MSC 事件类型相关。通过设置相应的位，可以指示设备支持的杂项事件，例如设备状态变化等。</li>
<li>ledbit（LED 类型位图）表示输入设备支持的 LED 类型，通常与 EV_LED 事件类型相关。通过设置相应的位，可以指示设备支持的 LED 灯控制。</li>
<li>sndbit（声音类型位图）表示输入设备支持的声音类型，通常与 EV_SND 事件类型相关。通过设置相应的位，可以指示设备支持的声音事件。</li>
<li>ffbit（力反馈类型位图）表示输入设备支持的力反馈类型，通常与 EV_FF 事件类型相关。通过设置相应的位，可以指示设备支持的力反馈事件。</li>
<li>swbit（开关类型位图）表示输入设备支持的开关类型，通常与 EV_SW 事件类型相关。通过设置相应的位，可以指示设备支持的开关状态变化。</li>
</ul>
<p><code>__set_bit</code> 是一个位操作函数，用于设置一个位图中的特定位，例如可以通过下面的代码将输入设备设置为支持按键事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__set_bit(EV_KEY,myinput_dev-&gt;evbit)</span><br></pre></td></tr></table></figure>

<h4 id="设置具体类型"><a href="#设置具体类型" class="headerlink" title="设置具体类型"></a>设置具体类型</h4><p>设 置 完 事 件 类 型 之 后 ， 还 需 要 设 置 具 体 类 型 ， 宏 定 义 仍 旧 定 义 在 头 文 件<code>include/uapi/linux/input-event-codes.h</code> 中，部分内容如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br></pre></td></tr></table></figure>

<p>上一小节只是将输入设备设置为了按键事件，但具体要表示什么呢，是按键 1 还是按键 2亦或者其他按键，都无法确定，所以仍旧需要使用<code>__set_bit</code> 函数来确定具体类型，例如使用以下程序将该输入设备设置为按键 1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__set_bit(KEY_1,myinput_dev-&gt;keybit)</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">myinput_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">myinput_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配输入设备结构体</span></span><br><span class="line">    myinput_dev = input_allocate_device();</span><br><span class="line">    <span class="keyword">if</span> (myinput_dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_allocate_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入设备的名称</span></span><br><span class="line">    myinput_dev-&gt;name = <span class="string">&quot;myinput_dev&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入设备支持的事件类型</span></span><br><span class="line">    __set_bit(EV_KEY, myinput_dev-&gt;evbit);    <span class="comment">// 设置支持按键事件</span></span><br><span class="line">    __set_bit(KEY_1, myinput_dev-&gt;keybit);    <span class="comment">// 设置支持按键1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册输入设备</span></span><br><span class="line">    ret = input_register_device(myinput_dev);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_register_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="comment">// 注册失败，释放输入设备结构体</span></span><br><span class="line">    input_free_device(myinput_dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">myinput_dev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销输入设备</span></span><br><span class="line">    input_unregister_device(myinput_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myinput_dev_init);</span><br><span class="line">module_exit(myinput_dev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意这里没有上报事件。</p>
<h2 id="分析匹配规则"><a href="#分析匹配规则" class="headerlink" title="分析匹配规则"></a>分析匹配规则</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> =</span> <span class="literal">NULL</span>;<span class="comment">// 输入设备资源结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span><span class="comment">// 输入处理程序指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> packet_size;<span class="comment">// 数据包大小</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path;<span class="comment">// 设备路径字符串指针</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit) &amp;&amp; !dev-&gt;absinfo) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev,</span><br><span class="line">			<span class="string">&quot;Absolute device without dev-&gt;absinfo, refusing to register\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;<span class="comment">// 如果设备资源是由管理的，则分配设备资源结构体</span></span><br><span class="line">		devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">				      <span class="keyword">sizeof</span>(*devres), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!devres)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		devres-&gt;input = dev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    <span class="comment">/* 每个输入设备都会产生 EV_SYN/SYN_REPORT 事件。 */</span></span><br><span class="line">	__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    <span class="comment">/* KEY_RESERVED 不应传递给用户空间。 */</span></span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    <span class="comment">/* 确保未在 dev-&gt;evbit 中提及的位掩码是干净的。 */</span></span><br><span class="line">	input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">	packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">		dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">	dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">	dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;vals) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_devres_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment">	 * is handled by the driver itself and we don&#x27;t do it in input.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 如果延迟和周期由驱动程序预设，</span></span><br><span class="line"><span class="comment">    * 则自动重复由驱动程序自己处理，我们不在 input.c 中处理。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span><br><span class="line">		input_enable_softrepeat(dev, <span class="number">250</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">		dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">		dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;poller)</span><br><span class="line">		input_dev_poller_finalize(dev-&gt;poller);</span><br><span class="line"></span><br><span class="line">	error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_free_vals;</span><br><span class="line"></span><br><span class="line">	path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">	pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">		dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">		path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">	kfree(path);</span><br><span class="line"></span><br><span class="line">	error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_device_del;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line">	<span class="comment">// 遍历输入处理程序链表，将输入设备与每个处理程序建立关联</span></span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">		dev_dbg(dev-&gt;dev.parent, <span class="string">&quot;%s: registering %s with devres.\n&quot;</span>,</span><br><span class="line">			__func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">		devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_del:</span><br><span class="line">	device_del(&amp;dev-&gt;dev);</span><br><span class="line">err_free_vals:</span><br><span class="line">	kfree(dev-&gt;vals);</span><br><span class="line">	dev-&gt;vals = <span class="literal">NULL</span>;</span><br><span class="line">err_devres_free:</span><br><span class="line">	devres_free(devres);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重点是<code>input_attach_handler()</code>函数</p>
<h3 id="input-attach-handler-1"><a href="#input-attach-handler-1" class="headerlink" title="input_attach_handler()"></a>input_attach_handler()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_attach_handler</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过输入设备和处理程序的匹配函数来确定是否适用于该设备</span></span><br><span class="line">    <span class="comment">// 这个函数将在处理程序的输入设备 ID 表中查找与给定的输入设备匹配的 ID，</span></span><br><span class="line">    <span class="comment">// 并返回匹配的 ID。如果没有找到匹配的 ID，则返回 NULL</span></span><br><span class="line">	id = input_match_device(handler, dev);</span><br><span class="line">	<span class="keyword">if</span> (!id)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用处理程序的连接函数来建立设备和处理程序之间的连接</span></span><br><span class="line">	error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">		pr_err(<span class="string">&quot;failed to attach handler %s to device %s, error: %d\n&quot;</span>,</span><br><span class="line">		       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="input-match-device-1"><a href="#input-match-device-1" class="headerlink" title="input_match_device()"></a>input_match_device()</h3><p>这个函数在输入子系统中的作用是在给定的输入事件处理程序（<code>input_handler）</code>中查找与指定输入设备匹配的输入设备 ID（input device ID）。</p>
<p>处理程序的输入设备 ID 表是一个以 <code>struct input_device_id</code> 结构为元素的数组，每个元素表示一个可能的输入设备 ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> input_device_id *<span class="title function_">input_match_device</span><span class="params">(<span class="keyword">struct</span> input_handler *handler,</span></span><br><span class="line"><span class="params">							<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">	<span class="comment">// 遍历处理程序的输入设备 ID 表，直到找到匹配的 ID 或遍历完所有 ID 为止</span></span><br><span class="line">	<span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (input_match_device_id(dev, id) &amp;&amp; <span class="comment">// 使用输入设备 ID 匹配函数判断给定的输入设备是否与当前 ID 匹配</span></span><br><span class="line">		    (!handler-&gt;match || handler-&gt;match(handler, dev))) &#123;<span class="comment">// 如果输入设备与 ID 匹配，并且处理程序的匹配函数返回 true（或者没有匹配函数），则返回该 ID</span></span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下evdev的<code>input_handler</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123; .driver_info = <span class="number">1</span> &#125;,	<span class="comment">/* Matches all devices */</span></span><br><span class="line">	&#123; &#125;,			<span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(input, evdev_ids);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">	.event		= evdev_event,</span><br><span class="line">	.events		= evdev_events,</span><br><span class="line">	.connect	= evdev_connect,</span><br><span class="line">	.disconnect	= evdev_disconnect,</span><br><span class="line">	.legacy_minors	= <span class="literal">true</span>,</span><br><span class="line">	.minor		= EVDEV_MINOR_BASE,</span><br><span class="line">	.name		= <span class="string">&quot;evdev&quot;</span>,</span><br><span class="line">	.id_table	= evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 <code>driver_info</code> 为 1，所以<code>input_match_device()</code>中的 for 循环的条件就会一直成立，在每一次的循环中都会判定 id 是不是匹配，即匹配所有的<code>input_dev</code>。</p>
<h3 id="input-match-device-id-1"><a href="#input-match-device-id-1" class="headerlink" title="input_match_device_id()"></a>input_match_device_id()</h3><p><code>input_match_device_id(dev, id)</code>调用输入设备 ID 匹配函数来判断给定的输入设备是否与当前 ID 匹配。匹配函数的作用是比较输入设备的属性与 ID 中指定的属性是否一致，例如厂商 ID、产品 ID 等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">input_match_device_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">			   <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span><span class="comment">// id = handler-&gt;id_table数组中的一项</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">		<span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">	    !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_match_device_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而我们上面写的最简单的输入设备驱动层代码并没有由于在编写的最简单的设备驱动层代码中并未定义 id 的 flags 参数，所以第 5、10、15、20 中的判断都不成立。</p>
<blockquote>
<p><code>bitmap_subset</code>是一个内联函数，用于判断两个位图是否具有子集关系，即<strong>判断第一个位图是否是第二个位图的子集</strong>。</p>
</blockquote>
<p>id 中并未定义 evbit、keybit、relbit 等，所以 25-34 行的 if 判断也不成立，最终该函数会返回 true，当然这仅仅只是对 evdev.c 这一通用事件处理代码进行的分析，返回 true， 之后然后回到 <code>input_attach_handler</code> 函数，然后会调用 <code>handler-&gt;connect</code> 建立与输入设备的连接。</p>
<h2 id="多对多匹配分析"><a href="#多对多匹配分析" class="headerlink" title="多对多匹配分析"></a>多对多匹配分析</h2><p><code>drivers/input/joydev.c</code> 文件的 <code>input_handler</code> 结构体内容如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">joydev_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="comment">// 第一个标识符，匹配 X 轴（ABS_X）的绝对事件</span></span><br><span class="line">		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">				INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">		.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件）</span></span><br><span class="line">		.absbit = &#123; BIT_MASK(ABS_X) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_X（X 轴</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="comment">// 第二个标识符，匹配 Z 轴（ABS_Z）的绝对事件</span></span><br><span class="line">		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">				INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">		.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件）</span></span><br><span class="line">		.absbit = &#123; BIT_MASK(ABS_Z) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_Z（Z 轴）</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="comment">// 第三个标识符，匹配滚轮（ABS_WHEEL）的绝对事件</span></span><br><span class="line">		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">				INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">		.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件</span></span><br><span class="line">		.absbit = &#123; BIT_MASK(ABS_WHEEL) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_WHEEL（滚轮）</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="comment">// 第四个标识符，匹配油门（ABS_THROTTLE）的绝对事件</span></span><br><span class="line">		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">				INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">		.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件）</span></span><br><span class="line">		.absbit = &#123; BIT_MASK(ABS_THROTTLE) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_THROTTLE（油门）</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="comment">// 第五个标识符，匹配游戏杆（BTN_JOYSTICK）的按键事件</span></span><br><span class="line">		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">				INPUT_DEVICE_ID_MATCH_KEYBIT,</span><br><span class="line">		.evbit = &#123; BIT_MASK(EV_KEY) &#125;,<span class="comment">// 匹配的事件类型是 EV_KEY（按键事件）</span></span><br><span class="line">		.keybit = &#123;[BIT_WORD(BTN_JOYSTICK)] = BIT_MASK(BTN_JOYSTICK) &#125;,<span class="comment">// 匹配的按键类型是BTN_JOYSTICK（游戏杆）</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="comment">// 第六个标识符，匹配游戏手柄（BTN_GAMEPAD）的按键事件</span></span><br><span class="line">		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">				INPUT_DEVICE_ID_MATCH_KEYBIT,</span><br><span class="line">		.evbit = &#123; BIT_MASK(EV_KEY) &#125;,<span class="comment">// 匹配的事件类型是 EV_KEY（按键事件）</span></span><br><span class="line">		.keybit = &#123; [BIT_WORD(BTN_GAMEPAD)] = BIT_MASK(BTN_GAMEPAD) &#125;,<span class="comment">// 匹配的按键类型是BTN_GAMEPAD（游戏手柄）</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="comment">// 第七个标识符，匹配快乐键（BTN_TRIGGER_HAPPY）的按键事件</span></span><br><span class="line">		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">				INPUT_DEVICE_ID_MATCH_KEYBIT,</span><br><span class="line">		.evbit = &#123; BIT_MASK(EV_KEY) &#125;,<span class="comment">// 匹配的事件类型是 EV_KEY（按键事件</span></span><br><span class="line">		.keybit = &#123; [BIT_WORD(BTN_TRIGGER_HAPPY)] = BIT_MASK(BTN_TRIGGER_HAPPY) &#125;,<span class="comment">// 匹配的按键类型是 BTN_TRIGGER_HAPPY（快乐键）</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123; &#125;	<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(input, joydev_ids);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">joydev_handler</span> =</span> &#123;</span><br><span class="line">	.event		= joydev_event,</span><br><span class="line">	.match		= joydev_match,</span><br><span class="line">	.connect	= joydev_connect,</span><br><span class="line">	.disconnect	= joydev_disconnect,</span><br><span class="line">	.legacy_minors	= <span class="literal">true</span>,</span><br><span class="line">	.minor		= JOYDEV_MINOR_BASE,</span><br><span class="line">	.name		= <span class="string">&quot;joydev&quot;</span>,</span><br><span class="line">	.id_table	= joydev_ids,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">joydev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> input_register_handler(&amp;joydev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">joydev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	input_unregister_handler(&amp;joydev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(joydev_init);</span><br><span class="line">module_exit(joydev_exit);</span><br></pre></td></tr></table></figure>

<p>与上面的通用设备驱动层 <code>evdev.c</code> 的 <code>evdev_handler</code> 结构体不同的是，<code>joydev_handler</code>结构体中有着对应的匹配函数，也就是说当设备驱动层与事件处理层进行匹配的时候，需要joydev_ids 结构体数组和相应的匹配函数共同决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/evdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123; .driver_info = <span class="number">1</span> &#125;,	<span class="comment">/* Matches all devices */</span></span><br><span class="line">	&#123; &#125;,			<span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体 <code>input_device_id</code> 的作用是<strong>描述输入设备的特征</strong>，以便内核能够识别和匹配正确的驱动程序。在通用设备驱动层 evdev.c 中的 evdev_ids 结构体数组设置的是 <code>driver_info</code> 表示匹配全部设备，而 joydev.c 中的 <code>joydev_ids</code> 结构体数组包含以下字段：</p>
<ul>
<li>flags ： 标 识 符 的 标 志 位 ， 用 于 指 定 匹 配 方 式 。 在 这 里 ， 使 用 flags 字 段 的<code>INPUT_DEVICE_ID_MATCH_EVBIT</code> 和 <code>INPUT_DEVICE_ID_MATCH_ABSBIT</code> 标志表示匹配事件类型和绝对事件类型。</li>
<li>evbit：事件类型的位掩码，用于指定要匹配的事件类型。在这里，evbit 字段的位掩码表示匹配的事件类型是 EV_ABS（绝对事件）或 EV_KEY（按键事件）。</li>
<li>absbit：绝对事件类型的位掩码，用于指定要匹配的绝对事件类型。在这里，absbit字段的位掩码表示匹配的绝对事件类型是 ABS_X（X 轴）、ABS_Z（Z 轴）、ABS_WHEEL（滚轮）或 ABS_THROTTLE（油门）。</li>
<li>keybit：按键类型的位掩码，用于指定要匹配的按键类型。在这里，keybit 字段的位掩码表示匹配的按键类型是 BTN_JOYSTICK（游戏杆）、BTN_GAMEPAD（游戏手柄）或BTN_TRIGGER_HAPPY（快乐键）。</li>
</ul>
<p>对于我们之前写的最简单的input设备驱动层代码：</p>
<p><code>input_match_device()</code>中的 for 循环中由于每个 <code>joydev_ids</code> 结构体数组中虽然<code>driver_info</code>没有设置，但是 flags 参数都存在且值不为零，所以 for 循环的条件是成立的，在 for 循环中会调用 <code>input_match_device_id</code> 函数判定给定的输入设备是否与当前 ID 匹配。</p>
<p>由于<code>id_table</code>中没有设置bustype, vendor, product, version, 因此检查设备的总线类型，厂商ID，产品ID，设备的版本号是否匹配都能匹配成功。但是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bitmap_subset</code> 用于<strong>判断第一个位图是否是第二个位图的子集</strong>。在编写的最简单的设备驱动层代码中的设置如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__set_bit(EV_KEY, myinput_dev-&gt;evbit); <span class="comment">// 设置支持按键事件</span></span><br><span class="line">__set_bit(KEY_1, myinput_dev-&gt;keybit); <span class="comment">// 设置支持按键 1</span></span><br></pre></td></tr></table></figure>

<p>判断<code>input_handler</code>的事件位图是否为<code>input_dev</code>设置的事件位图的子集，这是要求事件处理层要求的事件处理设备驱动层必须都要支持。</p>
<p>可以加一个打印：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">	!bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;input dev is error %s\n&quot;</span>, dev-&gt;name);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;input dev is ok %s\n&quot;</span>, dev-&gt;name);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195222786.png" alt="多对多匹配测试" loading="lazy"></p>
<p>总结：</p>
<p>在输入子系统中，输入设备和输入处理器之间的关系是多对多的。</p>
<p>这意味着<strong>一个输入设备可以与多个输入处理器关联，而一个输入处理器也可以处理多个输入设备的事件</strong>。</p>
<h2 id="完善设备驱动层代码"><a href="#完善设备驱动层代码" class="headerlink" title="完善设备驱动层代码"></a>完善设备驱动层代码</h2><h3 id="上报事件"><a href="#上报事件" class="headerlink" title="上报事件"></a>上报事件</h3><p><strong>上报事件是指在设备驱动层中，当输入设备产生事件时，将该事件通知给输入子系统</strong>。</p>
<p>在上报事件之前，首先要确定要上报的事件类型。事件类型可以是按键事件、相对位置事件、绝对位置事件等，取决于输入设备的特性和能力。</p>
<p>在 Linux 内核中，事件类型由预定义的常量表示，如 EV_KEY 表示按键事件，EV_REL 表示相对位置事件，EV_ABS 表示绝对位置事件等。<br>在前面编写的最简单的设备驱动层代码的第二个步骤中已经对事件类型和具体事件进行了确认。 </p>
<p>而在确定事件类型之后，就需要使用相应的上报函数将事件数据传递给输入子系统。常用的上报函数包括：</p>
<ul>
<li><code>input_report_key()</code>：上报按键事件，用于通知按键的按下和释放状态。</li>
<li><code>input_report_rel()</code>：上报相对位置事件，用于通知设备的相对移动量，如鼠标的移动。</li>
<li><code>input_report_abs()</code>：上报绝对位置事件，用于通知设备的绝对位置，如触摸屏的坐标。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195226891.png" alt="上报事件" loading="lazy"></p>
<h3 id="上报函数"><a href="#上报函数" class="headerlink" title="上报函数"></a>上报函数</h3><h4 id="input-report-key"><a href="#input-report-key" class="headerlink" title="input_report_key()"></a>input_report_key()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>头文件</strong></td>
<td><code>&lt;linux/input.h&gt;</code></td>
</tr>
<tr>
<td><strong>函数原型</strong></td>
<td><code>void input_report_key(struct input_dev *dev, unsigned int code, int value)</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>dev</code>：指向输入设备结构体 <code>input_dev</code> 的指针 - <code>code</code>：按键事件码（如 <code>KEY_A</code>, <code>BTN_TOUCH</code> 等） - <code>value</code>：按键状态（0 &#x3D; 释放，非 0 &#x3D; 按下）</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无（<code>void</code>）</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>上报一个 <strong>按键事件（EV_KEY）</strong>。用于键盘、按钮、触摸屏点击等场景。</td>
</tr>
</tbody></table>
<hr>
<h4 id="input-report-rel"><a href="#input-report-rel" class="headerlink" title="input_report_rel()"></a>input_report_rel()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>头文件</strong></td>
<td><code>&lt;linux/input.h&gt;</code></td>
</tr>
<tr>
<td><strong>函数原型</strong></td>
<td><code>void input_report_rel(struct input_dev *dev, unsigned int code, int value)</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：相对轴类型（如 <code>REL_X</code>, <code>REL_Y</code>, <code>REL_WHEEL</code>） - <code>value</code>：相对于上一次位置的偏移量（可正可负）</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无（<code>void</code>）</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>上报一个 <strong>相对坐标事件（EV_REL）</strong>。常用于鼠标、滚轮等设备。</td>
</tr>
</tbody></table>
<h4 id="input-report-abs"><a href="#input-report-abs" class="headerlink" title="input_report_abs()"></a>input_report_abs()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>头文件</strong></td>
<td><code>&lt;linux/input.h&gt;</code></td>
</tr>
<tr>
<td><strong>函数原型</strong></td>
<td><code>void input_report_abs(struct input_dev *dev, unsigned int code, int value)</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：绝对轴类型（如 <code>ABS_X</code>, <code>ABS_Y</code>, <code>ABS_MT_POSITION_X</code>） - <code>value</code>：当前的绝对坐标值</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无（<code>void</code>）</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>上报一个 <strong>绝对坐标事件（EV_ABS）</strong>。用于触摸屏、手写板、游戏手柄摇杆等设备。</td>
</tr>
</tbody></table>
<hr>
<h4 id="input-report-ff-status"><a href="#input-report-ff-status" class="headerlink" title="input_report_ff_status()"></a>input_report_ff_status()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>头文件</strong></td>
<td><code>&lt;linux/input.h&gt;</code></td>
</tr>
<tr>
<td><strong>函数原型</strong></td>
<td><code>void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：力反馈效果 ID（通常由用户空间分配） - <code>value</code>：力反馈状态（0 &#x3D; 停止，非 0 &#x3D; 正在播放）</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无（<code>void</code>）</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>上报 <strong>力反馈（Force Feedback）状态事件（EV_FF_STATUS）</strong>，用于通知用户空间某个力反馈效果的当前运行状态。</td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ 注：该函数较少使用，多数力反馈由内核主动控制，而非设备上报状态。</p>
</blockquote>
<hr>
<h4 id="input-report-switch"><a href="#input-report-switch" class="headerlink" title="input_report_switch()"></a>input_report_switch()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>头文件</strong></td>
<td><code>&lt;linux/input.h&gt;</code></td>
</tr>
<tr>
<td><strong>函数原型</strong></td>
<td><code>void input_report_switch(struct input_dev *dev, unsigned int code, int value)</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：开关类型（如 <code>SW_LID</code>, <code>SW_TABLET_MODE</code>） - <code>value</code>：开关状态（0 &#x3D; 关闭&#x2F;打开盖子，非 0 &#x3D; 打开&#x2F;合上盖子，具体含义依类型而定）</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无（<code>void</code>）</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>上报一个 <strong>开关状态事件（EV_SW）</strong>。常用于笔记本翻盖检测、平板模式切换等硬件开关。</td>
</tr>
</tbody></table>
<hr>
<h4 id="input-sync"><a href="#input-sync" class="headerlink" title="input_sync()"></a>input_sync()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>头文件</strong></td>
<td><code>&lt;linux/input.h&gt;</code></td>
</tr>
<tr>
<td><strong>函数原型</strong></td>
<td><code>void input_sync(struct input_dev *dev)</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>dev</code>：指向 <code>input_dev</code> 的指针</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无（<code>void</code>）</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>发送一个 <strong>同步事件（EV_SYN &#x2F; SYN_REPORT）</strong>，表示一组相关事件已完整上报。用户空间会将此前所有未同步的事件视为“同一时间发生”的一个事件包。<strong>每次上报完一组数据后必须调用此函数</strong>，否则事件可能不会被处理。</td>
</tr>
</tbody></table>
<h4 id="input-event"><a href="#input-event" class="headerlink" title="input_event()"></a>input_event()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_event() - report new input event</span></span><br><span class="line"><span class="comment"> * @dev: device that generated the event</span></span><br><span class="line"><span class="comment"> * @type: type of the event</span></span><br><span class="line"><span class="comment"> * @code: event code</span></span><br><span class="line"><span class="comment"> * @value: value of the event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be used by drivers implementing various input</span></span><br><span class="line"><span class="comment"> * devices to report input events. See also input_inject_event().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> input_event() may be safely used right after input device was</span></span><br><span class="line"><span class="comment"> * allocated with input_allocate_device(), even before it is registered</span></span><br><span class="line"><span class="comment"> * with input_register_device(), but the event will not reach any of the</span></span><br><span class="line"><span class="comment"> * input handlers. Such early invocation of input_event() may be used</span></span><br><span class="line"><span class="comment"> * to &#x27;seed&#x27; initial state of a switch or initial position of absolute</span></span><br><span class="line"><span class="comment"> * axis, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">		spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">		input_handle_event(dev, type, code, value);</span><br><span class="line">		spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_event);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul>
<li>所有上述函数均为 <strong>内联函数（inline）</strong>，内部最终调用 <code>input_event(dev, type, code, value)</code>。</li>
<li>事件类型（<code>type</code>）由函数隐式确定：<ul>
<li><code>input_report_key</code> → <code>EV_KEY</code></li>
<li><code>input_report_rel</code> → <code>EV_REL</code></li>
<li><code>input_report_abs</code> → <code>EV_ABS</code></li>
<li><code>input_report_ff_status</code> → <code>EV_FF_STATUS</code></li>
<li><code>input_report_switch</code> → <code>EV_SW</code></li>
<li><code>input_sync</code> → <code>EV_SYN</code>（<code>code = SYN_REPORT</code>）</li>
</ul>
</li>
</ul>
<p>这些函数是 Linux 输入子系统驱动开发中最核心的 API，用于将硬件产生的原始数据转换为标准输入事件供用户空间（如 evdev、libinput、X11&#x2F;Wayland）使用。</p>
<p>在使用上报函数之后，通常会调用 <code>input_sync()</code>函数进行同步。同步事件的目的是告知输入子系统事件的结束，以便子系统可以将事件传递给相应的应用程序或系统组件进行处理。同步事件的调用可以防止事件数据的丢失或混乱。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>驱动，使用定时器每隔一段时间上报事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">myinput_dev</span>;</span>  <span class="comment">// 输入设备结构体指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;</span><br><span class="line"></span><br><span class="line">DEFINE_TIMER(test_timer, timer_function);  <span class="comment">// 定义定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;  <span class="comment">// 静态变量用于切换键值</span></span><br><span class="line"></span><br><span class="line">    value = value ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    input_event(myinput_dev, EV_KEY, KEY_1, value);      <span class="comment">// 发送按键事件</span></span><br><span class="line">    input_event(myinput_dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);     <span class="comment">// 发送同步事件</span></span><br><span class="line"></span><br><span class="line">    mod_timer(&amp;test_timer, jiffies + msecs_to_jiffies(<span class="number">1000</span>));  <span class="comment">// 更新定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">myinput_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    myinput_dev = input_allocate_device();  <span class="comment">// 分配输入设备</span></span><br><span class="line">    <span class="keyword">if</span> (myinput_dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_allocate_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myinput_dev-&gt;name = <span class="string">&quot;myinput_dev&quot;</span>;  <span class="comment">// 设置设备名</span></span><br><span class="line"></span><br><span class="line">    set_bit(EV_KEY, myinput_dev-&gt;evbit);   <span class="comment">// 支持按键事件</span></span><br><span class="line">    set_bit(EV_SYN, myinput_dev-&gt;evbit);   <span class="comment">// 支持同步事件</span></span><br><span class="line">    set_bit(KEY_1, myinput_dev-&gt;keybit);   <span class="comment">// 支持 KEY_1 按键</span></span><br><span class="line"></span><br><span class="line">    ret = input_register_device(myinput_dev);  <span class="comment">// 注册输入设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_register_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mod_timer(&amp;test_timer, jiffies + msecs_to_jiffies(<span class="number">1000</span>));  <span class="comment">// 启动定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    input_free_device(myinput_dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">myinput_dev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    del_timer(&amp;test_timer);           <span class="comment">// 删除定时器</span></span><br><span class="line">    input_unregister_device(myinput_dev);  <span class="comment">// 取消注册输入设备</span></span><br><span class="line">    input_free_device(myinput_dev);   <span class="comment">// 释放输入设备内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myinput_dev_init);</span><br><span class="line">module_exit(myinput_dev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="应用层获取上报数据"><a href="#应用层获取上报数据" class="headerlink" title="应用层获取上报数据"></a>应用层获取上报数据</h2><h3 id="input-event-结构体"><a href="#input-event-结构体" class="headerlink" title="input_event 结构体"></a>input_event 结构体</h3><p>应用层读取的数据为<code>input_event</code>结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)) &amp;&amp; !defined(__KERNEL__)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec time.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec time.tv_usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> __sec;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sparc__) &amp;&amp; defined(__arch64__)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __usec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __pad;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> __usec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec  __sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec __usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__u16 type;<span class="comment">// 类型</span></span><br><span class="line">	__u16 code;<span class="comment">// 具体事件</span></span><br><span class="line">	__s32 value;<span class="comment">// 对应的取值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>type</strong>：type 用于描述发生了哪一种类型的事件（对事件的分类），Linux 系统所支持的输入事件类型如下所示，这些宏定义同样在<code>&lt;linux/input.h&gt;</code>头文件中，所以在应用程序中需要包含该头文件；<ul>
<li>EV_SYN (0x00): 用于<strong>同步事件</strong>，表示一组输入事件的结束。</li>
<li>EV_KEY (0x01): 用于<strong>按键事件</strong>，表示按下、释放或重复一个键。</li>
<li>EV_REL (0x02): 用于<strong>相对位移事件</strong>，表示设备的相对位置变化，例如鼠标的移动。</li>
<li>EV_ABS (0x03): 用于<strong>绝对位移事件</strong>，表示设备的绝对位置变化，例如触摸屏的坐标。</li>
<li>EV_MSC (0x04): 用于<strong>杂项事件</strong>，包含一些特殊目的的事件类型，例如设备状态变化等。</li>
<li>EV_SW (0x05): 用于<strong>开关事件</strong>，表示开关的状态变化，例如电源按钮、开合盖等。</li>
<li>EV_LED (0x11): 用于 <strong>LED 事件</strong>，表示 LED 灯的状态变化。</li>
<li>EV_SND (0x12): 用于<strong>声音事件</strong>，表示声音的播放相关事件。</li>
<li>EV_REP (0x14): 用于<strong>重复事件</strong>，表示键盘重复发送事件。</li>
<li>EV_FF (0x15): 用于<strong>力反馈事件</strong>，表示力反馈设备的输出事件。</li>
<li>EV_PWR (0x16): 用于<strong>电源事件</strong>，表示电源状态变化。</li>
<li>EV_FF_STATUS (0x17): 用于<strong>力反馈状态事件</strong>，表示力反馈设备的状态变化。</li>
<li>EV_MAX (0x1f): 输入事件类型的最大值。</li>
<li>EV_CNT: 输入事件类型的数量。</li>
</ul>
</li>
<li><strong>code</strong>：code 表示该类事件中的哪一个具体事件，以上列举的每一种事件类型中都包含了一系列具体事件，譬如一个键盘上通常有很多按键，而 code 变量则告知应用程序是哪一个按键发生了输入事件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1 <span class="comment">//ESC 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2  <span class="comment">//数字 1 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3  <span class="comment">//数字 2 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4  <span class="comment">//数字 3 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5  <span class="comment">//数字 4 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6  <span class="comment">//数字 5 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7 <span class="comment">//数字 6 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8 <span class="comment">//数字 7 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9 <span class="comment">//数字 8 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10 <span class="comment">//数字 9 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_0 11 <span class="comment">//数字 0 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_MINUS 12 <span class="comment">//减号键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_EQUAL 13<span class="comment">//加号键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_BACKSPACE 14 <span class="comment">//回退键</span></span></span><br></pre></td></tr></table></figure>

<p>对于其他输入事件的 code 值 ，可以查看 <code>input-event-codes.h</code> 头文件 （该头文件被<code>&lt;linux/input.h&gt;</code>所包含）。</p>
<ul>
<li><strong>value</strong>: 核每次上报事件都会向应用层发送一个数据 value，对 value 值的解释随着 code的变化而变化。<ul>
<li>譬如对于按键事件来说，如果 value 等于 1，则表示按键按下；value 等于 0 表示按键松开，如果 value 等于 2 则表示按键长按。</li>
<li>而在绝对位移事件中（type&#x3D;3），如果code&#x3D;0（触摸点 X 坐标 ABS_X），那么 value 值就等于触摸点的 X 轴坐标值；如果 code&#x3D;1（触摸点 Y 坐标 ABS_Y），此时 value 值便等于触摸点的 Y 轴坐标值。</li>
</ul>
</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> ret;  <span class="comment">// 返回值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span>  <span class="comment">// 输入事件结构体</span></span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/input/event4&quot;</span>, O_RDWR);  <span class="comment">// 打开输入设备文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开错误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = read(fd, &amp;event, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_event));  <span class="comment">// 读取输入事件</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;读取错误\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.type == EV_KEY) &#123;  <span class="comment">// 判断事件类型为键盘事件</span></span><br><span class="line">            <span class="keyword">if</span> (event.code == KEY_1) &#123;  <span class="comment">// 判断键码为1</span></span><br><span class="line">                <span class="keyword">if</span> (event.value == <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;值为1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (event.value == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;值为0\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="上报数据格式"><a href="#上报数据格式" class="headerlink" title="上报数据格式"></a>上报数据格式</h3><p>以使用命令<code>hexdump /dev/input/event4</code>来查看上报的信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195236276.png" alt="hexdump &#x2F;dev&#x2F;input&#x2F;event4" loading="lazy"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)) &amp;&amp; !defined(__KERNEL__)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec time.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec time.tv_usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> __sec;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sparc__) &amp;&amp; defined(__arch64__)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __usec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __pad;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> __usec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec  __sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec __usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__u16 type;<span class="comment">// 类型</span></span><br><span class="line">	__u16 code;<span class="comment">// 具体事件</span></span><br><span class="line">	__s32 value;<span class="comment">// 对应的取值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>input_event</code> 数据包中，有四个成员变量：time, type, code, value。<ul>
<li><code>time.tv_sec</code> 和 <code>time.tv_usec</code> 的类型是 long int,占 8 个字节，所以<code>time</code>占16个字节</li>
<li><code>__u16 type</code> 的类型是 unsigned short int,占 2 个字节</li>
<li><code>__u16 code</code> 的类型是 unsigned short int,占 2 个字节</li>
<li><code>__s32 value</code> 的类型是 unsigned int，占 4 个字节</li>
</ul>
</li>
</ul>
<p>因此，一个 input_event 数据包所占字节的大小为 8+8+2+2+4 &#x3D;24 个字节</p>
<blockquote>
<p> 一般情况下，<code>input_event</code> 数据包的字节顺序是小端字节序（Little Endian）。这意味着较低的字节位于较高的内存地址处。</p>
</blockquote>
<p>假设 hexdump 输出的数据（以 16 进制表示）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@topeet:~$ hexdump /dev/input/event2</span><br><span class="line"><span class="number">0000000</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000010</span> <span class="number">0003</span> <span class="number">0039</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000020</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0003</span> <span class="number">0035</span> <span class="number">00f</span>5 <span class="number">0000</span></span><br><span class="line"><span class="number">0000030</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000040</span> <span class="number">0003</span> <span class="number">0036</span> <span class="number">02b</span>2 <span class="number">0000</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000050</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0003</span> <span class="number">0030</span> <span class="number">0021</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>

<p>第一个<code>input_event</code>对应成员如下：</p>
<ul>
<li><strong>tv_sec</strong>        0f09 65d3 0000 0000</li>
<li><strong>tv_usec</strong>     36fb 0001 0000 0000</li>
<li><strong>type</strong>           0003</li>
<li><strong>code</strong>           0039</li>
<li><strong>value</strong>         0000 0000</li>
</ul>
<h2 id="通用事件处理层-evdev"><a href="#通用事件处理层-evdev" class="headerlink" title="通用事件处理层 evdev"></a>通用事件处理层 evdev</h2><h3 id="connect-函数分析"><a href="#connect-函数分析" class="headerlink" title="connect 函数分析"></a>connect 函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/evdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">	.event		= evdev_event, <span class="comment">// 事件处理函数指针，指向名为 evdev_event 的函数，用于处理输入事件</span></span><br><span class="line">	.events		= evdev_events,<span class="comment">// 批量事件处理函数指针，指向名为 evdev_events 的函数，用于处理输入设备的多个事件</span></span><br><span class="line">	.connect	= evdev_connect,<span class="comment">// 当 input_dev 和 input_handler 匹配成功之后执行的连接处理函数</span></span><br><span class="line">	.disconnect	= evdev_disconnect,<span class="comment">// 断开连接处理函数</span></span><br><span class="line">	.legacy_minors	= <span class="literal">true</span>,<span class="comment">// 设置为 true,表示支持传统次设备号，如果设置为 false,则使用动态的次设备号分配方式</span></span><br><span class="line">	.minor		= EVDEV_MINOR_BASE,<span class="comment">// 输入设备的基础次设备号</span></span><br><span class="line">	.name		= <span class="string">&quot;evdev&quot;</span>,<span class="comment">// 设备名称，设置为字符串 &quot;evdev&quot;</span></span><br><span class="line">	.id_table	= evdev_ids,<span class="comment">// 输入设备 ID 表，指向名为 evdev_ids 的表，用于匹配输入设备的 ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">evdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="evdev-结构体"><a href="#evdev-结构体" class="headerlink" title="evdev 结构体"></a>evdev 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> open;<span class="comment">// 记录 evdev 设备打开的状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span><span class="comment">// 输入事件处理器的句柄</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span><span class="comment">// 指向当前占用 evdev 设备的客户端</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span><span class="comment">// 与 evdev 设备关联的客户端链表</span></span><br><span class="line">	<span class="type">spinlock_t</span> client_lock; <span class="comment">/* protects client_list */</span> <span class="comment">// 用于保护客户端链表的自旋锁</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">// 用于保护对 evdev 设备的互斥访问</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">// 与 evdev 设备关联的设备结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">// evdev 设备的字符设备结构</span></span><br><span class="line">	<span class="type">bool</span> exist;<span class="comment">// 表示 evdev 设备是否存在</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>open</strong>: 记录 evdev 设备的打开状态，可能的取值为 0（关闭）或 1（打开）。</li>
<li><strong>handle</strong>: 用于处理输入事件的句柄，包含了与事件处理器相关的信息，如打开的输入设备和事件处理函数等。</li>
<li><strong>grab</strong>: 指向当前占用 evdev 设备的客户端。当某个客户端占用了 evdev 设备时，其他客户端无法访问该设备。</li>
<li><strong>client_list</strong>:  与 evdev 设备关联的客户端链表，用于管理连接到该设备的客户端。</li>
<li><strong>client_lock</strong>: 用于保护客户端链表的自旋锁，确保在多线程环境下对客户端链表的操作线程是安全的。</li>
<li><strong>mutex</strong>: 用于保护对 evdev 设备的互斥访问，确保在多线程环境下对设备的操作是互斥的。</li>
<li><strong>dev</strong>: 与 evdev 设备关联的设备结构体，用于表示设备的特定信息，如设备名称，设备号等。</li>
<li><strong>cdev</strong>: evdev 设备的字符设备结构，用于注册和管理字符设备。</li>
<li><strong>exist</strong>: 表示 evdev 设备是否存在的标志。如果设备存在，则为 true;否则为 false。</li>
</ul>
<h4 id="evdev-client-结构体"><a href="#evdev-client-结构体" class="headerlink" title="evdev_client 结构体"></a>evdev_client 结构体</h4><p>这个结构体定义了一个 evdev 客户端的相关信息和状态，用于管理与 evdev 设备相关联的客户端，<strong>在应用程序中每打开一遍 event 设备节点，就会用一个 <code>evdev_client</code> 结构体来表示</strong>，系统可以为每个 evdev 设备维护多个客户端，并管理每个客户端的状态和属性。</p>
<p>在 evdev.c 中，也会对这个结构体进行操作，并根据客户端的状态和属性，将接收到的事件写入缓冲区或通知客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head; <span class="comment">// 缓冲区的头指针，指向下一个可写入的位置</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tail; <span class="comment">// 缓冲区的尾指针，指向下一个可读取的位置</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span> <span class="comment">// [未来] 下一个数据包的第一个元素的位置</span></span><br><span class="line">	<span class="type">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span> <span class="comment">// 用于保护对缓冲区、头指针和尾指针的访问的自旋锁</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span><span class="comment">// 用于异步通知的结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span><span class="comment">// 与客户端关联的 evdev 设备指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">// 与 evdev 设备关联的客户端链表节点</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">input_clock_type</span> <span class="title">clk_type</span>;</span><span class="comment">// 输入时钟类型</span></span><br><span class="line">	<span class="type">bool</span> revoked;<span class="comment">// 标志，指示客户端是否被撤销</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *evmasks[EV_CNT];<span class="comment">// 用于事件掩码的数组</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bufsize;<span class="comment">// 缓冲区的大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span><span class="comment">// 输入事件缓冲区，可变长度数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>head</strong>: 缓冲区的头指针，指向下一个可写入的位置。</li>
<li><strong>tail</strong>:缓冲区的尾指针，指向下一个可读取的位置。</li>
<li><strong>packet_head</strong>:下一个数据包的第一个元素的位置。</li>
<li><strong>buffer_lock</strong>：用于保护对缓冲区，头指针和尾指针的访问的自旋锁，在多线程环境下确保对缓冲区的操作线程是安全的。</li>
<li><strong>fasync</strong>:用于异步通知的结构体指针，在需要异步通知时，将其设置为相应的值。</li>
<li><strong>evdev</strong>:与客户端关联的 evdev 设备指针，表示客户端所属的 evdev 设备。</li>
<li><strong>node</strong>:与 evdev 设备关联的客户端链表节点，用于管理与设备关联的客户端。</li>
<li><strong>clk_type</strong>:输入时钟类型，表示客户端使用的输入时钟类型。</li>
<li><strong>revoked</strong>:标志，指示客户端是否被撤销。</li>
<li><strong>evmasks</strong>:用于事件掩码的数组，存储了不同类型事件的掩码，数组的大小由 EV_CNT 定义。</li>
<li><strong>bufsize</strong>:缓冲区的大小，表示缓冲区可以容纳的输入事件数量。</li>
<li><strong>buffer[]</strong>:输入事件缓冲区，是一个可变长度数组，存储了输入事件数据。</li>
</ul>
<h4 id="evdev-connect-1"><a href="#evdev-connect-1" class="headerlink" title="evdev_connect()"></a>evdev_connect()</h4><p><code>input_handler</code>的connect函数。</p>
<p><code>input_register_handler()</code>中调用<code>input_attach_handler()</code>，该函数又调用<code>input_handler</code>的connect函数，<code>error = handler-&gt;connect(handler, dev, id)</code>即<code>evdev_connect()</code></p>
<p>该函数的主要功能是建立与输入设备的连接，初始化并注册输入句柄，设置设备属性，并添加字符设备到系统中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINOR_BASE	64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINORS		32</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create new evdev device. Note that input core serializes calls</span></span><br><span class="line"><span class="comment"> * to connect and disconnect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_connect</span><span class="params">(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">	<span class="type">int</span> minor;</span><br><span class="line">	<span class="type">int</span> dev_no;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="comment">// 获取一个新的次设备号</span></span><br><span class="line">	minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (minor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		error = minor;</span><br><span class="line">		pr_err(<span class="string">&quot;failed to reserve new minor: %d\n&quot;</span>, error);</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 分配并初始化 evdev 结构体</span></span><br><span class="line">	evdev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> evdev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!evdev) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_free_minor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化 evdev 结构体中的成员</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;evdev-&gt;client_list);<span class="comment">// 初始化客户端链表</span></span><br><span class="line">	spin_lock_init(&amp;evdev-&gt;client_lock);<span class="comment">// 初始化客户端链表的自旋锁</span></span><br><span class="line">	mutex_init(&amp;evdev-&gt;mutex);<span class="comment">// 初始化互斥锁</span></span><br><span class="line">	evdev-&gt;exist = <span class="literal">true</span>;<span class="comment">// 设置 evdev 存在标志为 true，表示 evdev 存在。</span></span><br><span class="line"></span><br><span class="line">	dev_no = minor;<span class="comment">// 根据次设备号计算设备号 dev_no,并根据情况将其归一化为传统范围内的设备号。</span></span><br><span class="line">	<span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)<span class="comment">// 如果设备号在旧版范围内，则进行标准化处理</span></span><br><span class="line">		dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">	dev_set_name(&amp;evdev-&gt;dev, <span class="string">&quot;event%d&quot;</span>, dev_no);<span class="comment">// 设置设备名称</span></span><br><span class="line"></span><br><span class="line">	evdev-&gt;handle.dev = input_get_device(dev);<span class="comment">// 设置输入句柄的输入设备</span></span><br><span class="line">	evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);<span class="comment">// 设置输入句柄的名称为设备名称</span></span><br><span class="line">	evdev-&gt;handle.handler = handler;<span class="comment">// 设置输入句柄的处理程序为传入的处理程序</span></span><br><span class="line">	evdev-&gt;handle.private = evdev;<span class="comment">//  设置输入句柄的私有数据指针为 evdev 结构体的指针</span></span><br><span class="line"></span><br><span class="line">	evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);<span class="comment">// 设置设备号</span></span><br><span class="line">	evdev-&gt;dev.class = &amp;input_class;<span class="comment">// 设置设备的类</span></span><br><span class="line">	evdev-&gt;dev.parent = &amp;dev-&gt;dev;<span class="comment">// 设置设备的父设备</span></span><br><span class="line">	evdev-&gt;dev.release = evdev_free;<span class="comment">// 设置设备的释放函数为 evdev_free</span></span><br><span class="line">	device_initialize(&amp;evdev-&gt;dev);<span class="comment">// 初始化设备</span></span><br><span class="line"></span><br><span class="line">	error = input_register_handle(&amp;evdev-&gt;handle);<span class="comment">// 注册输入句柄</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_free_evdev;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);<span class="comment">// 初始化字符设备结构体</span></span><br><span class="line"></span><br><span class="line">	error = cdev_device_add(&amp;evdev-&gt;cdev, &amp;evdev-&gt;dev);<span class="comment">// 添加字符设备</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">	evdev_cleanup(evdev);<span class="comment">// 清理 evdev 结构体</span></span><br><span class="line">	input_unregister_handle(&amp;evdev-&gt;handle);<span class="comment">// 取消注册输入句柄</span></span><br><span class="line"> err_free_evdev:</span><br><span class="line">	put_device(&amp;evdev-&gt;dev);<span class="comment">// 释放设备</span></span><br><span class="line"> err_free_minor:</span><br><span class="line">	input_free_minor(minor);<span class="comment">// 释放次设备号</span></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见 <code>connect</code> 函数的主要任务是将输入设备与事件处理器关联起来，以便在事件发生时调用相应的处理函数。</p>
<p>它通过注册输入处理器和设置回调函数来实现这一关联，并确保正确的事件处理器被调用。这种关联机制允许开发者根据需要自定义处理函数，以便根据输入设备上报的事件进行相应的处理。</p>
<h3 id="分配设备号分析"><a href="#分配设备号分析" class="headerlink" title="分配设备号分析"></a>分配设备号分析</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195244328.png" alt="次设备号" loading="lazy"></p>
<p>从上图中可以发现由 evdev.c 程序创建的设备节点 event0,event1,event2,event3 的主设备号都是 13，次设备号是 64,65,66,67。所有设备号的规律是主设备号全部都是 13，次设备号从 64 开始依次往后类推。</p>
<h4 id="主设备号"><a href="#主设备号" class="headerlink" title="主设备号"></a>主设备号</h4><p>在 connect 函数中，使用 <code>	evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);</code>设置了主设备号，主设备号为INPUT_MAJOR,也就是 13</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/major.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MAJOR		13</span></span><br></pre></td></tr></table></figure>

<h4 id="次设备号"><a href="#次设备号" class="headerlink" title="次设备号"></a>次设备号</h4><p>在 connect 函数中，使用了<code>minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);</code>函数获取了次设备号。而</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINOR_BASE	64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINORS		32</span></span><br></pre></td></tr></table></figure>



<h5 id="input-get-new-minor"><a href="#input-get-new-minor" class="headerlink" title="input_get_new_minor()"></a>input_get_new_minor()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_get_new_minor - allocates a new input minor number</span></span><br><span class="line"><span class="comment"> * @legacy_base: beginning or the legacy range to be searched</span></span><br><span class="line"><span class="comment"> * @legacy_num: size of legacy range</span></span><br><span class="line"><span class="comment"> * @allow_dynamic: whether we can also take ID from the dynamic range</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function allocates a new device minor for from input major namespace.</span></span><br><span class="line"><span class="comment"> * Caller can request legacy minor by specifying @legacy_base and @legacy_num</span></span><br><span class="line"><span class="comment"> * parameters and whether ID can be allocated from dynamic range if there are</span></span><br><span class="line"><span class="comment"> * no free IDs in legacy range.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_get_new_minor</span><span class="params">(<span class="type">int</span> legacy_base, <span class="type">unsigned</span> <span class="type">int</span> legacy_num,</span></span><br><span class="line"><span class="params">			<span class="type">bool</span> allow_dynamic)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This function should be called from input handler&#x27;s -&gt;connect()</span></span><br><span class="line"><span class="comment">	 * methods, which are serialized with input_mutex, so no additional</span></span><br><span class="line"><span class="comment">	 * locking is needed here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (legacy_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> minor = ida_simple_get(&amp;input_ida,</span><br><span class="line">					   legacy_base,</span><br><span class="line">					   legacy_base + legacy_num,</span><br><span class="line">					   GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (minor &gt;= <span class="number">0</span> || !allow_dynamic)</span><br><span class="line">			<span class="keyword">return</span> minor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ida_simple_get(&amp;input_ida,</span><br><span class="line">			      INPUT_FIRST_DYNAMIC_DEV, INPUT_MAX_CHAR_DEVICES,</span><br><span class="line">			      GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_get_new_minor);</span><br></pre></td></tr></table></figure>

<p>上面的函数用于获取一个新的次设备号。主要功能是根据指定的条件获取一个新的次设备号。如果指定了 legacy_base，则优先从该范围内获取次设备号，如果获取失败或不允许动态分配，则尝试从动态分配的范围内获取次设备号。最终返回获取到的次设备号。</p>
<ul>
<li><p>如果 legacy_base 大于等于 0，则执行以下逻辑：</p>
<ul>
<li><p>使用 <code>ida_simple_get()</code> 函数从 <code>input_ida</code> 中获取一个次设备号 <code>minor</code>,范围为 <code>legacy_base</code> 到 <code>legacy_base+legacy_num</code></p>
</li>
<li><p>如果获取到的次设备号 minor 大于等于 0 或者不允许动态分配（<code>allow_dynamic</code> 为 false），则返回次设备号 minor。</p>
</li>
</ul>
</li>
<li><p>如果上述条件不满足，则执行以下逻辑：</p>
<ul>
<li>使 用 <code>ida_simple_get()</code> 函 数 从<code>input_ida</code> 中 获 取 一 个 次 设 备 号<code>minor</code> ， 范 围 为<code>INPUT_FIRST_DYNAMIC_DEV</code> 到 <code>INPUT_MAX_CHAR_DEVICES</code>。</li>
</ul>
</li>
</ul>
<p>而<code>ida_simple_get()</code>定义为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ida_simple_get(ida, start, end, gfp)	\</span></span><br><span class="line"><span class="meta">			ida_alloc_range(ida, start, (end) - 1, gfp)</span></span><br></pre></td></tr></table></figure>

<p><code>ida_alloc_range</code>函数用于在 ID 分配器中分配一个连续的 ID 范围。宏的参数解释如下：</p>
<ul>
<li><strong>ida</strong>:    表示 IDA 对象的指针，用于管理 ID 范围的分配和释放。</li>
<li><strong>start</strong>: 表示分配的 ID 范围的起始 ID。</li>
<li><strong>end</strong>:  表示分配的 ID 范围的结束 ID。</li>
<li><strong>gfp</strong>:   表示用于内存分配的 GFP 标志。</li>
</ul>
<h3 id="文件操作集函数"><a href="#文件操作集函数" class="headerlink" title="文件操作集函数"></a>文件操作集函数</h3><p>在 <code>connect</code> 函数中，通过<code>	cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</code>创建字符设备，创建字符设备中最重要的操作是实现文件操作集中的函数，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.read		= evdev_read,</span><br><span class="line">	.write		= evdev_write,</span><br><span class="line">	.poll		= evdev_poll,</span><br><span class="line">	.open		= evdev_open,</span><br><span class="line">	.release	= evdev_release,</span><br><span class="line">	.unlocked_ioctl	= evdev_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	.compat_ioctl	= evdev_ioctl_compat,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.fasync		= evdev_fasync,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="open-函数分析"><a href="#open-函数分析" class="headerlink" title="open 函数分析"></a>open 函数分析</h4><p>在 <code>connect</code> 函数中，通过<code>	cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</code>创建字符设备，创建字符设备中最重要的操作是实现文件操作集中的函数，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.read		= evdev_read,</span><br><span class="line">	.write		= evdev_write,</span><br><span class="line">	.poll		= evdev_poll,</span><br><span class="line">	.open		= evdev_open,</span><br><span class="line">	.release	= evdev_release,</span><br><span class="line">	.unlocked_ioctl	= evdev_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	.compat_ioctl	= evdev_ioctl_compat,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.fasync		= evdev_fasync,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="evdev-open"><a href="#evdev-open" class="headerlink" title="evdev_open()"></a>evdev_open()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 inode 的 i_cdev 成员中获取 evdev 结构体的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> evdev, cdev);</span><br><span class="line">    <span class="comment">// 计算缓冲区大小</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev);</span><br><span class="line">    <span class="comment">// 定义 evdev_client 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 分配内存用于存储 evdev_client 结构体和输入事件缓冲区</span></span><br><span class="line">	client = kvzalloc(struct_size(client, buffer, bufsize), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待队列初始化</span></span><br><span class="line">	init_waitqueue_head(&amp;client-&gt;wait);</span><br><span class="line">    <span class="comment">// 初始化 client 结构体的成员变量</span></span><br><span class="line">	client-&gt;bufsize = bufsize;</span><br><span class="line">	spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">	client-&gt;evdev = evdev;</span><br><span class="line">    <span class="comment">// 将 client 添加到 evdev 的客户端列表中</span></span><br><span class="line">	evdev_attach_client(evdev, client);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 打开底层设备</span></span><br><span class="line">	error = evdev_open_device(evdev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err_free_client;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将 client 结构体设置为文件的私有数据</span></span><br><span class="line">	file-&gt;private_data = client;</span><br><span class="line">    <span class="comment">// 使用stream_open打开,标记文件是no_seekable的，不支持随机访问</span></span><br><span class="line">	stream_open(inode, file);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_free_client:</span><br><span class="line">    <span class="comment">// 打开设备失败，需要进行错误处理，从 evdev 的客户端列表中移除 client</span></span><br><span class="line">	evdev_detach_client(evdev, client);</span><br><span class="line">    <span class="comment">// 释放 client 分配的内存</span></span><br><span class="line">	kvfree(client);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="stream-open"><a href="#stream-open" class="headerlink" title="stream_open()"></a>stream_open()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stream_open is used by subsystems that want stream-like file descriptors.</span></span><br><span class="line"><span class="comment"> * Such file descriptors are not seekable and don&#x27;t have notion of position</span></span><br><span class="line"><span class="comment"> * (file.f_pos is always 0 and ppos passed to .read()/.write() is always NULL).</span></span><br><span class="line"><span class="comment"> * Contrary to file descriptors of other regular files, .read() and .write()</span></span><br><span class="line"><span class="comment"> * can run simultaneously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stream_open never fails and is marked to return int so that it could be</span></span><br><span class="line"><span class="comment"> * directly used as file_operations.open .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;f_mode &amp;= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);</span><br><span class="line">	filp-&gt;f_mode |= FMODE_STREAM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(stream_open);</span><br></pre></td></tr></table></figure>

<h5 id="edev-open-device"><a href="#edev-open-device" class="headerlink" title="edev_open_device()"></a>edev_open_device()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_open_device</span><span class="params">(<span class="keyword">struct</span> evdev *evdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);<span class="comment">// 获取输入设备的互斥锁</span></span><br><span class="line">	<span class="keyword">if</span> (retval)<span class="comment">// 如果无法获取锁，函数将返回相应的错误码</span></span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!evdev-&gt;exist)<span class="comment">// 如果该字段为假（0），表示输入设备不存在</span></span><br><span class="line">		retval = -ENODEV;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!evdev-&gt;open++) &#123;</span><br><span class="line">		retval = input_open_device(&amp;evdev-&gt;handle);<span class="comment">// 调用 input_open_device 函数打开输入设备，并将返回值存储在 retval 变量中</span></span><br><span class="line">		<span class="keyword">if</span> (retval)<span class="comment">// 如果打开设备失败，函数会将 evdev-&gt;open 减一，表示设备的打开计数器递减</span></span><br><span class="line">			evdev-&gt;open--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;evdev-&gt;mutex); <span class="comment">// 释放输入设备的互斥锁</span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="input-open-device"><a href="#input-open-device" class="headerlink" title="input_open_device()"></a>input_open_device()</h5><p><code>evdev_open_device()</code>中调用 <code>input_open_device()</code> 函数打开输入设备。该函数会调用<code>input_dev</code>的 <code>open()</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_open_device - open input device</span></span><br><span class="line"><span class="comment"> * @handle: handle through which device is being accessed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be called by input handlers when they</span></span><br><span class="line"><span class="comment"> * want to start receive events from given input device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_open_device</span><span class="params">(<span class="keyword">struct</span> input_handle *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> handle-&gt;dev;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;going_away) &#123;</span><br><span class="line">		retval = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handle-&gt;open++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;users++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Device is already opened, so we can exit immediately and</span></span><br><span class="line"><span class="comment">		 * report success.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;open) &#123;</span><br><span class="line">		retval = dev-&gt;open(dev);</span><br><span class="line">		<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">			dev-&gt;users--;</span><br><span class="line">			handle-&gt;open--;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Make sure we are not delivering any more events</span></span><br><span class="line"><span class="comment">			 * through this handle</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			synchronize_rcu();</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;poller)</span><br><span class="line">		input_dev_poller_start(dev-&gt;poller);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_open_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h4 id="ioctl-函数分析"><a href="#ioctl-函数分析" class="headerlink" title="ioctl 函数分析"></a>ioctl 函数分析</h4><h5 id="evdev-ioctl"><a href="#evdev-ioctl" class="headerlink" title="evdev_ioctl()"></a>evdev_ioctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">evdev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 evdev_ioctl_handler 函数来处理 IO 控制操作，传递给它 file 指针，cmd 和</span></span><br><span class="line">    <span class="comment">// 类型转换后的 arg 作为参数。函数将 arg 转换为 void __user *类型，以便在用户空间和内核空</span></span><br><span class="line">    <span class="comment">// 间之间传递指针。函数将 evdev_ioctl_handler 的返回值作为自己的返回值，并将其直接返回给调用者</span></span><br><span class="line">	<span class="keyword">return</span> evdev_ioctl_handler(file, cmd, (<span class="type">void</span> __user *)arg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="evdev-ioctl-handler"><a href="#evdev-ioctl-handler" class="headerlink" title="evdev_ioctl_handler()"></a>evdev_ioctl_handler()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">evdev_ioctl_handler</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">				<span class="type">void</span> __user *p, <span class="type">int</span> compat_mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从文件结构获取指向 evdev_client 的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 从 evdev_client 获取指向 evdev 的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取 evdev 的互斥锁，如果无法获取则返回相应的错误码</span></span><br><span class="line">	retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 检查设备是否存在或者客户端是否已被撤销</span></span><br><span class="line">	<span class="keyword">if</span> (!evdev-&gt;exist || client-&gt;revoked) &#123;</span><br><span class="line">		retval = -ENODEV;<span class="comment">// 如果设备不存在或客户端已被撤销，则返回设备不存在的错误码</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用 evdev_do_ioctl 函数来执行实际的 IO 控制操作，并将返回值存储在 retval 变量中</span></span><br><span class="line">	retval = evdev_do_ioctl(file, cmd, p, compat_mode);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;evdev-&gt;mutex);<span class="comment">// 解锁 evdev 的互斥锁</span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="evdev-do-ioctl"><a href="#evdev-do-ioctl" class="headerlink" title="evdev_do_ioctl()"></a>evdev_do_ioctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">evdev_do_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			   <span class="type">void</span> __user *p, <span class="type">int</span> compat_mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> evdev-&gt;handle.dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> <span class="title">abs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_mask</span> <span class="title">mask</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ff_effect</span> <span class="title">effect</span>;</span></span><br><span class="line">	<span class="type">int</span> __user *ip = (<span class="type">int</span> __user *)p;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, t, u, v;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First we check for fixed-length commands */</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGVERSION:</span><br><span class="line">		<span class="keyword">return</span> put_user(EV_VERSION, ip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGID:</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(p, &amp;dev-&gt;id, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_id)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGREP:</span><br><span class="line">		<span class="keyword">if</span> (!test_bit(EV_REP, dev-&gt;evbit))</span><br><span class="line">			<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">		<span class="keyword">if</span> (put_user(dev-&gt;rep[REP_DELAY], ip))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (put_user(dev-&gt;rep[REP_PERIOD], ip + <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCSREP:</span><br><span class="line">		<span class="keyword">if</span> (!test_bit(EV_REP, dev-&gt;evbit))</span><br><span class="line">			<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">		<span class="keyword">if</span> (get_user(u, ip))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (get_user(v, ip + <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		input_inject_event(&amp;evdev-&gt;handle, EV_REP, REP_DELAY, u);</span><br><span class="line">		input_inject_event(&amp;evdev-&gt;handle, EV_REP, REP_PERIOD, v);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCRMFF:</span><br><span class="line">		<span class="keyword">return</span> input_ff_erase(dev, (<span class="type">int</span>)(<span class="type">unsigned</span> <span class="type">long</span>) p, file);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGEFFECTS:</span><br><span class="line">		i = test_bit(EV_FF, dev-&gt;evbit) ?</span><br><span class="line">				dev-&gt;ff-&gt;max_effects : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (put_user(i, ip))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGRAB:</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> evdev_grab(evdev, client);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> evdev_ungrab(evdev, client);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCREVOKE:</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> evdev_revoke(evdev, client, file);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGMASK: &#123;</span><br><span class="line">		<span class="type">void</span> __user *codes_ptr;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;mask, p, <span class="keyword">sizeof</span>(mask)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		codes_ptr = (<span class="type">void</span> __user *)(<span class="type">unsigned</span> <span class="type">long</span>)mask.codes_ptr;</span><br><span class="line">		<span class="keyword">return</span> evdev_get_mask(client,</span><br><span class="line">				      mask.type, codes_ptr, mask.codes_size,</span><br><span class="line">				      compat_mode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCSMASK: &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">void</span> __user *codes_ptr;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;mask, p, <span class="keyword">sizeof</span>(mask)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		codes_ptr = (<span class="type">const</span> <span class="type">void</span> __user *)(<span class="type">unsigned</span> <span class="type">long</span>)mask.codes_ptr;</span><br><span class="line">		<span class="keyword">return</span> evdev_set_mask(client,</span><br><span class="line">				      mask.type, codes_ptr, mask.codes_size,</span><br><span class="line">				      compat_mode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCSCLOCKID:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;i, p, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> evdev_set_clk_type(client, i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGKEYCODE:</span><br><span class="line">		<span class="keyword">return</span> evdev_handle_get_keycode(dev, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCSKEYCODE:</span><br><span class="line">		<span class="keyword">return</span> evdev_handle_set_keycode(dev, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCGKEYCODE_V2:</span><br><span class="line">		<span class="keyword">return</span> evdev_handle_get_keycode_v2(dev, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EVIOCSKEYCODE_V2:</span><br><span class="line">		<span class="keyword">return</span> evdev_handle_set_keycode_v2(dev, p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size = _IOC_SIZE(cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now check variable-length commands */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVIOC_MASK_SIZE(nr)	((nr) &amp; ~(_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line">	<span class="keyword">switch</span> (EVIOC_MASK_SIZE(cmd)) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGPROP</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">bits_to_user</span><span class="params">(dev-&gt;propbit, INPUT_PROP_MAX,</span></span><br><span class="line"><span class="params">				    size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGMTSLOTS</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">evdev_handle_mt_request</span><span class="params">(dev, size, ip)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGKEY</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_KEY, dev-&gt;key,</span></span><br><span class="line"><span class="params">					    KEY_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGLED</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_LED, dev-&gt;led,</span></span><br><span class="line"><span class="params">					    LED_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGSND</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_SND, dev-&gt;snd,</span></span><br><span class="line"><span class="params">					    SND_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGSW</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_SW, dev-&gt;sw,</span></span><br><span class="line"><span class="params">					    SW_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGNAME</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">str_to_user</span><span class="params">(dev-&gt;name, size, p)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGPHYS</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">str_to_user</span><span class="params">(dev-&gt;phys, size, p)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOCGUNIQ</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">str_to_user</span><span class="params">(dev-&gt;uniq, size, p)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="title function_">EVIOC_MASK_SIZE</span><span class="params">(EVIOCSFF)</span>:</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(input_ff_effect_from_user(p, size, &amp;effect))</span></span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		error = input_ff_upload(dev, &amp;effect, file);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (put_user(effect.id, &amp;(((<span class="keyword">struct</span> ff_effect __user *)p)-&gt;id)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Multi-number variable-length handlers */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_TYPE(cmd) != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_IOC_DIR(cmd) == _IOC_READ) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((_IOC_NR(cmd) &amp; ~EV_MAX) == _IOC_NR(EVIOCGBIT(<span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">			<span class="keyword">return</span> handle_eviocgbit(dev,</span><br><span class="line">						_IOC_NR(cmd) &amp; EV_MAX, size,</span><br><span class="line">						p, compat_mode);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((_IOC_NR(cmd) &amp; ~ABS_MAX) == _IOC_NR(EVIOCGABS(<span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">			t = _IOC_NR(cmd) &amp; ABS_MAX;</span><br><span class="line">			<span class="built_in">abs</span> = dev-&gt;absinfo[t];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(p, &amp;<span class="built_in">abs</span>, <span class="type">min_t</span>(<span class="type">size_t</span>,</span><br><span class="line">					size, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_absinfo))))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_IOC_DIR(cmd) == _IOC_WRITE) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((_IOC_NR(cmd) &amp; ~ABS_MAX) == _IOC_NR(EVIOCSABS(<span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">			t = _IOC_NR(cmd) &amp; ABS_MAX;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (copy_from_user(&amp;<span class="built_in">abs</span>, p, <span class="type">min_t</span>(<span class="type">size_t</span>,</span><br><span class="line">					size, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_absinfo))))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (size &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_absinfo))</span><br><span class="line">				<span class="built_in">abs</span>.resolution = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* We can&#x27;t change number of reserved MT slots */</span></span><br><span class="line">			<span class="keyword">if</span> (t == ABS_MT_SLOT)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Take event lock to ensure that we are not</span></span><br><span class="line"><span class="comment">			 * changing device parameters in the middle</span></span><br><span class="line"><span class="comment">			 * of event.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			spin_lock_irq(&amp;dev-&gt;event_lock);</span><br><span class="line">			dev-&gt;absinfo[t] = <span class="built_in">abs</span>;</span><br><span class="line">			spin_unlock_irq(&amp;dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中的这些命令解释如下</p>
<ul>
<li>EVIOCGVERSION: 获取去掉版本号</li>
<li>EVIOCGID：获取输入设备的 ID 信息</li>
<li>EVIOCSREP：获取按键重复设置</li>
<li>EVIOCGKEYCODE: 获取按键码</li>
<li>EVIOCGKEYCODE_V2: 获取按键映射表</li>
<li>EVIOCSKEYCODE：设置按键值</li>
<li>EVIOCSKEYCODE_V2：设置按键映射表</li>
<li>EVIOCGNAME(len)：获取设备名称</li>
<li>EVIOCGPHYS(len)：获取物理位置</li>
<li>EVIOCGUNIQ(len)：获取唯一标识符</li>
<li>EVIOCGPROP(len)：获取设备属性</li>
<li>EVIOCGMTSLOTS(len)：获取多点触控信息</li>
<li>EVIOCGKEY(len)：获取全局按键状态</li>
<li>EVIOCGLED(len)：获取所有 LED 状态</li>
<li>EVIOCGSND(len)：获取所有声音状态</li>
<li>EVIOCGSW(len)：获取所有开关状态</li>
<li>EVIOCGBIT(ev,len)：获取事件位图</li>
<li>EVIOCGABS(abs)：获取绝对值&#x2F;范围</li>
<li>EVIOCSABS(abs)：设置绝对值&#x2F;范围</li>
<li>EVIOCSFF：发送力反馈效果到力反馈设备</li>
<li>EVIOCRMFF：删除力反馈效果</li>
<li>EVIOCGEFFECTS：报告同时可播放的效果数量</li>
<li>EVIOCGRAB：占用&#x2F;释放输入设备</li>
<li>EVIOCREVOKE：撤销设备访问权限</li>
<li>EVIOCGMASK：检索当前事件掩码</li>
<li>EVIOCSMASK：设置事件掩码</li>
<li>EVIOCSCLOCKID：设置用于时间戳的时钟标识</li>
</ul>
<h4 id="poll-函数分析"><a href="#poll-函数分析" class="headerlink" title="poll 函数分析"></a>poll 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* No kernel lock - fine */</span></span><br><span class="line"><span class="type">static</span> <span class="type">__poll_t</span> <span class="title function_">evdev_poll</span><span class="params">(<span class="keyword">struct</span> file *file, poll_table *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件私有数据中的 evdev_client 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 获取 evdev_client 结构体中的 evdev 指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line">	<span class="type">__poll_t</span> mask;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将当前进程加入到等待队列中，等待 evdev-&gt;wait 的唤醒事件</span></span><br><span class="line">	poll_wait(file, &amp;client-&gt;wait, wait);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 检查 evdev-&gt;exist 和 client-&gt;revoked 的值</span></span><br><span class="line">	<span class="keyword">if</span> (evdev-&gt;exist &amp;&amp; !client-&gt;revoked)</span><br><span class="line">        <span class="comment">// 如果 evdev 存在且 client 未被撤销，设置 mask 为 EPOLLOUT | EPOLLWRNORM</span></span><br><span class="line">		mask = EPOLLOUT | EPOLLWRNORM;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，设置 mask 为 EPOLLHUP | EPOLLERR</span></span><br><span class="line">		mask = EPOLLHUP | EPOLLERR;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 检查 client 中的 packet_head 和 tail 的值</span></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;packet_head != client-&gt;tail)</span><br><span class="line">        <span class="comment">// 如果 packet_head 和 tail 不相等，设置 mask 为 mask | EPOLLIN | EPOLLRDNORM</span></span><br><span class="line">		mask |= EPOLLIN | EPOLLRDNORM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="fasync-函数分析"><a href="#fasync-函数分析" class="headerlink" title="fasync 函数分析"></a>fasync 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件私有数据中的 evdev_client 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 fasync_helper 函数来处理进程的异步通知</span></span><br><span class="line">	<span class="comment">// 该函数会根据 on 的值，将进程添加到或从异步通知的列表中</span></span><br><span class="line">	<span class="comment">// 并将通知相关的数据存储在 client-&gt;fasync </span></span><br><span class="line">	<span class="keyword">return</span> fasync_helper(fd, file, on, &amp;client-&gt;fasync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="llseek-函数分析"><a href="#llseek-函数分析" class="headerlink" title="llseek 函数分析"></a>llseek 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">loff_t</span> <span class="title function_">no_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> -ESPIPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>-ESPIPE</code> 作为返回值直接返回。这个函数的作用是阻止对设备文件执行 llseek 操作，也就是不允许通过改变文件位置指针来随机访问设备文件。</p>
<h4 id="release-函数分析"><a href="#release-函数分析" class="headerlink" title="release 函数分析"></a>release 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件私有数据中的 evdev_client 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 获取 evdev_client 结构体中的 evdev 指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 evdev 的互斥锁，确保对 evdev 的操作是原子的</span></span><br><span class="line">	mutex_lock(&amp;evdev-&gt;mutex);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 检查 evdev-&gt;exist 和 client-&gt;revoked 的值</span></span><br><span class="line">	<span class="keyword">if</span> (evdev-&gt;exist &amp;&amp; !client-&gt;revoked)</span><br><span class="line">        <span class="comment">// 如果 evdev 存在且 client 未被撤销，调用 input_flush_device 函数刷新设备的输入缓冲区</span></span><br><span class="line">		input_flush_device(&amp;evdev-&gt;handle, file);</span><br><span class="line">	<span class="comment">// 释放 evdev 的抢占状态，将客户端从抢占列表中移除</span></span><br><span class="line">	evdev_ungrab(evdev, client);</span><br><span class="line">    <span class="comment">// 解锁 evdev 的互斥锁</span></span><br><span class="line">	mutex_unlock(&amp;evdev-&gt;mutex);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 从 evdev 中分离并释放客户端</span></span><br><span class="line">	evdev_detach_client(evdev, client);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 释放客户端的事件掩码内存</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; EV_CNT; ++i)</span><br><span class="line">		bitmap_free(client-&gt;evmasks[i]);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 释放客户端的内存</span></span><br><span class="line">	kvfree(client);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 关闭 evdev 设备</span></span><br><span class="line">	evdev_close_device(evdev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据上报流程"><a href="#数据上报流程" class="headerlink" title="数据上报流程"></a>数据上报流程</h3><p>使用读函数来读取输入设备上报的数据时，驱动程序中的文件操作集会执行 <code>evdev_read</code> 函数。同样地，当我们使用写函数向输入设备写入数据时，驱动程序中的文件操作集会执行 <code>evdev_write</code> 函数。</p>
<p>设备输入层负责处理输入设备的数据，并将其传递给驱动程序。当输入设备上报数据时，设备输入层会接收到这些数据，并将其转发给注册的驱动程序。</p>
<h4 id="event-函数分析"><a href="#event-函数分析" class="headerlink" title="event 函数分析"></a>event 函数分析</h4><h5 id="input-event-1"><a href="#input-event-1" class="headerlink" title="input_event()"></a>input_event()</h5><p>上报事件时需要调用<code>input_event</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_event() - report new input event</span></span><br><span class="line"><span class="comment"> * @dev: device that generated the event</span></span><br><span class="line"><span class="comment"> * @type: type of the event</span></span><br><span class="line"><span class="comment"> * @code: event code</span></span><br><span class="line"><span class="comment"> * @value: value of the event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be used by drivers implementing various input</span></span><br><span class="line"><span class="comment"> * devices to report input events. See also input_inject_event().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> input_event() may be safely used right after input device was</span></span><br><span class="line"><span class="comment"> * allocated with input_allocate_device(), even before it is registered</span></span><br><span class="line"><span class="comment"> * with input_register_device(), but the event will not reach any of the</span></span><br><span class="line"><span class="comment"> * input handlers. Such early invocation of input_event() may be used</span></span><br><span class="line"><span class="comment"> * to &#x27;seed&#x27; initial state of a switch or initial position of absolute</span></span><br><span class="line"><span class="comment"> * axis, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">// 用于保存中断标志</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 检查输入设备是否支持指定的事件类型</span></span><br><span class="line">	<span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line">		<span class="comment">// 获取事件锁，确保对事件的处理是原子的</span></span><br><span class="line">		spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">        <span class="comment">// 调用 input_handle_event 函数处理输入事件</span></span><br><span class="line">		input_handle_event(dev, type, code, value);</span><br><span class="line">        <span class="comment">// 释放事件锁</span></span><br><span class="line">		spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_event);</span><br></pre></td></tr></table></figure>

<h5 id="input-handle-event"><a href="#input-handle-event" class="headerlink" title="input_handle_event()"></a>input_handle_event()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">input_handle_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取输入事件的处理方式, 即判断事件是应该被忽略、传递给设备还是传递给处理程序</span></span><br><span class="line">	<span class="type">int</span> disposition = input_get_disposition(dev, type, code, &amp;value);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果事件不应被忽略且不是 EV_SYN 类型的事件，则将事件的类型、代码和值添加到输入随机数池中</span></span><br><span class="line">	<span class="keyword">if</span> (disposition != INPUT_IGNORE_EVENT &amp;&amp; type != EV_SYN)</span><br><span class="line">		add_input_randomness(type, code, value);</span><br><span class="line">	<span class="comment">// 如果事件应该传递给设备且设备有事件处理函数，则调用事件处理函数</span></span><br><span class="line">	<span class="keyword">if</span> ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event)</span><br><span class="line">		dev-&gt;event(dev, type, code, value);</span><br><span class="line">	<span class="comment">// 如果输入设备没有值列表，则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;vals)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 如果事件应该传递给处理程序</span></span><br><span class="line">	<span class="keyword">if</span> (disposition &amp; INPUT_PASS_TO_HANDLERS) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果事件需要传递给处理程序的槽位，则将槽位信息添加到值列表中</span></span><br><span class="line">		<span class="keyword">if</span> (disposition &amp; INPUT_SLOT) &#123;</span><br><span class="line">			v = &amp;dev-&gt;vals[dev-&gt;num_vals++];</span><br><span class="line">			v-&gt;type = EV_ABS;</span><br><span class="line">			v-&gt;code = ABS_MT_SLOT;</span><br><span class="line">			v-&gt;value = dev-&gt;mt-&gt;slot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将事件的类型、代码和值添加到值列表中</span></span><br><span class="line">		v = &amp;dev-&gt;vals[dev-&gt;num_vals++];</span><br><span class="line">		v-&gt;type = type;</span><br><span class="line">		v-&gt;code = code;</span><br><span class="line">		v-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果事件需要刷新值列表</span></span><br><span class="line">	<span class="keyword">if</span> (disposition &amp; INPUT_FLUSH) &#123;</span><br><span class="line">        <span class="comment">// 如果值列表中的值大于等于 2，则传递值列表中的值给设备的处理函数</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;num_vals &gt;= <span class="number">2</span>)</span><br><span class="line">			input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">		dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Reset the timestamp on flush so we won&#x27;t end up</span></span><br><span class="line"><span class="comment">		 * with a stale one. Note we only need to reset the</span></span><br><span class="line"><span class="comment">		 * monolithic one as we use its presence when deciding</span></span><br><span class="line"><span class="comment">		 * whether to generate a synthetic timestamp.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 重置刷新时的时间戳，以避免出现过时的时间戳。</span></span><br><span class="line"><span class="comment">		* 注意，我们只需要重置单一时间戳（INPUT_CLK_MONO），</span></span><br><span class="line"><span class="comment">		* 因为在决定是否生成合成时间戳时，我们使用它的存在。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		dev-&gt;timestamp[INPUT_CLK_MONO] = ktime_set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;num_vals &gt;= dev-&gt;max_vals - <span class="number">2</span>) &#123;<span class="comment">// 如果值列表中的值大于等于设备的最大值减去 2</span></span><br><span class="line">        <span class="comment">// 将同步事件添加到值列表中</span></span><br><span class="line">		dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync;</span><br><span class="line">        <span class="comment">// 传递值列表中的值给设备的处理函数</span></span><br><span class="line">		input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">		dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="input-get-disposition"><a href="#input-get-disposition" class="headerlink" title="input_get_disposition()"></a>input_get_disposition()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_get_disposition</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> *pval)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> disposition = INPUT_IGNORE_EVENT;<span class="comment">// 事件的处理方式，默认为忽略</span></span><br><span class="line">	<span class="type">int</span> value = *pval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SYN:</span><br><span class="line">		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYN_CONFIG:</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYN_REPORT:</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS | INPUT_FLUSH;<span class="comment">// 将事件传递给处理程序，并刷新值列表</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SYN_MT_REPORT:</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS;<span class="comment">// 将事件传递给处理程序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_KEY:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;keybit, KEY_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* auto-repeat bypasses state updates */</span></span><br><span class="line">            <span class="comment">// 自动重复事件不更新状态，直接传递给处理程序</span></span><br><span class="line">			<span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">				disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 判断按键状态是否改变，若改变则更新状态并传递给处理程序</span></span><br><span class="line">			<span class="keyword">if</span> (!!test_bit(code, dev-&gt;key) != !!value) &#123;</span><br><span class="line"></span><br><span class="line">				__change_bit(code, dev-&gt;key);</span><br><span class="line">				disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SW:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;swbit, SW_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;sw) != !!value) &#123;</span><br><span class="line">			<span class="comment">// 判断开关状态是否改变，若改变则更新状态并传递给处理程序</span></span><br><span class="line">			__change_bit(code, dev-&gt;sw);</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_ABS:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;absbit, ABS_MAX))</span><br><span class="line">			disposition = input_handle_abs_event(dev, code, &amp;value);<span class="comment">// 处理绝对事件的特殊情况</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_REL:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;relbit, REL_MAX) &amp;&amp; value)</span><br><span class="line">			disposition = INPUT_PASS_TO_HANDLERS;<span class="comment">// 将事件传递给处理程序</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_MSC:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;mscbit, MSC_MAX))</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_LED:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;ledbit, LED_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;led) != !!value) &#123;</span><br><span class="line">			<span class="comment">// 判断 LED 状态是否改变，若改变则更新状态并传递给所有处理程序</span></span><br><span class="line">			__change_bit(code, dev-&gt;led);</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_SND:</span><br><span class="line">		<span class="keyword">if</span> (is_event_supported(code, dev-&gt;sndbit, SND_MAX)) &#123;</span><br><span class="line">			<span class="comment">// 判断声音状态是否改变，若改变则更新状态并传递给所有处理程序</span></span><br><span class="line">			<span class="keyword">if</span> (!!test_bit(code, dev-&gt;snd) != !!value)</span><br><span class="line">				__change_bit(code, dev-&gt;snd);</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_REP:</span><br><span class="line">		<span class="keyword">if</span> (code &lt;= REP_MAX &amp;&amp; value &gt;= <span class="number">0</span> &amp;&amp; dev-&gt;rep[code] != value) &#123;</span><br><span class="line">            <span class="comment">// 更新重复事件的设置，并将事件传递给所有处理程序</span></span><br><span class="line">			dev-&gt;rep[code] = value;</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_FF:</span><br><span class="line">		<span class="keyword">if</span> (value &gt;= <span class="number">0</span>)</span><br><span class="line">			disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EV_PWR:</span><br><span class="line">		disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pval = value; <span class="comment">// 将事件的值更新为处理后的值</span></span><br><span class="line">	<span class="keyword">return</span> disposition; <span class="comment">// 返回事件的处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数用于根据输入设备的类型、代码和值，确定事件的处理方式。首先，根据事件的类型进行分支判断。每个分支中会根据事件的类型和代码判断事件的处理方式，并相应地更新 disposition（事件的处理方式）。disposition 有以下几种方式</p>
<ul>
<li><code>INPUT_IGNORE_EVENT</code>：表示忽略该输入事件，不进行任何处理</li>
<li><code>INPUT_PASS_TO_HANDLERS</code> ：表示将输入事件传递给处理程序进行处理。处理程序可以是输入驱动程序中的回调函数，也可以是用户空间的应用程序或服务进程。</li>
<li><code>INPUT_PASS_TO_DEVICE</code> ：表示将输入事件传递给设备进行处理。设备可能包括物理设备（如键盘，鼠标）或虚拟设备（如触摸屏模拟器）。</li>
<li><code>INPUT_SLOT</code>：用于触摸屏模拟器，表示输入事件是触摸屏幕上的特定槽位的事件，通常，在处理多点触摸事件时，每个触点都对应一个槽位。</li>
<li><code>INPUT_FLUSH</code>：表示需要刷新输入事件队列。当输入事件队列积累到一定数量或满时，以使用此标志刷新队列，将事件传递给设备进行处理。</li>
<li><code>INPUT_PASS_TO_ALL</code> (<code>INPUT_PASS_TO_HANDLERS</code> | <code>INPUT_PASS_TO_DEVICE</code>)：表示将输入事件同时传递给处理程序和设备进行处理，即综合使用 <code>INPUT_PASS_TO_HANDLERS</code> 和 <code>INPUT_PASS_TO_DEVICE</code> 的功能。</li>
</ul>
<h5 id="input-pass-values"><a href="#input-pass-values" class="headerlink" title="input_pass_values()"></a>input_pass_values()</h5><p>该函数用于将输入设备的值传递给相应的句柄进行处理，并触发按键事件的自动重复。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass values first through all filters and then, if event has not been</span></span><br><span class="line"><span class="comment"> * filtered out, through all open handles. This function is called with</span></span><br><span class="line"><span class="comment"> * dev-&gt;event_lock held and interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">input_pass_values</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span><span class="comment">// 输入设备的句柄</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span><span class="comment">// 当前处理的值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">// 如果值的数量为 0，则直接返回</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();<span class="comment">// 读取 RCU 锁</span></span><br><span class="line"></span><br><span class="line">	handle = rcu_dereference(dev-&gt;grab);<span class="comment">// 获取设备的句柄</span></span><br><span class="line">	<span class="keyword">if</span> (handle) &#123;</span><br><span class="line">		count = input_to_handler(handle, vals, count);<span class="comment">// 将值传递给句柄进行处理，并更新值的数量</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历设备的句柄列表，将值传递给每个已打开的句柄进行处理，并更新值的数量</span></span><br><span class="line">		list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">			<span class="keyword">if</span> (handle-&gt;open) &#123;</span><br><span class="line">				count = input_to_handler(handle, vals, count);</span><br><span class="line">				<span class="keyword">if</span> (!count)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();<span class="comment">// 解锁 RCU 锁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* trigger auto repeat for key events */</span></span><br><span class="line">    <span class="comment">/* 触发按键事件的自动重复 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(EV_REP, dev-&gt;evbit) &amp;&amp; test_bit(EV_KEY, dev-&gt;evbit)) &#123;</span><br><span class="line">        <span class="comment">// 遍历值列表，对于类型为 EV_KEY 且值不为 2 的事件：</span></span><br><span class="line">        <span class="comment">// 如果值为真，则启动按键的自动重复；</span></span><br><span class="line">        <span class="comment">// 如果值为假，则停止按键的自动重复</span></span><br><span class="line">		<span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v-&gt;type == EV_KEY &amp;&amp; v-&gt;value != <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (v-&gt;value)</span><br><span class="line">					input_start_autorepeat(dev, v-&gt;code);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					input_stop_autorepeat(dev);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="input-to-handler"><a href="#input-to-handler" class="headerlink" title="input_to_handler()"></a>input_to_handler()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass event first through all filters and then, if event has not been</span></span><br><span class="line"><span class="comment"> * filtered out, through all open handles. This function is called with</span></span><br><span class="line"><span class="comment"> * dev-&gt;event_lock held and interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">input_to_handler</span><span class="params">(<span class="keyword">struct</span> input_handle *handle,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> =</span> handle-&gt;handler; <span class="comment">// 输入句柄对应的处理程序</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> =</span> vals; <span class="comment">// 已处理的值的末尾</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span> <span class="comment">// 当前处理的值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;filter) &#123;</span><br><span class="line">        <span class="comment">// 如果处理程序定义了过滤器函数，则对值列表中的每个值进行过滤</span></span><br><span class="line">		<span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (handler-&gt;filter(handle, v-&gt;type, v-&gt;code, v-&gt;value))</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">// 如果过滤器函数返回真，则跳过当前值</span></span><br><span class="line">			<span class="keyword">if</span> (end != v)</span><br><span class="line">				*end = *v;<span class="comment">// 将当前值复制到已处理的值的末尾</span></span><br><span class="line">			end++;</span><br><span class="line">		&#125;</span><br><span class="line">		count = end - vals;<span class="comment">// 更新处理后的值的数量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 如果处理后的值的数量为 0，则直接返回</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">		handler-&gt;events(handle, vals, count);<span class="comment">// 如果处理程序定义了事件处理函数，则将处理后的值传递给事件处理函数</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)<span class="comment">//// 如果处理程序定义了单个事件处理函数，则对每个值调用事件处理函数</span></span><br><span class="line">		<span class="keyword">for</span> (v = vals; v != vals + count; v++)</span><br><span class="line">			handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到：根据处理程序的定义，如果定义了事件处理函数（events 不为 NULL），它将处理后的值传递给事件处理函数。否则，如果只定义了单个事件处理函数（event 不为 NULL），它将对每个值调用事件处理函数，传递句柄、类型、代码和值作为参数。</p>
<h5 id="evdev-event"><a href="#evdev-event" class="headerlink" title="evdev_event()"></a>evdev_event()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evdev_event</span><span class="params">(<span class="keyword">struct</span> input_handle *handle,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] =</span> &#123; &#123; type, code, value &#125; &#125;;</span><br><span class="line"></span><br><span class="line">	evdev_events(handle, vals, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>edev_event</code>就是调用<code>evdev_events</code></p>
<h5 id="evdev-events"><a href="#evdev-events" class="headerlink" title="evdev_events()"></a>evdev_events()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass incoming events to all connected clients.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evdev_events</span><span class="params">(<span class="keyword">struct</span> input_handle *handle,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> handle-&gt;private;<span class="comment">// 获取输入句柄的私有数据，这里是 evdev 结构体类型</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span><span class="comment">// 定义 evdev 客户端指针</span></span><br><span class="line">	<span class="type">ktime_t</span> *ev_time = input_get_timestamp(handle-&gt;dev);<span class="comment">// 获取输入设备的时间戳</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();<span class="comment">// 开始读取 RCU 保护区域</span></span><br><span class="line"></span><br><span class="line">	client = rcu_dereference(evdev-&gt;grab);<span class="comment">// RCU 安全地获取当前的 evdev 客户端</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (client)<span class="comment">// 如果存在抢占的客户端，则将值传递给抢占的客户端</span></span><br><span class="line">		evdev_pass_values(client, vals, count, ev_time);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">			evdev_pass_values(client, vals, count, ev_time);<span class="comment">// 否则，将值传递给所有注册的客户端</span></span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();<span class="comment">// 结束读取 RCU 保护区域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="edev-pass-values"><a href="#edev-pass-values" class="headerlink" title="edev_pass_values()"></a>edev_pass_values()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evdev_pass_values</span><span class="params">(<span class="keyword">struct</span> evdev_client *client,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">			<span class="type">ktime_t</span> *ev_time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span><span class="comment">// 当前处理的输入值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span><span class="comment">// 输入事件结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts</span>;</span><span class="comment">// 时间戳</span></span><br><span class="line">	<span class="type">bool</span> wakeup = <span class="literal">false</span>;<span class="comment">// 是否需要唤醒等待线程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;revoked)</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">// 如果客户端已被撤销，则直接返回</span></span><br><span class="line"></span><br><span class="line">	ts = ktime_to_timespec64(ev_time[client-&gt;clk_type]);<span class="comment">// 将 ev_time 转换为 struct timespec64 类型的时间戳</span></span><br><span class="line">	event.input_event_sec = ts.tv_sec;<span class="comment">// 输入事件的秒字段设置为时间戳的秒值</span></span><br><span class="line">	event.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;<span class="comment">// 输入事件的微秒字段设置为时间戳的纳秒值除以 1000 得到的值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Interrupts are disabled, just acquire the lock. */</span></span><br><span class="line">    <span class="comment">/* 关中断，只需获取锁即可。 */</span></span><br><span class="line">	spin_lock(&amp;client-&gt;buffer_lock);<span class="comment">// 获取客户端的缓冲区锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (__evdev_is_filtered(client, v-&gt;type, v-&gt;code))</span><br><span class="line">			<span class="keyword">continue</span>;<span class="comment">// 如果输入值被过滤，则跳过当前值的处理</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">			<span class="comment">/* drop empty SYN_REPORT */</span></span><br><span class="line">            <span class="comment">/* 丢弃空的 SYN_REPORT */</span></span><br><span class="line">			<span class="keyword">if</span> (client-&gt;packet_head == client-&gt;head)</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">// 如果客户端的数据包头和数据头相同，则跳过当前值的处理</span></span><br><span class="line"></span><br><span class="line">			wakeup = <span class="literal">true</span>;<span class="comment">// 设置唤醒标志为真</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		event.type = v-&gt;type;<span class="comment">// 设置输入事件的类型字段为当前值的类型</span></span><br><span class="line">		event.code = v-&gt;code;<span class="comment">// 设置输入事件的代码字段为当前值的代码</span></span><br><span class="line">		event.value = v-&gt;value;<span class="comment">// 设置输入事件的值字段为当前值的值</span></span><br><span class="line">		__pass_event(client, &amp;event);<span class="comment">// 将输入事件传递给客户端的事件处理函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;client-&gt;buffer_lock);<span class="comment">// 释放客户端的缓冲区锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wakeup)<span class="comment">// 如果需要唤醒等待线程，则唤醒等待队列中的线程</span></span><br><span class="line">		wake_up_interruptible_poll(&amp;client-&gt;wait,</span><br><span class="line">			EPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="pass-event"><a href="#pass-event" class="headerlink" title="__pass_event()"></a>__pass_event()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __pass_event(<span class="keyword">struct</span> evdev_client *client,</span><br><span class="line">			 <span class="type">const</span> <span class="keyword">struct</span> input_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	client-&gt;buffer[client-&gt;head++] = *event;<span class="comment">// 将事件复制到客户端的缓冲区中，然后将缓冲区头指针递增</span></span><br><span class="line">	client-&gt;head &amp;= client-&gt;bufsize - <span class="number">1</span>; <span class="comment">// 将缓冲区头指针掩码处理，确保其在缓冲区范围内</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(client-&gt;head == client-&gt;tail)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This effectively &quot;drops&quot; all unconsumed events, leaving</span></span><br><span class="line"><span class="comment">		 * EV_SYN/SYN_DROPPED plus the newest event in the queue.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 这实际上&quot;丢弃&quot;了所有未消耗的事件，只保留了 EV_SYN/SYN_DROPPED 加上最新的事件。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		client-&gt;tail = (client-&gt;head - <span class="number">2</span>) &amp; (client-&gt;bufsize - <span class="number">1</span>);<span class="comment">// 更新缓冲区尾指针，使其指向倒数第二个事件</span></span><br><span class="line"></span><br><span class="line">		client-&gt;buffer[client-&gt;tail] = (<span class="keyword">struct</span> input_event) &#123;</span><br><span class="line">			.input_event_sec = event-&gt;input_event_sec,</span><br><span class="line">			.input_event_usec = event-&gt;input_event_usec,</span><br><span class="line">			.type = EV_SYN,</span><br><span class="line">			.code = SYN_DROPPED,</span><br><span class="line">			.value = <span class="number">0</span>,</span><br><span class="line">		&#125;;<span class="comment">// 在缓冲区尾指针位置插入一个 EV_SYN/SYN_DROPPED 事件，表示丢弃了事件</span></span><br><span class="line"></span><br><span class="line">		client-&gt;packet_head = client-&gt;tail;<span class="comment">// 更新数据包头指针为缓冲区尾指针</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (event-&gt;type == EV_SYN &amp;&amp; event-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">		client-&gt;packet_head = client-&gt;head;<span class="comment">// 更新数据包头指针为缓冲区头指针</span></span><br><span class="line">		kill_fasync(&amp;client-&gt;fasync, SIGIO, POLL_IN);<span class="comment">// 向注册的异步通知处理函数发送 SIGIO 信号，通知有新的事件可读取</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="read-函数分析"><a href="#read-函数分析" class="headerlink" title="read 函数分析"></a>read 函数分析</h4><p>驱动程序可以通过注册到设备输入层的回调函数来获取输入设备上报的数据。在驱动程序中，<code>evdev_read</code> 函数就是用于从设备输入层获取输入设备上报的数据的函数。</p>
<h5 id="edev-read"><a href="#edev-read" class="headerlink" title="edev_read()"></a>edev_read()</h5><p><code>edev_read()</code>从 evdev 设备读取输入事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">evdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">			  <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 获取文件私有数据中的 evdev 客户端结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;<span class="comment">// 获取客户端结构体中的 evdev 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span><span class="comment">// 定义一个输入事件结构体</span></span><br><span class="line">	<span class="type">size_t</span> read = <span class="number">0</span>;<span class="comment">// 已读取的字节数</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; count &lt; input_event_size())</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;<span class="comment">// 如果 count 不为 0 且小于输入事件大小，返回无效参数错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环读取输入事件并将其复制到用户空间缓冲区中</span></span><br><span class="line">		<span class="keyword">if</span> (!evdev-&gt;exist || client-&gt;revoked)</span><br><span class="line">			<span class="keyword">return</span> -ENODEV;<span class="comment">// 如果 evdev 设备不存在或客户端已撤销，则返回设备不存在错误码</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (client-&gt;packet_head == client-&gt;tail &amp;&amp;</span><br><span class="line">		    (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;<span class="comment">// 如果数据包头等于尾且文件标志中设置了非阻塞标志，返回暂无数据可读错误码</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * count == 0 is special - no IO is done but we check</span></span><br><span class="line"><span class="comment">		 * for error conditions (see above).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">0</span>)<span class="comment">// 如果 count 为 0，退出循环，不执行 IO 操作，但仍检查错误条件</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (read + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">		       evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (input_event_to_user(buffer + read, &amp;event))<span class="comment">// 将输入事件数据复制到用户空间缓冲区中</span></span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">			read += input_event_size();<span class="comment">// 更新已读取的字节数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (read)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">// 如果已读取的字节数大于 0，退出循环</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">			error = wait_event_interruptible(client-&gt;wait,</span><br><span class="line">					client-&gt;packet_head != client-&gt;tail ||</span><br><span class="line">					!evdev-&gt;exist || client-&gt;revoked);<span class="comment">// 等待事件的发生，阻塞当前线程</span></span><br><span class="line">			<span class="keyword">if</span> (error)</span><br><span class="line">				<span class="keyword">return</span> error;<span class="comment">// 如果等待被中断，返回错误码</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> read;<span class="comment">// 返回已读取的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="write-函数分析"><a href="#write-函数分析" class="headerlink" title="write 函数分析"></a>write 函数分析</h4><p>当我们在应用程序中使用写函数向输入设备写入数据时，输入数据会被传递到驱动程序的 <code>evdev_write</code> 函数。驱动程序可以根据需要对这些写入的数据进行处理和响应。</p>
<h5 id="edev-write"><a href="#edev-write" class="headerlink" title="edev_write()"></a>edev_write()</h5><p>该函数将输入事件写入到 evdev 设备的缓冲区中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">evdev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">			   <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 获取文件私有数据中的 evdev 客户端结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;<span class="comment">// 获取客户端结构体中的 evdev 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span><span class="comment">// 定义一个输入事件结构体</span></span><br><span class="line">	<span class="type">int</span> retval = <span class="number">0</span>;<span class="comment">// 返回值变量，默认为 0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; count &lt; input_event_size())</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;<span class="comment">// 如果 count 不为 0 且小于输入事件大小，返回无效参数错误</span></span><br><span class="line"></span><br><span class="line">	retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);<span class="comment">// 对 evdev 的互斥锁进行上锁，可中断</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;<span class="comment">// 如果上锁失败，返回错误码</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!evdev-&gt;exist || client-&gt;revoked) &#123;<span class="comment">// 如果 evdev 设备不存在或客户端已撤销，则返回设备不存在的错误码</span></span><br><span class="line">		retval = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (retval + input_event_size() &lt;= count) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (input_event_from_user(buffer + retval, &amp;event)) &#123;<span class="comment">// 从用户空间复制输入事件到 event 结构体中</span></span><br><span class="line">			retval = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		retval += input_event_size();<span class="comment">// 更新 retval，增加一个输入事件的大小</span></span><br><span class="line"></span><br><span class="line">		input_inject_event(&amp;evdev-&gt;handle,</span><br><span class="line">				   event.type, event.code, event.value);<span class="comment">// 将输入事件注入到evdev 事件处理器中</span></span><br><span class="line">		cond_resched();<span class="comment">// 条件调度，让出 CPU 给其他线程执行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;evdev-&gt;mutex);<span class="comment">// 解锁 evdev 的互斥锁</span></span><br><span class="line">	<span class="keyword">return</span> retval;<span class="comment">// 返回 retval 作为写入的字节数或错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="核心层代码分析"><a href="#核心层代码分析" class="headerlink" title="核心层代码分析"></a>核心层代码分析</h2><p>输入子系统的核心层主要由 <code>kernel/drivers/input/input.c</code> 文件实现的，它是 Linux 内核中处理输入设备的关键组件之一。input.c 文件负责注册，管理和处理输入设备，提供与输入设备相关的核心功能和接口。</p>
<p>核心层的主要作用如下：</p>
<ol>
<li><strong>设备注册和管理</strong>：核心层负责注册和管理输入设备。它通过与设备驱动程序进行交互，将输入设备与相应的驱动程序进行匹配，并创建与设备相关的数据结构。这些数据结构包含设备的状态，属性和操作函数等信息。</li>
<li><strong>事件处理</strong>：核心层负责处理输入设备产生的事件。当输入设备发生触摸，按键或其他操作时，核心层会收到相应的事件数据，并进行处理。它将事件数据传递给上层应用程序或其他子系统，以便实现相应的交互操作。</li>
<li><strong>事件分发</strong>：核心层负责将事件分发给注册了对应设备的应用程序或子系统。它根据设备的类型和属性，将事件传递给相应的处理程序。这样，应用程序或子系统就可以根据事件类型来执行相应的操作，例如处理触摸事件，响应按键输入等。</li>
<li><strong>设备节点管理</strong>：核心层负责创建和管理输入设备的设备节点。设备节点通常位于<code>/dev/input</code>目录下，提供了对输入设备的访问接口。核心层会根据设备的类型和属性，在设备节点中创建相应的信息，并确保设备节点的正确性和一致性。</li>
<li><strong>设备驱动程序的接口</strong>：核心层为设备驱动程序提供了接口，使其可以与输入子系统进行交互。驱动程序可以通过注册回调函数等方式，与核心层进行通信和数据交换，实现了输入设备的初始化，事件处理等功能。</li>
</ol>
<h3 id="input-init"><a href="#input-init" class="headerlink" title="input_init()"></a>input_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivesr/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = class_register(&amp;input_class);<span class="comment">// 尝试注册 input_dev 类</span></span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register input_dev class\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = input_proc_init();<span class="comment">// 初始化输入子系统的 proc 文件系统接口。这个接口用于在/proc 文件系统中提供有关输入设备的信息</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">	err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">				     INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail2:	input_proc_exit();</span><br><span class="line"> fail1:	class_unregister(&amp;input_class);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">input_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	input_proc_exit();</span><br><span class="line">	unregister_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">				 INPUT_MAX_CHAR_DEVICES);</span><br><span class="line">	class_unregister(&amp;input_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(input_init);<span class="comment">// 在内核启动时被调用</span></span><br><span class="line">module_exit(input_exit);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="input-proc-init"><a href="#input-proc-init" class="headerlink" title="input_proc_init()"></a>input_proc_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">	proc_bus_input_dir = proc_mkdir(<span class="string">&quot;bus/input&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// 创建一个名为”bus/input”的目录，表示输入设备的总线类型</span></span><br><span class="line">	<span class="keyword">if</span> (!proc_bus_input_dir)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	entry = proc_create(<span class="string">&quot;devices&quot;</span>, <span class="number">0</span>, proc_bus_input_dir,</span><br><span class="line">			    &amp;input_devices_proc_ops);<span class="comment">//创建一个名 为 “ device”的文件，并将其与之前创建的“bus/input”目录相关联 </span></span><br><span class="line">	<span class="keyword">if</span> (!entry)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">	entry = proc_create(<span class="string">&quot;handlers&quot;</span>, <span class="number">0</span>, proc_bus_input_dir,</span><br><span class="line">			    &amp;input_handlers_proc_ops);<span class="comment">//创建一个名为&quot;handlers&quot;的文件，并将其与&quot;bus/input&quot;目录相关联。</span></span><br><span class="line">	<span class="keyword">if</span> (!entry)</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail2:	remove_proc_entry(<span class="string">&quot;devices&quot;</span>, proc_bus_input_dir);</span><br><span class="line"> fail1: remove_proc_entry(<span class="string">&quot;bus/input&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="固定输入设备的设备节点"><a href="#固定输入设备的设备节点" class="headerlink" title="固定输入设备的设备节点"></a>固定输入设备的设备节点</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在进行嵌入式 Linux 开发时，不同厂家和型号的外设在内核启动时加载的顺序可能会不同。例如，触摸板和 USB 转串口等设备，这会导致在<code>/dev/input</code> 目录下创建的 evdevx 节点（其中 x&#x3D;0,1,2,3…）不同。然而应用程序通常打开的是固定的设备节点，如果设备节点发生变化，就会导致应用程序打开错误的设备节点，因此，需要对输入设备创建的设备节点进行固定。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过分析 evdev.c 驱动程序，我们确定<strong>设备节点是在 <code>evdev_connect</code> 函数中创建的</strong>。因此，只需要<strong>在 <code>evdev_connect</code> 函数中针对需要固定设备节点的设备单独创建一个设备节点即可</strong>。</p>
<p>首先确定想要固定设备节点的设备名称，使用 <code>cat /proc/bus/input/devices</code> 命令找到设备名称。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195254121.png" alt="goodix-ts" loading="lazy"></p>
<p>修改 <code>evdev_connect 函数</code>，根据设备名称来判断是否为想要固定的那个节点的名称，然后使用 <code>dev_set_name</code> 函数来固定设备节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195257393.png" alt="connect函数" loading="lazy"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195300720.png" alt="&#x2F;dev&#x2F;input&#x2F;" loading="lazy"></p>
<h2 id="固定USB设备的设备节点"><a href="#固定USB设备的设备节点" class="headerlink" title="固定USB设备的设备节点"></a>固定USB设备的设备节点</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>在 Linux 系统中，当使用多个 USB 转串口设备时，经常会遇到插拔 USB 转串口的顺序变化导致设备节点不稳定的情况。为了解决这个问题，我们可以通过使用 udev 来固定设备节点，以确保设备节点不受 USB 转串口插拔顺序的影响</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>插入USB设备：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info -a -n /dev/ttyUSB0</span><br></pre></td></tr></table></figure>



<p><code>udevadm info -a -n /dev/ttyUSB0</code> 是一个用于获取有关特定设备节点的详细信息的命令，包括设备的属性、驱动程序、设备路径等。这些命令的参数含义如下所示：</p>
<ul>
<li><code>-a</code>：显示与指定设备节点相关联的所有属性。</li>
<li><code>-n</code>：指定设备节点的路径或名称。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195304678.png" alt="udevadm info -a -n &#x2F;dev&#x2F;ttyUSB0" loading="lazy"></p>
<p>这个命令的输出可能会包含以下信息:</p>
<ol>
<li>设备路径（DEVPATH）：设备在系统中的路径，例如<code>/devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/ttyUSB0/tty/ttyUSB0</code>。</li>
<li>设备节点（DEVNAME）：设备在文件系统中的节点，即<code>/dev/ttyUSB0</code>。</li>
<li>设备的属性（Device Attributes）：包括设备的供应商 ID、产品 ID、序列号等信息。</li>
<li>设备的驱动程序（Device Driver）：设备所使用的驱动程序的名称和路径。</li>
<li>设备类型（SUBSYSTEM）：usb</li>
</ol>
<p>接下来在开发板的 <code>etc/udev/rules.d/</code>目录下，创建一个名为 001.rules 的规则文件:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">KERNELS</span>==”<span class="number">5</span>-<span class="number">1</span>:<span class="number">1</span>.<span class="number">0</span>”,SUBSYSTEMS==”usb”,MODE:=”<span class="number">0777</span>”,SYMLINK+=”myusb”</span><br></pre></td></tr></table></figure>

<ol>
<li><code>KERNELS==&quot;5-1:1.0&quot;</code></li>
</ol>
<ul>
<li>匹配设备的 <strong>内核设备名（Kernel Device Name）</strong></li>
<li><code>5-1:1.0</code> 是 USB 设备在内核中的路径标识：<ul>
<li><code>5</code>: USB 总线号（Bus）</li>
<li><code>1</code>: USB 设备号（Device）</li>
<li><code>1.0</code>: 接口编号（Interface），表示第 1 个接口的第 0 个端点</li>
</ul>
</li>
<li>这个值来自 <code>udevadm info</code> 输出中的 <code>KERNELS</code> 字段</li>
</ul>
<hr>
<ol start="2">
<li><code>SUBSYSTEMS==&quot;usb&quot;</code></li>
</ol>
<ul>
<li>匹配设备所属的 <strong>子系统（Subsystem）</strong></li>
<li>表示这是一个 USB 类型的设备</li>
<li>可以用来过滤所有 USB 设备</li>
</ul>
<hr>
<ol start="3">
<li><code>MODE:=&quot;0777&quot;</code></li>
</ol>
<ul>
<li>设置该设备文件的 <strong>权限（mode）</strong></li>
<li><code>0777</code> 表示：<ul>
<li>所有用户（root、普通用户、其他用户）都拥有读、写、执行权限</li>
<li>即：<code>rwxrwxrwx</code></li>
</ul>
</li>
<li>这样任何程序都可以直接访问该设备（如 <code>/dev/ttyUSB0</code>）</li>
</ul>
<blockquote>
<p>⚠️ 注意：<code>MODE</code> 前面是 <code>:=</code>，不是 <code>==</code>。<code>:=</code> 表示“赋值”，而 <code>==</code> 是“匹配”。</p>
</blockquote>
<hr>
<ol start="4">
<li><code>SYMLINK+=&quot;myusb&quot;</code></li>
</ol>
<ul>
<li>为设备创建一个 <strong>符号链接（symbolic link）</strong></li>
<li>比如原本设备是 <code>/dev/ttyUSB0</code>，现在会多一个软链接：<code>/dev/myusb -&gt; /dev/ttyUSB0</code></li>
<li>可以用 <code>myusb</code> 来代替 <code>ttyUSB0</code>，更方便命名和脚本调用</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195322984.png" alt="效果" loading="lazy"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/2512183/">https://even629.com/posts/2512183/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><div class="post-share"><div class="social-share" data-image="/images/linux_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center liquidGlass-wrapper" id="my-custom-card-author"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status">🐟<span>认真摸鱼中</span></div></div></div><div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" target="_blank" title="github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" target="_blank" title="email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com/519280138" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="rss"><i class="fas fa-rss" style="color: #000000;"></i></a></div></div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"> <div class="newYear-slider"> <div class="swiper-wrapper"> <div class="swiper-slide" style="background-image:url(/img/happy_new_year1.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year2.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year3.webp)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year4.gif)"></div> </div> </div> <div id="newYear-main"> <div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div> </div></div><div class="sticky_layout"><div class="card-widget liquidGlass-wrapper" id="card-toc"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text">输入子系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%E5%92%8C%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">如何确定输入设备和节点之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-text">输入子系统框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">输入子系统数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#input-register-handler"><span class="toc-text">input_register_handler()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-handler-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">input_handler 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-attach-handler"><span class="toc-text">input_attach_handler()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-match-device"><span class="toc-text">input_match_device()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#input-match-device-id"><span class="toc-text">input_match_device_id()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-dev-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">input_dev 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-handle-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">input_handle 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#evdev-connect"><span class="toc-text">evdev_connect()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-register-handle"><span class="toc-text">input_register_handle()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-register-device"><span class="toc-text">input_register_device()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-text">数据结构关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81"><span class="toc-text">输入子系统源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%B1%82%E4%BB%A3%E7%A0%81"><span class="toc-text">编写最简单的设备驱动层代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-allocate-device"><span class="toc-text">input_allocate_device()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96input-dev%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">初始化input_dev结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">设置事件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-text">设置具体类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">分析匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#input-attach-handler-1"><span class="toc-text">input_attach_handler()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-match-device-1"><span class="toc-text">input_match_device()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-match-device-id-1"><span class="toc-text">input_match_device_id()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%8C%B9%E9%85%8D%E5%88%86%E6%9E%90"><span class="toc-text">多对多匹配分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%B1%82%E4%BB%A3%E7%A0%81"><span class="toc-text">完善设备驱动层代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E4%BA%8B%E4%BB%B6"><span class="toc-text">上报事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E5%87%BD%E6%95%B0"><span class="toc-text">上报函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#input-report-key"><span class="toc-text">input_report_key()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#input-report-rel"><span class="toc-text">input_report_rel()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#input-report-abs"><span class="toc-text">input_report_abs()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#input-report-ff-status"><span class="toc-text">input_report_ff_status()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#input-report-switch"><span class="toc-text">input_report_switch()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#input-sync"><span class="toc-text">input_sync()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#input-event"><span class="toc-text">input_event()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">补充说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8A%E6%8A%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">应用层获取上报数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#input-event-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">input_event 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text">上报数据格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%B1%82-evdev"><span class="toc-text">通用事件处理层 evdev</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#connect-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">connect 函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#evdev-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">evdev 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#evdev-client-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">evdev_client 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#evdev-connect-1"><span class="toc-text">evdev_connect()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%88%86%E6%9E%90"><span class="toc-text">分配设备号分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-text">主设备号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A1%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-text">次设备号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#input-get-new-minor"><span class="toc-text">input_get_new_minor()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-text">文件操作集函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">open 函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#evdev-open"><span class="toc-text">evdev_open()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stream-open"><span class="toc-text">stream_open()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#edev-open-device"><span class="toc-text">edev_open_device()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#input-open-device"><span class="toc-text">input_open_device()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ioctl-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">ioctl 函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#evdev-ioctl"><span class="toc-text">evdev_ioctl()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#evdev-ioctl-handler"><span class="toc-text">evdev_ioctl_handler()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#evdev-do-ioctl"><span class="toc-text">evdev_do_ioctl()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">poll 函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fasync-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">fasync 函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#llseek-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">llseek 函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#release-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">release 函数分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8A%E6%8A%A5%E6%B5%81%E7%A8%8B"><span class="toc-text">数据上报流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#event-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">event 函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#input-event-1"><span class="toc-text">input_event()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#input-handle-event"><span class="toc-text">input_handle_event()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#input-get-disposition"><span class="toc-text">input_get_disposition()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#input-pass-values"><span class="toc-text">input_pass_values()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#input-to-handler"><span class="toc-text">input_to_handler()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#evdev-event"><span class="toc-text">evdev_event()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#evdev-events"><span class="toc-text">evdev_events()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#edev-pass-values"><span class="toc-text">edev_pass_values()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pass-event"><span class="toc-text">__pass_event()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">read 函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#edev-read"><span class="toc-text">edev_read()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">write 函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#edev-write"><span class="toc-text">edev_write()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B1%82%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">核心层代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#input-init"><span class="toc-text">input_init()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input-proc-init"><span class="toc-text">input_proc_init()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%E7%9A%84%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-text">固定输入设备的设备节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-text">需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9AUSB%E8%AE%BE%E5%A4%87%E7%9A%84%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-text">固定USB设备的设备节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82-1"><span class="toc-text">需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-1"><span class="toc-text">解决方法</span></a></li></ol></li></ol></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a target="_blank" rel="noopener" href="https://github.com/even629" title="github"><i class="fab fa-github"></i></a><a href="/img/qq.jpg" title="qq"><i class="fa-brands fa-qq"></i></a><a href="mailto:zhaohang731005515@proton.me" title="email"><i class="fas fa-envelope"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/519280138" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a href="/atom.xml" title="rss"><i class="fas fa-rss"></i></a></div><div class="copyright">&copy;2024 - 2026 By even629</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Frame-Hexo-blue.svg" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Theme-Butterfly.svg" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Source-Github.svg" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Copyright-BY--NC--SA.4.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"> </span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.stopSakura();"><i class="fa-solid fa-feather"></i><span data-zh="樱花特效" data-en="toggle sakura"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'e67f9103d5765ba6f7a83037f889d509'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.js"></script><script src="/js/sakura.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/solarlunar.js"></script><script src="/js/newYear.js"></script><script src="/js/pop-up-window.js"></script><script data-pjax src="/js/nav.js"></script><script data-pjax src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><svg style="display: none">
<filter
  id="glass-distortion"
  x="0%"
  y="0%"
  width="100%"
  height="100%"
  filterUnits="objectBoundingBox"
>
  <feTurbulence
    type="fractalNoise"
    baseFrequency="0.01 0.01"
    numOctaves="1"
    seed="5"
    result="turbulence"
  />
  <!-- Seeds: 14, 17,  -->

  <feComponentTransfer in="turbulence" result="mapped">
    <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
    <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
    <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
  </feComponentTransfer>

  <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />

  <feSpecularLighting
    in="softMap"
    surfaceScale="5"
    specularConstant="1"
    specularExponent="100"
    lighting-color="white"
    result="specLight"
  >
    <fePointLight x="-200" y="-200" z="300" />
  </feSpecularLighting>

  <feComposite
    in="specLight"
    operator="arithmetic"
    k1="0"
    k2="1"
    k3="1"
    k4="0"
    result="litImage"
  />

  <feDisplacementMap
    in="SourceGraphic"
    in2="softMap"
    scale="150"
    xChannelSelector="R"
    yChannelSelector="G"
  />
  </filter>
</svg>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr class="custom-hr"/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4847823_upluhme7cv.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><!-- hexo injector body_end end --></body></html>