<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux SPI | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux SPI">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux SPI">
<meta property="og:url" content="https://even629.com/posts/2512303/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="Linux SPI">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/linux_cover.webp">
<meta property="article:published_time" content="2025-12-30T06:35:13.000Z">
<meta property="article:modified_time" content="2025-12-30T06:35:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/linux_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/2512303/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: even629","link":"链接: ","source":"来源: 常想一二，不思八九","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux SPI',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.png', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom_card_author.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/newYear.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/beautify_label_h.css"><link rel="stylesheet" href="/css/equipment.css"><link rel="stylesheet" href="/css/liquid_glass.css"><link rel="stylesheet" href="/css/tag_plugin_plus.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="常想一二，不思八九" type="application/atom+xml">
</head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/linux_top_image.jpg);"><nav class="liquidGlass-wrapper" id="nav" style="--glass-border-radius: 2rem;"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box" style="display:flex;align-items:center;justify-content:center;width:100%"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" alt="Logo"></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 菜单项--><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><!-- 显示当前标题名称--><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">常想一二，不思八九</a></center></div></div><!-- 右侧功能区域（新增容器）--><div id="nav-right-container"><!-- 搜索按钮（移动到右侧）--><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><!-- 移动端汉堡菜单按钮--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux SPI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-30T06:35:13.000Z" title="发表于 2025-12-30 14:35:13">2025-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-30T06:35:13.000Z" title="更新于 2025-12-30 14:35:13">2025-12-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2512303/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-30</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>

<hr>
<h1 id="SPI基础"><a href="#SPI基础" class="headerlink" title="SPI基础"></a>SPI基础</h1><h2 id="SPI特点"><a href="#SPI特点" class="headerlink" title="SPI特点"></a>SPI特点</h2><p>SPI（Serial Peripheral Interface）最初是由摩托罗拉公司在上世纪 80 年代末期提出和开发的一种串行通信协议。当时,随着微控制器技术的发展,越来越多的外围设备需要与微控制器进行数据交换。</p>
<p>但传统的并行总线接口存在着引脚数量多、接线麻烦、功耗高等问题,不太适合嵌入式系统的需求。</p>
<p>为此,摩托罗拉公司设计了 SPI 这种简单高效的串行通信总线协议,以解决当时嵌入式系统中通信接口的痛点。SPI 的核心设计思路如下:</p>
<ul>
<li><p><strong>使用最少的引脚数实现全双工通信</strong></p>
<ul>
<li><p><strong>单工通信</strong>： 指信号只在一个方向上传输，仅能发送或接收</p>
</li>
<li><p><strong>半双工通信</strong>：信号可以在俩个方向上传输，但某一个时刻只允许发送或接收(单总线和 I2C 都是半双工通信)</p>
</li>
<li><p><strong>全双工通信</strong>：全双工通信指数据同时在两个方向上传输，SPI 只需要 4 根信号线(<strong>SCLK、MOSI、MISO、CS</strong>)即可完成主从设备之间的数据交换，实现全双工通信。这大大减少了引脚数,简化了接线。</p>
</li>
</ul>
</li>
<li><p><strong>采用同步通信机制</strong></p>
<ul>
<li><p><strong>同步通信</strong>: <strong>指数据传输的发送方和接收方使用相同的时钟信号进行协调</strong>。每<strong>个时钟周期都会发送或接收一个数据位</strong>，因此，数据传输严格依赖于时钟信号的节奏。</p>
</li>
<li><p><strong>异步通信</strong>: <strong>不依赖一个共同的时钟信号进行数据传输</strong>，发送方和接收方独立运行，通过特定的协议进行数据同步，具体示意图如下所示：</p>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143841712.png" alt="并行通信与串行通信" loading="lazy"></p>
<ul>
<li><p><strong>主从结构设计</strong>: SPI 协议将通信设备分为主设备和从设备</p>
<ul>
<li>主设备负责<strong>提供时钟信号和控制通信过程</strong></li>
<li>从设备<strong>被动响应主设备的操作。</strong></li>
</ul>
</li>
<li><p><strong>支持多从设备接入</strong>: SPI 有多种连接模式，主要分为常规模式和菊花链模式（菊花链模式不常用），</p>
<ul>
<li><p>在<strong>常规模式</strong>下，每个从设备（Slave）都有独立的片选（Chip Select, CS）信号线。主设备（Master）通过拉低相应的 CS 线来选择从设备进行通信，具体示意图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143854714.png" alt="常规模式" loading="lazy"></p>
</li>
<li><p><strong>菊花链模式</strong>下，<wavy>从设备会串联在一起</wavy>，数据从主设备传输到第一个从设备，然后从第一个从设备传输到下一个，从而形成链式结构，具体连接示意图如下所示：</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143907231.png" alt="菊花链模式" loading="lazy"></p>
</li>
</ul>
<h2 id="SPI硬件连接"><a href="#SPI硬件连接" class="headerlink" title="SPI硬件连接"></a>SPI硬件连接</h2><p> SPI 使用 4 根信号线进行通信,分别是 <strong>SCLK</strong>、<strong>MOSI</strong>、<strong>MISO</strong> 和 <strong>CS</strong>，现在对每根信号线的具体作用和功能进行介绍。</p>
<ul>
<li><strong>SCLK (Serial Clock)：时钟信号线</strong></li>
</ul>
<p>这是由主设备产生的同步时钟信号,用于驱动数据的收发。<emp>主设备负责提供稳定的时钟信号,频率可以根据需要进行调整</emp>。从设备需要使用这个时钟信号来对齐和采样数据。</p>
<ul>
<li><strong>MOSI (Master Output Slave Input)：主-&gt;从数据传输线</strong></li>
</ul>
<p>这是主设备向从设备传输数据的线路。主设备将要发送的数据放在这条线上,从设备则从这条线上读取数据。</p>
<ul>
<li><strong>MISO (Master Input Slave Output)：从-&gt;主数据传输线</strong></li>
</ul>
<p>这是从设备向主设备传输数据的线路。从设备将要发送的数据放在这条线上,主设备则从这条线上读取数据。</p>
<ul>
<li><strong>CS (Chip Select) 或 SS (Slave Select)：片选&#x2F;从设备选择信号</strong></li>
</ul>
<p>这是主设备用来选择与之通信的从设备的信号线。当主设备拉低某个从设备的 CS&#x2F;SS 线时,表示选中了该从设备进行通信。主设备可以通过控制多个 CS&#x2F;SS 线来选择与不同从设备通信。</p>
<p>主设备和从设备之间的连接关系如下所示:</p>
<ul>
<li><p>SCLK 线连接主设备的 SCLK 输出到从设备的 SCLK 输入</p>
</li>
<li><p>MOSI 线连接主设备的 MOSI 输出到从设备的 MOSI 输入</p>
</li>
<li><p>MISO 线连接主设备的 MISO 输入到从设备的 MISO 输出</p>
</li>
<li><p>CS&#x2F;SS 线连接主设备的片选输出到从设备的片选输入</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143913697.png" alt="主设备和从设备之间的连接关系" loading="lazy"></p>
<h2 id="SPI-通信原理"><a href="#SPI-通信原理" class="headerlink" title="SPI 通信原理"></a>SPI 通信原理</h2><p>SPI 总线在进行数据传输时，具有以下特点：</p>
<ul>
<li><strong>传输顺序</strong>：默认情况下，SPI 总线先传输高位（MSB，Most Significant Bit），然后传输低位（LSB，Least Significant Bit）。</li>
<li><strong>逻辑电平</strong>：数据线为高电平表示逻辑 1，数据线为低电平表示逻辑 0。</li>
<li><strong>字节传输</strong>：<wavy>一个字节传输完成之后，无需应答信号即可开启下一个字节的传输。</wavy></li>
</ul>
<p>SPI 是单通信协议，意味着总线中只有一个主设备能发起通信，而 SPI 主设备和从设备都有一个<strong>串行移位寄存器</strong>，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143920334.png" alt="SPI 主设备和从设备都有一个串行移位寄存器" loading="lazy"></p>
<p>当 SPI 主设备想读&#x2F;写从设备时，它<strong>首先要拉低从设备对应的 CS 线</strong>（CS 线是低电平有效），接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，<strong>主设备把信号发送到 MOSI 实现“写”，同时可对 MISO 采样实现“读”</strong>。</p>
<p><strong>在一个 SPI时钟周期内，收发是同时进行的</strong>：</p>
<ul>
<li>主机通过 MOSI 线发送 1bit 数据，从机通过该线读取这 1bit数据；</li>
<li>从机通过 MISO 线发送 1bit 数据，主机通过该线读取这 1bit 数据；</li>
</ul>
<p>当寄存器中的内容全部移出时，相当于完成了俩个寄存器内容的交换。如果主设备要给从设备传输数据，主设备只需要忽略掉从设备接收到的数据即可。如果主设备要从从设备接收数据，主设备向从设备随机发送数据，从设备忽略掉从主设备接收的数据即可。</p>
<h2 id="SPI极性和相位"><a href="#SPI极性和相位" class="headerlink" title="SPI极性和相位"></a>SPI极性和相位</h2><p>在 SPI 的通信之前需要先<strong>确定时钟信号的默认状态</strong>以及<strong>时钟信号的采样时间</strong>，这两个参数由 **CPOL(时钟极性 Clock Polarity)**和 **CPHA(时钟相位 Clock Phase)**来确定</p>
<ol>
<li><strong>CPOL(时钟极性 Clock Polarity)</strong>：CPOL 定义了<emp>时钟信号的默认状态(即空闲状态)</emp>。<ul>
<li>CPOL &#x3D; 0 时,表示时钟信号在空闲状态下为低电平(0)。</li>
<li>CPOL &#x3D; 1 时,表示时钟信号在空闲状态下为高电平(1)。</li>
</ul>
</li>
<li><strong>CPHA(时钟相位 Clock Phase)</strong>：CPHA 定义了<emp>数据信号相对于时钟信号的采样时间</emp>。<ul>
<li>CPHA &#x3D; 0 时,表示数据在时钟的<strong>第一个边沿(上升或下降)被采样</strong>。</li>
<li>CPHA &#x3D; 1 时,表示数据在时钟的<strong>第二个边沿(上升或下降)被采样</strong>。</li>
</ul>
</li>
</ol>
<p>四种组合模式：</p>
<ol>
<li>CPOL&#x3D;0, CPHA&#x3D;0: 时钟空闲为低电平,数据在时钟的第一个边沿(上升沿)被采样</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144110634.png" alt="CPOL&#x3D;0, CPHA&#x3D;0" loading="lazy"></p>
<ol start="2">
<li>CPOL&#x3D;0, CPHA&#x3D;1: 时钟空闲为低电平,数据在时钟的第二个边沿(下降沿)被采样</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144106614.png" alt="CPOL&#x3D;0, CPHA&#x3D;1" loading="lazy"></p>
<ol start="3">
<li>CPOL&#x3D;1, CPHA&#x3D;0: 时钟空闲为高电平,数据在时钟的第一个边沿(下降沿)被采样</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143935687.png" alt="CPOL&#x3D;1, CPHA&#x3D;0" loading="lazy"></p>
<ol start="4">
<li>CPOL&#x3D;1, CPHA&#x3D;1: 时钟空闲为高电平,数据在时钟的第二个边沿(上升沿)被采样</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143940236.png" alt="CPOL&#x3D;1, CPHA&#x3D;1" loading="lazy"></p>
<blockquote>
<p>注意：<strong>主设备和从设备必须配置相同的 CPOL 和 CPHA,否则无法正常通信。</strong></p>
<p>而在一般情况下,主设备会配置 CPOL 和 CPHA,从设备则需要根据主设备的设置进行匹配</p>
</blockquote>
<h2 id="iTOP-RK3568-处理器中的-SPI-接口"><a href="#iTOP-RK3568-处理器中的-SPI-接口" class="headerlink" title="iTOP-RK3568 处理器中的 SPI 接口"></a>iTOP-RK3568 处理器中的 SPI 接口</h2><p>iTOP-RK3568支持 4 个 SPI 控制器</p>
<ul>
<li>1 个控制器支持 1 个片选输出其余 3 个控制器各支持 2 个片选输出</li>
<li>支持主机模式和从机模式,可通过软件进行配置切换</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143947810.png" alt="RK3568核心板Datasheet" loading="lazy"></p>
<p>其中这里的 4 路 SPI 接口指的是硬件 SPI，在 SOC 上有专用的硬件 SPI 电路，关于硬件 I2C的介绍如下所示：</p>
<p><strong>硬件 SPI</strong>:</p>
<ul>
<li>实现方式: 通过专门的硬件电路来实现 SPI 通信协议。</li>
<li>优点:<ul>
<li>CPU 占用低: SPI 总线由硬件电路自动完成，CPU 无需直接介入。</li>
<li>传输速率高: 可以达到几十 MHz 甚至更高的通信速率。</li>
<li>灵活配置: 硬件 SPI 通常提供 CPOL 和 CPHA 的配置选项，用于设置时钟极性和相位。</li>
</ul>
</li>
<li>缺点:<ul>
<li>需要专用硬件: 需要专用的硬件 SPI 接口模块支持，成本相对较高。</li>
<li>接口固定: 接口固定，不如软件 SPI 灵活。</li>
</ul>
</li>
<li>适用范围: 适用于高速、大量数据传输的场合，如 LCD、EEPROM 等外设的连接。</li>
</ul>
<p>软件 SPI 指的是通过 GPIO 口模拟 SPI 的四根信号线，在硬件 SPI 不够用的情况下，可以通过 GPIO 来模拟软件 SPI,关于软件 SPI 的介绍如下所示：</p>
<p><strong>软件 SPI:</strong></p>
<ul>
<li>实现方式: 通过 CPU 的 GPIO 引脚模拟 SPI 通信协议。</li>
<li>优点<ul>
<li>灵活性高: 可以灵活配置 CPOL 和 CPHA，适用于高度定制化的 SPI 通信。</li>
<li>无专用硬件要求: 不需要专用的硬件 SPI 接口模块，适用于没有内置硬件 SPI 接口的系统。</li>
</ul>
</li>
<li>缺点:<ul>
<li>CPU 占用高: 需要 CPU 程序完成时钟信号的生成、数据的读写等全部操作。</li>
<li>传输速率低: 速度受到 CPU 执行程序的速度限制，通常较硬件 SPI 要慢。</li>
</ul>
</li>
<li>适用范围: 适用于没有内置硬件 SPI 接口的系统，或需要高度定制化 SPI 通信的场景。</li>
</ul>
<p>RK3568 开发板上的 SPI 接口具体使用情况如下表所示</p>
<h3 id="SPI0"><a href="#SPI0" class="headerlink" title="SPI0"></a><strong>SPI0</strong></h3><table>
<thead>
<tr>
<th>pinctrl function</th>
<th>网络标号</th>
<th>对应的 GPIO</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>SPI0_CLK_M0</td>
<td>TP_INT_L_GPI00_B5</td>
<td>GPIO00_B5</td>
<td>PCIE2.0 唤醒</td>
</tr>
<tr>
<td>SPI0_MISO_M0</td>
<td>LCD1_PWREN_H_GPI00_C5</td>
<td>GPIO00_C5</td>
<td>未使用</td>
</tr>
<tr>
<td>SPI0_MOSI_M0</td>
<td>TP_RST_L_GPI00_B6</td>
<td>GPIO00_B6</td>
<td>MIPI 屏幕触摸复位引脚</td>
</tr>
<tr>
<td>SPI0_CS0_M0</td>
<td>4G_PWREN_H_GPI00_C6</td>
<td>GPIO00_C6</td>
<td>未使用</td>
</tr>
<tr>
<td>SPI0_CS1_M0</td>
<td>LCD1_BL_PWM5</td>
<td>GPIO00_C4</td>
<td>MIPI 屏幕使能引脚</td>
</tr>
<tr>
<td>SPI0_CLK_M1</td>
<td>PCIE30X1_WAKEn_M1</td>
<td>GPIO2_D3</td>
<td>底板背面 SPI</td>
</tr>
<tr>
<td>SPI0_MISO_M1</td>
<td>PCIE20_CLKREQn_M1</td>
<td>GPIO2_D0</td>
<td>底板背面 SPI</td>
</tr>
<tr>
<td>SPI0_MOSI_M1</td>
<td>PCIE20_WAKEn_M1</td>
<td>GPIO2_D1</td>
<td>底板背面 SPI</td>
</tr>
<tr>
<td>SPI0_CS0_M1</td>
<td>PCIE30X1_CLKREQn_M1</td>
<td>GPIO2_D2</td>
<td>底板背面 SPI</td>
</tr>
</tbody></table>
<h3 id="SPI1"><a href="#SPI1" class="headerlink" title="SPI1"></a><strong>SPI1</strong></h3><table>
<thead>
<tr>
<th>pinctrl function</th>
<th>网络标号</th>
<th>对应的 GPIO</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>SPI1_CLK_M0</td>
<td>GMAC0_TXEN</td>
<td>GPIO2_B5</td>
<td>网口 0</td>
</tr>
<tr>
<td>SPI1_MISO_M0</td>
<td>GMAC0_RXD0</td>
<td>GPIO2_B6</td>
<td>网口 0</td>
</tr>
<tr>
<td>SPI1_MOSI_M0</td>
<td>GMAC0_RXD1</td>
<td>GPIO2_B7</td>
<td>网口 0</td>
</tr>
<tr>
<td>SPI1_CS0_M0</td>
<td>GMAC0_RXDV_CRS</td>
<td>GPIO2_C0</td>
<td>网口 0</td>
</tr>
<tr>
<td>SPI1_CS1_M0</td>
<td>CLK32K_OUT1_WIFI</td>
<td>GPIO2_C6</td>
<td>未使用</td>
</tr>
<tr>
<td>SPI1_CLK_M1</td>
<td>GMAC0_TXEN</td>
<td>GPIO3_C3</td>
<td>网口 0</td>
</tr>
<tr>
<td>SPI1_MISO_M1</td>
<td>SPK_CTL_H_GPI03_C3</td>
<td>GPIO2_B6</td>
<td>5G 复位</td>
</tr>
<tr>
<td>SPI1_MOSI_M1</td>
<td>PCIE20_PERSTn_M1</td>
<td>GPIO3_C1</td>
<td>未使用</td>
</tr>
<tr>
<td>SPI1_CS0_M1</td>
<td>PCIE30X1_PERSTn_M1</td>
<td>GPIO3_A1</td>
<td>未使用</td>
</tr>
</tbody></table>
<h3 id="SPI2"><a href="#SPI2" class="headerlink" title="SPI2"></a><strong>SPI2</strong></h3><table>
<thead>
<tr>
<th>pinctrl function</th>
<th>网络标号</th>
<th>对应的 GPIO</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>SPI2_CLK_M0</td>
<td>ETH0_REFCLK0_25M</td>
<td>GPIO2_C1</td>
<td>网口 0 时钟</td>
</tr>
<tr>
<td>SPI2_MISO_M0</td>
<td>GMAC0_MCLKINOUT</td>
<td>GPIO2_C2</td>
<td>网口 0 时钟</td>
</tr>
<tr>
<td>SPI2_MOSI_M0</td>
<td>GMAC0_MDC</td>
<td>GPIO2_C3</td>
<td>网口 0</td>
</tr>
<tr>
<td>SPI2_CS0_M0</td>
<td>GMAC0_MDIO</td>
<td>GPIO2_C4</td>
<td>网口 0</td>
</tr>
<tr>
<td>SPI2_CS1_M0</td>
<td>GPIO2_C5</td>
<td>GPIO2_C5</td>
<td>PCIE 电源使能引脚</td>
</tr>
<tr>
<td>SPI2_CLK_M1</td>
<td>PCIE30X1_PRSNT_L_GPI03_A0</td>
<td>GPIO3_A0</td>
<td>PCIE2.0</td>
</tr>
<tr>
<td>SPI2_MISO_M1</td>
<td>PCIE30X2_PRSNT_L_GPI02_D7</td>
<td>GPIO2_D7</td>
<td>PCIE3.0</td>
</tr>
<tr>
<td>SPI2_MOSI_M1</td>
<td>PCIE30X2_PERSTn_M1</td>
<td>GPIO2_D6</td>
<td>PCIE3.0</td>
</tr>
<tr>
<td>SPI2_CS0_M1</td>
<td>PCIE30X2_WAKEn_M1</td>
<td>GPIO2_D5</td>
<td>PCIE3.0</td>
</tr>
<tr>
<td>SPI2_CS1_M1</td>
<td>PCIE30X2_CLKREQn_M1</td>
<td>GPIO2_D4</td>
<td>PCIE3.0</td>
</tr>
</tbody></table>
<h3 id="SPI3"><a href="#SPI3" class="headerlink" title="SPI3"></a><strong>SPI3</strong></h3><table>
<thead>
<tr>
<th>pinctrl function</th>
<th>网络标号</th>
<th>对应的 GPIO</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>SPI3_CLK_M0</td>
<td>ETH1_REFCLK0_25M_M1</td>
<td>GPIO4_B3</td>
<td>网口 1 时钟</td>
</tr>
<tr>
<td>SPI3_MISO_M0</td>
<td>GMAC1_RXD1_M1</td>
<td>GPIO4_B0</td>
<td>网口 1</td>
</tr>
<tr>
<td>SPI3_MOSI_M0</td>
<td>GPIO4_B2</td>
<td>GPIO4_B2</td>
<td>未使用</td>
</tr>
<tr>
<td>SPI3_CS0_M0</td>
<td>GMAC1_TXEN_M1</td>
<td>GPIO4_A6</td>
<td>网口 1</td>
</tr>
<tr>
<td>SPI3_CS1_M0</td>
<td>GMAC1_RXD0_M1</td>
<td>GPIO4_A7</td>
<td>网口 1</td>
</tr>
<tr>
<td>SPI3_CLK_M1</td>
<td>4G_DISABLE_GPI04_C2</td>
<td>GPIO4_C2</td>
<td>CAN1_RX</td>
</tr>
<tr>
<td>SPI3_MISO_M1</td>
<td>GPIO4_C5</td>
<td>GPIO4_C5</td>
<td>未使用</td>
</tr>
<tr>
<td>SPI3_MOSI_M1</td>
<td>HDMI_RX_INT_L_GPI04_C3</td>
<td>GPIO4_C3</td>
<td>CAN1_TX</td>
</tr>
<tr>
<td>SPI3_CS0_M1</td>
<td>GPIO4_C6</td>
<td>GPIO4_C6</td>
<td>未使用</td>
</tr>
<tr>
<td>SPI3_CS1_M1</td>
<td>HDMI_TX_CEC_M0</td>
<td>GPIO4_D1</td>
<td>HDMI CEC 引脚</td>
</tr>
</tbody></table>
<p><strong>每个 SPI 控制器各自有两组 pinctrl，但某一个硬件 SPI 只能由一组 pinctrl 引脚进行复用</strong>。</p>
<h2 id="mcp2515"><a href="#mcp2515" class="headerlink" title="mcp2515"></a>mcp2515</h2><p>该模块不仅可以实现 SPI 转 CAN 的功能，还可以实现 TTL 转 485 的功能，相关的原理图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144004882.png" alt="mcp2515" loading="lazy"></p>
<p>上述原理图中总共涉及到了两个芯片，分别为 <strong>MCP2515 SPI 转 CAN 芯片</strong>和 <strong>MCP2551 CAN 收发器芯片</strong>，这里主要对 MCP2515 芯片进行介绍。</p>
<p>MCP2515 是一款独立的 CAN 协议控制器，完全支持 CAN V2.0B 技术规范。它通过标准的SPI 接口与控制器连接。主要特点如下：</p>
<ol>
<li>完全支持 CAN V2.0B：支持标准和扩展数据帧及远程帧的发送和接收。</li>
<li>高效的滤波功能：内置两个验收屏蔽寄存器和六个验收滤波寄存器，可以过滤掉不需要的报文，减少主 MCU 的处理负担。</li>
<li>SPI 接口：通过 SPI 接口与主控制器进行通信，提供高效的数据传输。</li>
<li>多种操作模式：包括正常模式、休眠模式、监听模式和环回模式，以满足不同应用需求。</li>
<li>自动重传：在发送失败时自动重传，确保数据传输的可靠性。</li>
<li>错误检测和处理：内置错误检测和处理机制，保证数据传输的准确性。</li>
</ol>
<p>SPI 转 CAN 模块与 iTOP-RK3568 开发板具体的连接示意图如下所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144017427.png" alt="SPI 转 CAN 模块与 iTOP-RK3568 开发板具体的连接" loading="lazy"></p>
<h1 id="SPI子系统框架"><a href="#SPI子系统框架" class="headerlink" title="SPI子系统框架"></a>SPI子系统框架</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144021289.png" alt="SPI 子系统框架" loading="lazy"></p>
<p>可以将上面这一 SPI 子系统划分为三个层次，分别为用户空间、内核空间和硬件层，内核空间就包括 SPI 设备驱动层、SPI 核心层和 SPI 适配器驱动层，而本章的主要内容就是介绍 SPI 子系统框架中的内核空间。</p>
<h2 id="SPI设备驱动层"><a href="#SPI设备驱动层" class="headerlink" title="SPI设备驱动层"></a>SPI设备驱动层</h2><p>SPI 设备驱动层的主要作用是编写驱动程序，使 SPI 外设能够正常工作。它创建了对应的设备节点，提供了标准化的接口，使得上层应用程序能够方便地与 SPI 设备进行交互。</p>
<p>具体来说，SPI 设备驱动层包含以下几个关键部分：</p>
<ul>
<li><code>spi_device</code><ul>
<li>代表一个连接到 SPI 总线上的从设备</li>
<li>包含从设备的地址、所属的 SPI 主设备等信息。</li>
</ul>
</li>
<li><code>/dev/spiX</code> 设备节点<ul>
<li>为上层应用程序提供设备访问的接口</li>
<li>通过打开&#x2F;读写&#x2F;控制设备节点，应用程序可以与 SPI 设备进行交互。</li>
<li>内核 SPI 子系统负责将应用程序的操作转发到对应的 spi_driver。</li>
</ul>
</li>
<li><code>spi_driver</code><ul>
<li>实现了具体 SPI 从设备的驱动程序</li>
<li>负责设备的初始化、读写、配置等操作。</li>
<li>通过 spi_device 与设备进行交互。</li>
<li>向上层提供设备访问的标准化接口。</li>
</ul>
</li>
</ul>
<h2 id="SPI适配器驱动层"><a href="#SPI适配器驱动层" class="headerlink" title="SPI适配器驱动层"></a>SPI适配器驱动层</h2><p>SPI 适配器驱动层是 SPI 子系统的重要组成部分，负责实现具体的 SPI 硬件控制器的驱动程序。SPI 适配器驱动程序的作用如下：</p>
<ul>
<li><strong>提供标准化的 SPI 传输接口</strong><ul>
<li>适配器驱动层为 SPI 核心层提供标准化的传输接口，确保不同的 SPI 控制器可以统一使用这些接口进行数据传输。</li>
</ul>
</li>
<li><strong>实现 SPI 总线协议的时序控制和数据收发</strong><ul>
<li>负责实现 SPI 总线协议的时序控制，包括时钟极性（CPOL）和时钟相位（CPHA）的配置。</li>
<li>管理数据的发送和接收，确保数据传输的准确性和可靠性。</li>
<li>通过硬件 SPI 模块自动完成时钟信号的生成和数据收发，提高通信效率。</li>
</ul>
</li>
<li><strong>管理 SPI 总线上的从设备</strong><ul>
<li>适配器驱动层负责管理 SPI 总线上的所有从设备，包括注册和注销从设备。</li>
<li>确保 SPI 总线上的从设备可以正确地进行通信，协调主设备和从设备之间的交互。</li>
</ul>
</li>
<li><strong>处理 SPI 总线错误和异常情况</strong><ul>
<li>适配器驱动层负责监控和处理 SPI 总线上的错误和异常情况。</li>
<li>提供错误恢复和重试机制，确保系统的稳定性和可靠性。</li>
<li>处理硬件中断，及时响应数据传输中的各种异常情况。</li>
</ul>
</li>
</ul>
<h2 id="SPI-核心层"><a href="#SPI-核心层" class="headerlink" title="SPI 核心层"></a>SPI 核心层</h2><p>SPI 核心层位于 SPI 设备驱动层和 SPI 适配器驱动层之间，起到了承上启下的作用，负责SPI 设备驱动层和 SPI 适配器驱动层之间的数据传递。</p>
<p>SPI 核心层的主要函数为 <code>spi_write</code> 和<code>spi_read</code>，这些函数提供了基本的读写接口。核心函数介绍：</p>
<ul>
<li><code>spi_write</code><ul>
<li>函数作用：用于向 SPI 从设备发送数据。</li>
<li>函数参数介绍：<ul>
<li><code>struct spi_device *spi</code>: 指向目标 SPI 从设备的指针。</li>
<li><code>const void *buf</code>: 数据缓冲区。</li>
<li><code>size_t len</code>: 要发送的字节数。</li>
</ul>
</li>
<li>这个函数负责生成符合 SPI 协议的时序和数据帧，并通过对应的 SPI 适配器驱动程序进行实际的总线操作。</li>
</ul>
</li>
<li><code>spi_read</code><ul>
<li>函数作用：用于从 SPI 从设备接收数据。</li>
<li>函数参数介绍：<ul>
<li><code>struct spi_device *spi</code>: 指向目标 SPI 从设备的指针。</li>
<li><code>void *buf</code>: 数据缓冲区。</li>
<li><code>size_t len</code>: 要接收的字节数。</li>
</ul>
</li>
<li>这个函数同样负责生成符合 SPI 协议的时序和数据帧，并通过对应的 SPI 适配器驱动程序进行实际的总线操作。</li>
</ul>
</li>
</ul>
<p>核心层的具体作用如下：</p>
<ul>
<li>核心层负责在设备驱动层和适配器驱动层之间传递数据。通过 <code>spi_write</code> 和 <code>spi_read</code>函数，核心层将设备驱动层的数据传递给适配器驱动层进行实际的硬件操作。</li>
<li>核心层生成符合 SPI 协议的时序和数据帧，确保数据能够正确地在 SPI 总线上传输。</li>
<li>核心层提供标准化的接口，使得上层的设备驱动程序可以方便地进行数据传输，而无需关心底层硬件的具体实现。</li>
</ul>
<h1 id="通用SPI外设框架编写"><a href="#通用SPI外设框架编写" class="headerlink" title="通用SPI外设框架编写"></a>通用SPI外设框架编写</h1><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><p>SPI 转 CAN 模块要接的 iTOP-RK3568 的引脚</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144030581.png" alt="SPI 转 CAN 模块要接的 iTOP-RK3568 的引脚" loading="lazy"></p>
<p>可以根据引脚的网络标号得到要使能的 SPI 控制器为 SPI0，然后开始对 iTOP-RK3568 的设备树进行修改</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi0</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">	</span></span><br><span class="line"><span class="symbol">	mcp2515:</span><span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-mcp2515&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>第 3-4 行，指定了要使用的 <code>spi pinctrl</code> 引脚，默认情况下使用的 spi0 控制器 pinctrl 引脚为 <code>spi0m0_cs0</code> 和 <code>spi0m0_pins</code>，而实际用的是第二组 pinctrl 引脚。</p>
<p>第 7 行，表述指定片选 0。</p>
<p>第 9 行，设置 <code>spi clk</code> 输出的时钟频率，这里设置的是 10M，RK3568 最大设置不超过 50M。如果 <code>reg</code> 属性和 <code>spi-max-frequency</code> 不设置在驱动加载时将无法进入 <code>probe spi</code> 初始化函数（驱动中匹配函数）。</p>
<h3 id="reg-和-spi-max-frequency属性"><a href="#reg-和-spi-max-frequency属性" class="headerlink" title="reg 和 spi-max-frequency属性"></a><code>reg</code> 和 <code>spi-max-frequency</code>属性</h3><p>在rk3568.dtsi中：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spi0:</span> <span class="title class_">spi@fe610000</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3066-spi&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe610000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">103</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">		<span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">		<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_SPI0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_SPI0&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;spiclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">dmas</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">20</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">21</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">dma-names</span> <span class="operator">=</span> <span class="string">&quot;tx&quot;</span>, <span class="string">&quot;rx&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;high_speed&quot;</span><span class="punctuation">;</span></span><br><span class="line">		pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m0_cs0</span> <span class="variable">&amp;spi0m0_cs1</span> <span class="variable">&amp;spi0m0_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m0_cs0</span> <span class="variable">&amp;spi0m0_cs1</span> <span class="variable">&amp;spi0m0_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">num-cs</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>根据设备树的 <code>compatible</code> 属性来寻找对应的 SPI 控制器驱动程序，找到的具体驱动文件路径为 <code>spi/spi-rockchip.c</code>，该驱动程序的 probe 函数内容如下所示：</p>
<h4 id="rockchip-spi-probe"><a href="#rockchip-spi-probe" class="headerlink" title="rockchip_spi_probe()"></a>rockchip_spi_probe()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_spi_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_spi</span> *<span class="title">rs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> *<span class="title">ctlr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">mem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	u32 rsd_nsecs, num_cs, csm;</span><br><span class="line">	<span class="type">bool</span> slave_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_spi_quirks</span> *<span class="title">quirks_cfg</span>;</span></span><br><span class="line">	<span class="comment">// 检查设备节点是否配置为 SPI 从模式</span></span><br><span class="line">	slave_mode = of_property_read_bool(np, <span class="string">&quot;spi-slave&quot;</span>);</span><br><span class="line">	<span class="comment">// 根据从模式或主模式分配 SPI 控制器</span></span><br><span class="line">	<span class="keyword">if</span> (slave_mode)</span><br><span class="line">		ctlr = spi_alloc_slave(&amp;pdev-&gt;dev,</span><br><span class="line">				<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rockchip_spi));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ctlr = spi_alloc_master(&amp;pdev-&gt;dev,</span><br><span class="line">				<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rockchip_spi));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ctlr)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 设置平台设备的驱动数据</span></span><br><span class="line">	platform_set_drvdata(pdev, ctlr);</span><br><span class="line"></span><br><span class="line">	rs = spi_controller_get_devdata(ctlr);</span><br><span class="line">	ctlr-&gt;slave = slave_mode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get basic io resource and map it */</span></span><br><span class="line">    <span class="comment">// 获取基本的 IO 资源并映射</span></span><br><span class="line">	mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	rs-&gt;regs = devm_ioremap_resource(&amp;pdev-&gt;dev, mem);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rs-&gt;regs)) &#123;</span><br><span class="line">		ret =  PTR_ERR(rs-&gt;regs);</span><br><span class="line">		<span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">	&#125;</span><br><span class="line">	rs-&gt;base_addr_phy = mem-&gt;start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!has_acpi_companion(&amp;pdev-&gt;dev))</span><br><span class="line">		rs-&gt;apb_pclk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;apb_pclk&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rs-&gt;apb_pclk)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get apb_pclk\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(rs-&gt;apb_pclk);</span><br><span class="line">		<span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!has_acpi_companion(&amp;pdev-&gt;dev))</span><br><span class="line">		rs-&gt;spiclk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;spiclk&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rs-&gt;spiclk)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get spi_pclk\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(rs-&gt;spiclk);</span><br><span class="line">		<span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rs-&gt;sclk_in = devm_clk_get_optional(&amp;pdev-&gt;dev, <span class="string">&quot;sclk_in&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rs-&gt;sclk_in)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get sclk_in\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(rs-&gt;sclk_in);</span><br><span class="line">		<span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 启用 APB PCLK</span></span><br><span class="line">	ret = clk_prepare_enable(rs-&gt;apb_pclk);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable apb_pclk\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 启用 SPI CLK</span></span><br><span class="line">	ret = clk_prepare_enable(rs-&gt;spiclk);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable spi_clk\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_disable_apbclk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = clk_prepare_enable(rs-&gt;sclk_in);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable sclk_in\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_disable_spiclk;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 禁用 SPI 芯片</span></span><br><span class="line">	spi_enable_chip(rs, <span class="literal">false</span>);</span><br><span class="line">	<span class="comment">// 获取平台中断资源</span></span><br><span class="line">	ret = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line">	<span class="comment">// 请求中断</span></span><br><span class="line">	ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, ret, rockchip_spi_isr, <span class="literal">NULL</span>,</span><br><span class="line">			IRQF_ONESHOT, dev_name(&amp;pdev-&gt;dev), ctlr);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line"></span><br><span class="line">	rs-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	rs-&gt;freq = clk_get_rate(rs-&gt;spiclk);</span><br><span class="line">	<span class="keyword">if</span> (!rs-&gt;freq) &#123;</span><br><span class="line">		ret = device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;clock-frequency&quot;</span>, &amp;rs-&gt;freq);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_warn(rs-&gt;dev, <span class="string">&quot;Failed to get clock or clock-frequency property\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取接收采样延迟（以纳秒为单位）</span></span><br><span class="line">	<span class="keyword">if</span> (!device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;rx-sample-delay-ns&quot;</span>, &amp;rsd_nsecs)) &#123;</span><br><span class="line">		<span class="comment">/* rx sample delay is expressed in parent clock cycles (max 3) */</span></span><br><span class="line">		u32 rsd = DIV_ROUND_CLOSEST(rsd_nsecs * (rs-&gt;freq &gt;&gt; <span class="number">8</span>),</span><br><span class="line">				<span class="number">1000000000</span> &gt;&gt; <span class="number">8</span>);</span><br><span class="line">		<span class="keyword">if</span> (!rsd) &#123;</span><br><span class="line">			dev_warn(rs-&gt;dev, <span class="string">&quot;%u Hz are too slow to express %u ns delay\n&quot;</span>,</span><br><span class="line">					rs-&gt;freq, rsd_nsecs);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rsd &gt; CR0_RSD_MAX) &#123;</span><br><span class="line">			rsd = CR0_RSD_MAX;</span><br><span class="line">			dev_warn(rs-&gt;dev, <span class="string">&quot;%u Hz are too fast to express %u ns delay, clamping at %u ns\n&quot;</span>,</span><br><span class="line">					rs-&gt;freq, rsd_nsecs,</span><br><span class="line">					CR0_RSD_MAX * <span class="number">1000000000U</span> / rs-&gt;freq);</span><br><span class="line">		&#125;</span><br><span class="line">		rs-&gt;rsd = rsd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;csm&quot;</span>, &amp;csm)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (csm &gt; CR0_CSM_ONE)	&#123;</span><br><span class="line">			dev_warn(rs-&gt;dev, <span class="string">&quot;The csm value %u exceeds the limit, clamping at %u\n&quot;</span>,</span><br><span class="line">				 csm, CR0_CSM_ONE);</span><br><span class="line">			csm = CR0_CSM_ONE;</span><br><span class="line">		&#125;</span><br><span class="line">		rs-&gt;csm = csm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rs-&gt;version = readl_relaxed(rs-&gt;regs + ROCKCHIP_SPI_VERSION);</span><br><span class="line">	rs-&gt;fifo_len = get_fifo_len(rs);<span class="comment">// 获取 FIFO 长度</span></span><br><span class="line">	<span class="keyword">if</span> (!rs-&gt;fifo_len) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get fifo length\n&quot;</span>);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line">	&#125;</span><br><span class="line">	quirks_cfg = device_get_match_data(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (quirks_cfg)</span><br><span class="line">		rs-&gt;max_baud_div_in_cpha = quirks_cfg-&gt;max_baud_div_in_cpha;</span><br><span class="line">	<span class="comment">// 设置并启用运行时电源管理</span></span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	ctlr-&gt;auto_runtime_pm = <span class="literal">true</span>;</span><br><span class="line">	ctlr-&gt;bus_num = pdev-&gt;id;</span><br><span class="line">	ctlr-&gt;mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP | SPI_LSB_FIRST;</span><br><span class="line">	<span class="keyword">if</span> (slave_mode) &#123;</span><br><span class="line">		ctlr-&gt;mode_bits |= SPI_NO_CS;</span><br><span class="line">		ctlr-&gt;slave_abort = rockchip_spi_slave_abort;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ctlr-&gt;flags = SPI_MASTER_GPIO_SS;</span><br><span class="line">		ctlr-&gt;max_native_cs = ROCKCHIP_SPI_MAX_CS_NUM;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * rk spi0 has two native cs, spi1..5 one cs only</span></span><br><span class="line"><span class="comment">		 * if num-cs is missing in the dts, default to 1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;num-cs&quot;</span>, &amp;num_cs))</span><br><span class="line">			num_cs = <span class="number">1</span>;</span><br><span class="line">		ctlr-&gt;num_chipselect = num_cs;</span><br><span class="line">		ctlr-&gt;use_gpio_descriptors = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ctlr-&gt;dev.of_node = pdev-&gt;dev.of_node;</span><br><span class="line">	ctlr-&gt;bits_per_word_mask = SPI_BPW_MASK(<span class="number">16</span>) | SPI_BPW_MASK(<span class="number">8</span>) | SPI_BPW_MASK(<span class="number">4</span>);</span><br><span class="line">	ctlr-&gt;min_speed_hz = rs-&gt;freq / BAUDR_SCKDV_MAX;</span><br><span class="line">	ctlr-&gt;max_speed_hz = min(rs-&gt;freq / BAUDR_SCKDV_MIN, MAX_SCLK_OUT);</span><br><span class="line"></span><br><span class="line">	ctlr-&gt;setup = rockchip_spi_setup;</span><br><span class="line">	ctlr-&gt;set_cs = rockchip_spi_set_cs;</span><br><span class="line">	ctlr-&gt;transfer_one = rockchip_spi_transfer_one;</span><br><span class="line">	ctlr-&gt;max_transfer_size = rockchip_spi_max_transfer_size;</span><br><span class="line">	ctlr-&gt;handle_err = rockchip_spi_handle_err;</span><br><span class="line">	<span class="comment">// 请求 TX DMA 通道</span></span><br><span class="line">	ctlr-&gt;dma_tx = dma_request_chan(rs-&gt;dev, <span class="string">&quot;tx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ctlr-&gt;dma_tx)) &#123;</span><br><span class="line">		<span class="comment">/* Check tx to see if we need defer probing driver */</span></span><br><span class="line">		<span class="keyword">if</span> (PTR_ERR(ctlr-&gt;dma_tx) == -EPROBE_DEFER) &#123;</span><br><span class="line">			ret = -EPROBE_DEFER;</span><br><span class="line">			<span class="keyword">goto</span> err_disable_pm_runtime;</span><br><span class="line">		&#125;</span><br><span class="line">		dev_warn(rs-&gt;dev, <span class="string">&quot;Failed to request TX DMA channel\n&quot;</span>);</span><br><span class="line">		ctlr-&gt;dma_tx = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 请求 RX DMA 通道</span></span><br><span class="line">	ctlr-&gt;dma_rx = dma_request_chan(rs-&gt;dev, <span class="string">&quot;rx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ctlr-&gt;dma_rx)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PTR_ERR(ctlr-&gt;dma_rx) == -EPROBE_DEFER) &#123;</span><br><span class="line">			ret = -EPROBE_DEFER;</span><br><span class="line">			<span class="keyword">goto</span> err_free_dma_tx;</span><br><span class="line">		&#125;</span><br><span class="line">		dev_warn(rs-&gt;dev, <span class="string">&quot;Failed to request RX DMA channel\n&quot;</span>);</span><br><span class="line">		ctlr-&gt;dma_rx = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果 TX 和 RX DMA 通道均成功请求</span></span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;dma_tx &amp;&amp; ctlr-&gt;dma_rx) &#123;</span><br><span class="line">		rs-&gt;dma_addr_tx = mem-&gt;start + ROCKCHIP_SPI_TXDR;</span><br><span class="line">		rs-&gt;dma_addr_rx = mem-&gt;start + ROCKCHIP_SPI_RXDR;</span><br><span class="line">		ctlr-&gt;can_dma = rockchip_spi_can_dma;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rs-&gt;poll = device_property_read_bool(&amp;pdev-&gt;dev, <span class="string">&quot;rockchip,poll-only&quot;</span>);</span><br><span class="line">	<span class="comment">// 检查 SPI 版本并设置 cs_inactive</span></span><br><span class="line">	<span class="keyword">switch</span> (rs-&gt;version) &#123;</span><br><span class="line">	<span class="keyword">case</span> ROCKCHIP_SPI_VER2_TYPE2:</span><br><span class="line">		rs-&gt;cs_high_supported = <span class="literal">true</span>;</span><br><span class="line">		ctlr-&gt;mode_bits |= SPI_CS_HIGH;</span><br><span class="line">		<span class="keyword">if</span> (slave_mode)</span><br><span class="line">			rs-&gt;cs_inactive = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rs-&gt;cs_inactive = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		rs-&gt;cs_inactive = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取引脚控制</span></span><br><span class="line">	pinctrl = devm_pinctrl_get(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(pinctrl)) &#123;</span><br><span class="line">		rs-&gt;high_speed_state = pinctrl_lookup_state(pinctrl, <span class="string">&quot;high_speed&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR_OR_NULL(rs-&gt;high_speed_state)) &#123;</span><br><span class="line">			dev_warn(&amp;pdev-&gt;dev, <span class="string">&quot;no high_speed pinctrl state\n&quot;</span>);</span><br><span class="line">			rs-&gt;high_speed_state = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册 SPI 控制器</span></span><br><span class="line">	ret = devm_spi_register_controller(&amp;pdev-&gt;dev, ctlr);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to register controller\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_free_dma_rx;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SPI_ROCKCHIP_MISCDEV)) &#123;</span><br><span class="line">		<span class="type">char</span> misc_name[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">snprintf</span>(misc_name, <span class="keyword">sizeof</span>(misc_name), <span class="string">&quot;rkspi-dev%d&quot;</span>, ctlr-&gt;bus_num);</span><br><span class="line">		rs-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">		rs-&gt;miscdev.name = misc_name;</span><br><span class="line">		rs-&gt;miscdev.fops = &amp;rockchip_spi_misc_fops;</span><br><span class="line">		rs-&gt;miscdev.parent = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">		ret = misc_register(&amp;rs-&gt;miscdev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to register misc device %s\n&quot;</span>, misc_name);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;register misc device %s\n&quot;</span>, misc_name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_info(rs-&gt;dev, <span class="string">&quot;probed, poll=%d, rsd=%d\n&quot;</span>, rs-&gt;poll, rs-&gt;rsd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_free_dma_rx:</span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;dma_rx)</span><br><span class="line">		dma_release_channel(ctlr-&gt;dma_rx);</span><br><span class="line">err_free_dma_tx:</span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;dma_tx)</span><br><span class="line">		dma_release_channel(ctlr-&gt;dma_tx);</span><br><span class="line">err_disable_pm_runtime:</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">err_disable_sclk_in:</span><br><span class="line">	clk_disable_unprepare(rs-&gt;sclk_in);</span><br><span class="line">err_disable_spiclk:</span><br><span class="line">	clk_disable_unprepare(rs-&gt;spiclk);</span><br><span class="line">err_disable_apbclk:</span><br><span class="line">	clk_disable_unprepare(rs-&gt;apb_pclk);</span><br><span class="line">err_put_ctlr:</span><br><span class="line">	spi_controller_put(ctlr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="devm-spi-register-controller"><a href="#devm-spi-register-controller" class="headerlink" title="devm_spi_register_controller()"></a>devm_spi_register_controller()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_spi_register_controller - register managed SPI master or slave</span></span><br><span class="line"><span class="comment"> *	controller</span></span><br><span class="line"><span class="comment"> * @dev:    device managing SPI controller</span></span><br><span class="line"><span class="comment"> * @ctlr: initialized controller, originally from spi_alloc_master() or</span></span><br><span class="line"><span class="comment"> *	spi_alloc_slave()</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register a SPI device as with spi_register_controller() which will</span></span><br><span class="line"><span class="comment"> * automatically be unregistered and freed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">devm_spi_register_controller</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> spi_controller *ctlr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> **<span class="title">ptr</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// 分配设备资源管理器(devres)内存，用于自动释放控制器资源</span></span><br><span class="line">	ptr = devres_alloc(devm_spi_unregister, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ptr)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;<span class="comment">// 内存分配失败</span></span><br><span class="line">	<span class="comment">// 注册 SPI 控制器</span></span><br><span class="line">	ret = spi_register_controller(ctlr);</span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		*ptr = ctlr;<span class="comment">// 注册成功，将指针存储在设备资源管理器中</span></span><br><span class="line">		devres_add(dev, ptr);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		devres_free(ptr);<span class="comment">// 注册失败，释放分配的资源</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">// 返回注册结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devm_spi_register_controller);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="spi-register-controller"><a href="#spi-register-controller" class="headerlink" title="spi_register_controller()"></a>spi_register_controller()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_register_controller</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">dev</span> =</span> ctlr-&gt;dev.parent;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">boardinfo</span>	*<span class="title">bi</span>;</span></span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line">	<span class="type">int</span>			id, first_dynamic;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure all necessary hooks are implemented before registering</span></span><br><span class="line"><span class="comment">	 * the SPI controller.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 在注册 SPI 控制器之前，确保所有必要的操作已实现</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	status = spi_controller_check_ops(ctlr);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;bus_num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* devices with a fixed bus num must check-in with the num */</span></span><br><span class="line">		mutex_lock(&amp;board_lock);<span class="comment">/* 固定总线编号的设备必须使用该编号进行检查 */</span></span><br><span class="line">		id = idr_alloc(&amp;spi_master_idr, ctlr, ctlr-&gt;bus_num,</span><br><span class="line">			ctlr-&gt;bus_num + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">		mutex_unlock(&amp;board_lock);</span><br><span class="line">		<span class="keyword">if</span> (WARN(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">			<span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line">		ctlr-&gt;bus_num = id;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctlr-&gt;dev.of_node) &#123;</span><br><span class="line">		<span class="comment">/* allocate dynamic bus number using Linux idr */</span></span><br><span class="line">		id = of_alias_get_id(ctlr-&gt;dev.of_node, <span class="string">&quot;spi&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			ctlr-&gt;bus_num = id;</span><br><span class="line">			mutex_lock(&amp;board_lock);</span><br><span class="line">			id = idr_alloc(&amp;spi_master_idr, ctlr, ctlr-&gt;bus_num,</span><br><span class="line">				       ctlr-&gt;bus_num + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">			mutex_unlock(&amp;board_lock);</span><br><span class="line">			<span class="keyword">if</span> (WARN(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">				<span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;bus_num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		first_dynamic = of_alias_get_highest_id(<span class="string">&quot;spi&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (first_dynamic &lt; <span class="number">0</span>)</span><br><span class="line">			first_dynamic = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			first_dynamic++;</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;board_lock);</span><br><span class="line">		id = idr_alloc(&amp;spi_master_idr, ctlr, first_dynamic,</span><br><span class="line">			       <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">		mutex_unlock(&amp;board_lock);</span><br><span class="line">		<span class="keyword">if</span> (WARN(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		ctlr-&gt;bus_num = id;</span><br><span class="line">	&#125;</span><br><span class="line">	INIT_LIST_HEAD(&amp;ctlr-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	spin_lock_init(&amp;ctlr-&gt;queue_lock);</span><br><span class="line">	spin_lock_init(&amp;ctlr-&gt;bus_lock_spinlock);</span><br><span class="line">	mutex_init(&amp;ctlr-&gt;bus_lock_mutex);</span><br><span class="line">	mutex_init(&amp;ctlr-&gt;io_mutex);</span><br><span class="line">	ctlr-&gt;bus_lock_flag = <span class="number">0</span>;</span><br><span class="line">	init_completion(&amp;ctlr-&gt;xfer_completion);</span><br><span class="line">	<span class="keyword">if</span> (!ctlr-&gt;max_dma_len)</span><br><span class="line">		ctlr-&gt;max_dma_len = INT_MAX;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register the device, then userspace will see it.</span></span><br><span class="line"><span class="comment">	 * registration fails if the bus ID is in use.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev_set_name(&amp;ctlr-&gt;dev, <span class="string">&quot;spi%u&quot;</span>, ctlr-&gt;bus_num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!spi_controller_is_slave(ctlr)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ctlr-&gt;use_gpio_descriptors) &#123;</span><br><span class="line">			status = spi_get_gpio_descs(ctlr);</span><br><span class="line">			<span class="keyword">if</span> (status)</span><br><span class="line">				<span class="keyword">goto</span> free_bus_id;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * A controller using GPIO descriptors always</span></span><br><span class="line"><span class="comment">			 * supports SPI_CS_HIGH if need be.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ctlr-&gt;mode_bits |= SPI_CS_HIGH;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Legacy code path for GPIOs from DT */</span></span><br><span class="line">			status = of_spi_get_gpio_numbers(ctlr);</span><br><span class="line">			<span class="keyword">if</span> (status)</span><br><span class="line">				<span class="keyword">goto</span> free_bus_id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Even if it&#x27;s just one always-selected device, there must</span></span><br><span class="line"><span class="comment">	 * be at least one chipselect.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ctlr-&gt;num_chipselect) &#123;</span><br><span class="line">		status = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> free_bus_id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status = device_add(&amp;ctlr-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_bus_id;</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;registered %s %s\n&quot;</span>,</span><br><span class="line">			spi_controller_is_slave(ctlr) ? <span class="string">&quot;slave&quot;</span> : <span class="string">&quot;master&quot;</span>,</span><br><span class="line">			dev_name(&amp;ctlr-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re using a queued driver, start the queue. Note that we don&#x27;t</span></span><br><span class="line"><span class="comment">	 * need the queueing logic if the driver is only supporting high-level</span></span><br><span class="line"><span class="comment">	 * memory operations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;transfer) &#123;</span><br><span class="line">		dev_info(dev, <span class="string">&quot;controller is unqueued, this is deprecated\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctlr-&gt;transfer_one || ctlr-&gt;transfer_one_message) &#123;</span><br><span class="line">		status = spi_controller_initialize_queue(ctlr);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			device_del(&amp;ctlr-&gt;dev);</span><br><span class="line">			<span class="keyword">goto</span> free_bus_id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* add statistics */</span></span><br><span class="line">	spin_lock_init(&amp;ctlr-&gt;statistics.lock);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;board_lock);</span><br><span class="line">	list_add_tail(&amp;ctlr-&gt;<span class="built_in">list</span>, &amp;spi_controller_list);</span><br><span class="line">	list_for_each_entry(bi, &amp;board_list, <span class="built_in">list</span>)</span><br><span class="line">		spi_match_controller_to_boardinfo(ctlr, &amp;bi-&gt;board_info);</span><br><span class="line">	mutex_unlock(&amp;board_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register devices from the device tree and ACPI */</span></span><br><span class="line">	of_register_spi_devices(ctlr);</span><br><span class="line">	acpi_register_spi_devices(ctlr);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">free_bus_id:</span><br><span class="line">	mutex_lock(&amp;board_lock);</span><br><span class="line">	idr_remove(&amp;spi_master_idr, ctlr-&gt;bus_num);</span><br><span class="line">	mutex_unlock(&amp;board_lock);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(spi_register_controller);</span><br></pre></td></tr></table></figure>

<p>在该函数的第 132行会调用设备树资源注册函数 <code>of_register_spi_devices</code> 对 SPI 的子节点设备树进行注册，该函数的具体内容如下所示：</p>
<h4 id="of-register-spi-devices"><a href="#of-register-spi-devices" class="headerlink" title="of_register_spi_devices()"></a>of_register_spi_devices()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_register_spi_devices() - Register child devices onto the SPI bus</span></span><br><span class="line"><span class="comment"> * @ctlr:	Pointer to spi_controller device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Registers an spi_device for each child node of controller node which</span></span><br><span class="line"><span class="comment"> * represents a valid SPI slave.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">of_register_spi_devices</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ctlr-&gt;dev.of_node)<span class="comment">// 如果控制器没有设备树节点，则直接返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历控制器设备树节点下的每个子节点</span></span><br><span class="line">	for_each_available_child_of_node(ctlr-&gt;dev.of_node, nc) &#123;</span><br><span class="line">		<span class="keyword">if</span> (of_node_test_and_set_flag(nc, OF_POPULATED))<span class="comment">// 如果该节点已被标记为已填充，则跳过该节点</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		spi = of_register_spi_device(ctlr, nc);<span class="comment">// 为该节点注册一个 SPI 设备</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(spi)) &#123;<span class="comment">// 如果注册失败，记录警告信息并清除该节点的已填充标记</span></span><br><span class="line">			dev_warn(&amp;ctlr-&gt;dev,</span><br><span class="line">				 <span class="string">&quot;Failed to create SPI device for %pOF\n&quot;</span>, nc);</span><br><span class="line">			of_node_clear_flag(nc, OF_POPULATED);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第17 行会遍历控制器设备树节点下的每个子节点，通过 <code>of_register_spi_device</code> 函数注册该 SPI 子节点，<code>of_register_spi_device</code> 函数具体内容如下所示：</p>
<h4 id="of-register-spi-device"><a href="#of-register-spi-device" class="headerlink" title="of_register_spi_device()"></a>of_register_spi_device()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> spi_device *</span><br><span class="line"><span class="title function_">of_register_spi_device</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr, <span class="keyword">struct</span> device_node *nc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span></span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alloc an spi_device */</span></span><br><span class="line">	spi = spi_alloc_device(ctlr);<span class="comment">/* 分配一个 spi_device */</span></span><br><span class="line">	<span class="keyword">if</span> (!spi) &#123;</span><br><span class="line">		dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;spi_device alloc error for %pOF\n&quot;</span>, nc);</span><br><span class="line">		rc = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Select device driver */</span></span><br><span class="line">    <span class="comment">/* 选择设备驱动 */</span></span><br><span class="line">	rc = of_modalias_node(nc, spi-&gt;modalias,</span><br><span class="line">				<span class="keyword">sizeof</span>(spi-&gt;modalias));</span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;cannot find modalias for %pOF\n&quot;</span>, nc);</span><br><span class="line">		<span class="keyword">goto</span> err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rc = of_spi_parse_dt(ctlr, spi, nc);<span class="comment">/* 解析设备树中的 SPI 信息 */</span></span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> err_out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store a pointer to the node in the device structure */</span></span><br><span class="line">	of_node_get(nc);<span class="comment">/* 在设备结构中存储指向节点的指针 */</span></span><br><span class="line">	spi-&gt;dev.of_node = nc;</span><br><span class="line">	spi-&gt;dev.fwnode = of_fwnode_handle(nc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register the new device */</span></span><br><span class="line">	rc = spi_add_device(spi);<span class="comment">/* 注册新设备 */</span></span><br><span class="line">	<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">		dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;spi_device register error %pOF\n&quot;</span>, nc);</span><br><span class="line">		<span class="keyword">goto</span> err_of_node_put;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> spi;</span><br><span class="line"></span><br><span class="line">err_of_node_put:</span><br><span class="line">	of_node_put(nc);</span><br><span class="line">err_out:</span><br><span class="line">	spi_dev_put(spi);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第 24 行调用了 <code>of_spi_parse_dt</code> 函数来解析设备树子节点中的 SPI 信息，<code>of_spi_parse_dt</code> 函数具体内容如下所示</p>
<h4 id="of-spi-parse-dt"><a href="#of-spi-parse-dt" class="headerlink" title="of_spi_parse_dt()"></a>of_spi_parse_dt()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_spi_parse_dt</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr, <span class="keyword">struct</span> spi_device *spi,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> device_node *nc)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 value;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Mode (clock phase/polarity/etc.) */</span> <span class="comment">/* 设置模式 (时钟相位/极性等) */</span></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-cpha&quot;</span>))</span><br><span class="line">		spi-&gt;mode |= SPI_CPHA;</span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-cpol&quot;</span>))</span><br><span class="line">		spi-&gt;mode |= SPI_CPOL;</span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-3wire&quot;</span>))</span><br><span class="line">		spi-&gt;mode |= SPI_3WIRE;</span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-lsb-first&quot;</span>))</span><br><span class="line">		spi-&gt;mode |= SPI_LSB_FIRST;</span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-cs-high&quot;</span>))</span><br><span class="line">		spi-&gt;mode |= SPI_CS_HIGH;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device DUAL/QUAD mode */</span></span><br><span class="line">    <span class="comment">/* 设置设备的 DUAL/QUAD 模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_property_read_u32(nc, <span class="string">&quot;spi-tx-bus-width&quot;</span>, &amp;value)) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (value) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			spi-&gt;mode |= SPI_TX_DUAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			spi-&gt;mode |= SPI_TX_QUAD;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			spi-&gt;mode |= SPI_TX_OCTAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			dev_warn(&amp;ctlr-&gt;dev,</span><br><span class="line">				<span class="string">&quot;spi-tx-bus-width %d not supported\n&quot;</span>,</span><br><span class="line">				value);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!of_property_read_u32(nc, <span class="string">&quot;spi-rx-bus-width&quot;</span>, &amp;value)) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (value) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			spi-&gt;mode |= SPI_RX_DUAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			spi-&gt;mode |= SPI_RX_QUAD;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			spi-&gt;mode |= SPI_RX_OCTAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			dev_warn(&amp;ctlr-&gt;dev,</span><br><span class="line">				<span class="string">&quot;spi-rx-bus-width %d not supported\n&quot;</span>,</span><br><span class="line">				value);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 如果是 SPI 从设备 */</span></span><br><span class="line">	<span class="keyword">if</span> (spi_controller_is_slave(ctlr)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!of_node_name_eq(nc, <span class="string">&quot;slave&quot;</span>)) &#123;</span><br><span class="line">			dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;%pOF is not called &#x27;slave&#x27;\n&quot;</span>,</span><br><span class="line">				nc);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device address */</span></span><br><span class="line">	rc = of_property_read_u32(nc, <span class="string">&quot;reg&quot;</span>, &amp;value);<span class="comment">/* 获取设备地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">		dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;%pOF has no valid &#x27;reg&#x27; property (%d)\n&quot;</span>,</span><br><span class="line">			nc, rc);</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line">	&#125;</span><br><span class="line">	spi-&gt;chip_select = value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device speed */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_property_read_u32(nc, <span class="string">&quot;spi-max-frequency&quot;</span>, &amp;value))<span class="comment">/* 获取设备速度 */</span></span><br><span class="line">		spi-&gt;max_speed_hz = value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果设备树不存在 <code>reg</code> 和 <code>spi-max-frequency</code> 两个属性则会返回 rc，这就导致上一级函数 <code>of_register_spi_device</code> 会返回错误，从而无法成功注册 SPI 设备、不能成功解析设备树节点，最终导致编写的 SPI 设备驱动无法正常匹配。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mcp2515_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一条消息,表示探测成功</span></span><br><span class="line">    printk(<span class="string">&quot;This is mcp2515 probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mcp2515_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备匹配表,用于设备树匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mcp2515_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;my-mcp2515&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备ID匹配表,用于总线匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">mcp2515_id_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;mcp2515&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515 SPI驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spi_mcp2515</span> =</span> &#123;</span><br><span class="line">    .probe = mcp2515_probe, <span class="comment">// 探测函数</span></span><br><span class="line">    .remove = mcp2515_remove, <span class="comment">// 移除函数</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;mcp2515&quot;</span>, <span class="comment">// 驱动名称</span></span><br><span class="line">        .owner = THIS_MODULE, <span class="comment">// 所属模块</span></span><br><span class="line">        .of_match_table = mcp2515_of_match_table, <span class="comment">// 设备树匹配表</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table = mcp2515_id_table, <span class="comment">// 设备ID匹配表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mcp2515_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册SPI驱动</span></span><br><span class="line">    ret = spi_register_driver(&amp;spi_mcp2515);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注册失败,打印错误信息</span></span><br><span class="line">        printk(<span class="string">&quot;spi_register_driver error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mcp2515_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销SPI驱动</span></span><br><span class="line">    spi_unregister_driver(&amp;spi_mcp2515);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mcp2515_init);</span><br><span class="line">module_exit(mcp2515_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="注册字符设备示例"><a href="#注册字符设备示例" class="headerlink" title="注册字符设备示例"></a>注册字符设备示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_t</span> dev_num; <span class="comment">// 设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">mcp2515_cdev</span>;</span> <span class="comment">// 字符设备结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">mcp2515_class</span>;</span> <span class="comment">// 设备类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">mcp2515_device</span>;</span> <span class="comment">// 设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi_dev</span>;</span> <span class="comment">// SPI设备指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515芯片复位函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mcp2515_reset</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> write_buf[] = &#123;<span class="number">0xc0</span>&#125;; <span class="comment">// 复位指令0x11000000即0xc0</span></span><br><span class="line">    ret = spi_write(spi_dev, write_buf, <span class="keyword">sizeof</span>(write_buf)); <span class="comment">// 发送复位命令</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;spi_write is error\n&quot;</span>); <span class="comment">// 打印错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515读寄存器函数</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">mcp2515_read_reg</span><span class="params">(<span class="type">char</span> reg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> write_buf[] = &#123;<span class="number">0x03</span>, reg&#125;;  <span class="comment">// SPI写缓冲区写入SPI读指令0x03</span></span><br><span class="line">    <span class="type">char</span> read_buf;                   <span class="comment">// SPI读缓冲区</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = spi_write_then_read(spi_dev, write_buf, <span class="keyword">sizeof</span>(write_buf), &amp;read_buf, <span class="keyword">sizeof</span>(read_buf));  <span class="comment">// 调用SPI写读函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;spi_write_then_read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开设备文件的回调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mcp2515_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取设备文件的回调函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mcp2515_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入设备文件的回调函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mcp2515_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭设备文件的回调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mcp2515_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备文件操作集合</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mcp2515_fops</span> =</span> &#123;</span><br><span class="line">    .open = mcp2515_open,</span><br><span class="line">    .read = mcp2515_read,</span><br><span class="line">    .write = mcp2515_write,</span><br><span class="line">    .release = mcp2515_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备初始化函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mcp2515_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is mcp2515_probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    spi_dev = spi; <span class="comment">// 保存SPI设备指针</span></span><br><span class="line">    <span class="comment">// 分配字符设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;mcp2515&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化字符设备</span></span><br><span class="line">    cdev_init(&amp;mcp2515_cdev, &amp;mcp2515_fops);</span><br><span class="line">    mcp2515_cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字符设备</span></span><br><span class="line">    ret = cdev_add(&amp;mcp2515_cdev, dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;cdev_add error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备类</span></span><br><span class="line">    mcp2515_class = class_create(THIS_MODULE, <span class="string">&quot;spi_to_can&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mcp2515_class)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;mcp2515_class error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mcp2515_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备</span></span><br><span class="line">    mcp2515_device = device_create(mcp2515_class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;mcp2515&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mcp2515_device)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;mcp2515_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mcp2515_device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mcp2515_reset();             <span class="comment">// 复位MCP2515设备</span></span><br><span class="line">    value = mcp2515_read_reg(<span class="number">0x0e</span>);  <span class="comment">// 读取寄存器值</span></span><br><span class="line">    printk(<span class="string">&quot;value is %x\n&quot;</span>, value);  <span class="comment">// 打印读取的值</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515 SPI设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mcp2515_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">    device_destroy(mcp2515_class, dev_num);</span><br><span class="line">    class_destroy(mcp2515_class);</span><br><span class="line">    cdev_del(&amp;mcp2515_cdev);</span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备匹配表,用于设备树匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mcp2515_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;my-mcp2515&quot;</span> &#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备ID匹配表,用于总线匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">mcp2515_id_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;mcp2515&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515 SPI驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spi_mcp2515</span> =</span> &#123;</span><br><span class="line">    .probe = mcp2515_probe, <span class="comment">// 探测函数</span></span><br><span class="line">    .remove = mcp2515_remove, <span class="comment">// 移除函数</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;mcp2515&quot;</span>, <span class="comment">// 驱动名称</span></span><br><span class="line">        .owner = THIS_MODULE, <span class="comment">// 所属模块</span></span><br><span class="line">        .of_match_table = mcp2515_of_match_table, <span class="comment">// 设备树匹配表</span></span><br><span class="line">&#125;,</span><br><span class="line">    .id_table = mcp2515_id_table, <span class="comment">// 设备ID匹配表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mcp2515_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册SPI驱动</span></span><br><span class="line">    ret = spi_register_driver(&amp;spi_mcp2515);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注册失败,打印错误信息</span></span><br><span class="line">        printk(<span class="string">&quot;spi_register_driver error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mcp2515_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销SPI驱动</span></span><br><span class="line">    spi_unregister_driver(&amp;spi_mcp2515);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mcp2515_init);</span><br><span class="line">module_exit(mcp2515_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="SPI通信流程"><a href="#SPI通信流程" class="headerlink" title="SPI通信流程"></a>SPI通信流程</h1><p>在 Linux 驱动中可以使用 <code>spi_write</code> 函数来实现向 SPI 从设备发送数据，<code>spi_write</code> 函数定义在 <code>include/linux/spi/spi.h</code> 文件中，具体内容如下所示</p>
<h2 id="spi-write"><a href="#spi-write" class="headerlink" title="spi_write()"></a>spi_write()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_write - SPI synchronous write</span></span><br><span class="line"><span class="comment"> * @spi: device to which data will be written</span></span><br><span class="line"><span class="comment"> * @buf: data buffer</span></span><br><span class="line"><span class="comment"> * @len: data buffer size</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function writes the buffer @buf.</span></span><br><span class="line"><span class="comment"> * Callable only from contexts that can sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">spi_write</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>	<span class="title">t</span> =</span> &#123;</span><br><span class="line">			.tx_buf		= buf,</span><br><span class="line">			.len		= len,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先会对要传输的数据以及传输的数据大小进行封装，然后调用 <code>spi_sync_transfer</code>函数进行输入传输，<code>spi_write</code> 函数传入的第一个参数为 <code>spi_device</code> 类型的结构体变量。</p>
<p><code>struct spi_device</code> 是 Linux 内核中用于描述 SPI 从设备的结构体。它包含了与 SPI 设备相关的各种信息和配置选项，该结构体的具体内容如下所示：</p>
<h2 id="struct-spi-device"><a href="#struct-spi-device" class="headerlink" title="struct spi_device"></a>struct spi_device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct spi_device - Controller side proxy for an SPI slave device</span></span><br><span class="line"><span class="comment"> * @dev: Driver model representation of the device.</span></span><br><span class="line"><span class="comment"> * @controller: SPI controller used with the device.</span></span><br><span class="line"><span class="comment"> * @master: Copy of controller, for backwards compatibility.</span></span><br><span class="line"><span class="comment"> * @max_speed_hz: Maximum clock rate to be used with this chip</span></span><br><span class="line"><span class="comment"> *	(on this board); may be changed by the device&#x27;s driver.</span></span><br><span class="line"><span class="comment"> *	The spi_transfer.speed_hz can override this for each transfer.</span></span><br><span class="line"><span class="comment"> * @chip_select: Chipselect, distinguishing chips handled by @controller.</span></span><br><span class="line"><span class="comment"> * @mode: The spi mode defines how data is clocked out and in.</span></span><br><span class="line"><span class="comment"> *	This may be changed by the device&#x27;s driver.</span></span><br><span class="line"><span class="comment"> *	The &quot;active low&quot; default for chipselect mode can be overridden</span></span><br><span class="line"><span class="comment"> *	(by specifying SPI_CS_HIGH) as can the &quot;MSB first&quot; default for</span></span><br><span class="line"><span class="comment"> *	each word in a transfer (by specifying SPI_LSB_FIRST).</span></span><br><span class="line"><span class="comment"> * @bits_per_word: Data transfers involve one or more words; word sizes</span></span><br><span class="line"><span class="comment"> *	like eight or 12 bits are common.  In-memory wordsizes are</span></span><br><span class="line"><span class="comment"> *	powers of two bytes (e.g. 20 bit samples use 32 bits).</span></span><br><span class="line"><span class="comment"> *	This may be changed by the device&#x27;s driver, or left at the</span></span><br><span class="line"><span class="comment"> *	default (0) indicating protocol words are eight bit bytes.</span></span><br><span class="line"><span class="comment"> *	The spi_transfer.bits_per_word can override this for each transfer.</span></span><br><span class="line"><span class="comment"> * @rt: Make the pump thread real time priority.</span></span><br><span class="line"><span class="comment"> * @irq: Negative, or the number passed to request_irq() to receive</span></span><br><span class="line"><span class="comment"> *	interrupts from this device.</span></span><br><span class="line"><span class="comment"> * @controller_state: Controller&#x27;s runtime state</span></span><br><span class="line"><span class="comment"> * @controller_data: Board-specific definitions for controller, such as</span></span><br><span class="line"><span class="comment"> *	FIFO initialization parameters; from board_info.controller_data</span></span><br><span class="line"><span class="comment"> * @modalias: Name of the driver to use with this device, or an alias</span></span><br><span class="line"><span class="comment"> *	for that name.  This appears in the sysfs &quot;modalias&quot; attribute</span></span><br><span class="line"><span class="comment"> *	for driver coldplugging, and in uevents used for hotplugging</span></span><br><span class="line"><span class="comment"> * @driver_override: If the name of a driver is written to this attribute, then</span></span><br><span class="line"><span class="comment"> *	the device will bind to the named driver and only the named driver.</span></span><br><span class="line"><span class="comment"> * @cs_gpio: LEGACY: gpio number of the chipselect line (optional, -ENOENT when</span></span><br><span class="line"><span class="comment"> *	not using a GPIO line) use cs_gpiod in new drivers by opting in on</span></span><br><span class="line"><span class="comment"> *	the spi_master.</span></span><br><span class="line"><span class="comment"> * @cs_gpiod: gpio descriptor of the chipselect line (optional, NULL when</span></span><br><span class="line"><span class="comment"> *	not using a GPIO line)</span></span><br><span class="line"><span class="comment"> * @word_delay: delay to be inserted between consecutive</span></span><br><span class="line"><span class="comment"> *	words of a transfer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @statistics: statistics for the spi_device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A @spi_device is used to interchange data between an SPI slave</span></span><br><span class="line"><span class="comment"> * (usually a discrete chip) and CPU memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In @dev, the platform_data is used to hold information about this</span></span><br><span class="line"><span class="comment"> * device that&#x27;s meaningful to the device&#x27;s protocol driver, but not</span></span><br><span class="line"><span class="comment"> * to its controller.  One example might be an identifier for a chip</span></span><br><span class="line"><span class="comment"> * variant with slightly different functionality; another might be</span></span><br><span class="line"><span class="comment"> * information about how this particular board wires the chip&#x27;s pins.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">dev</span>;</span> <span class="comment">// 通用设备模型的设备结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">controller</span>;</span> <span class="comment">// 指向控制器的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">master</span>;</span>	<span class="comment">/* compatibility layer */</span> <span class="comment">// 兼容层，指向控制器的指针（与 controller 相同）</span></span><br><span class="line">	u32			max_speed_hz;<span class="comment">// 设备支持的最大速度（以赫兹为单位</span></span><br><span class="line">	u8			chip_select;<span class="comment">// 片选编号</span></span><br><span class="line">	u8			bits_per_word;<span class="comment">// 每个字的位数</span></span><br><span class="line">	<span class="type">bool</span>			rt;</span><br><span class="line">	u32			mode;<span class="comment">// SPI 模式配置（包括时钟相位和极性等）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPHA	0x01			<span class="comment">/* clock phase */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPOL	0x02			<span class="comment">/* clock polarity */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_0	(0|0)			<span class="comment">/* (original MicroWire) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_1	(0|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_2	(SPI_CPOL|0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_HIGH	0x04			<span class="comment">/* chipselect active high? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LSB_FIRST	0x08			<span class="comment">/* per-word bits-on-wire */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE	0x10			<span class="comment">/* SI/SO signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LOOP	0x20			<span class="comment">/* loopback mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NO_CS	0x40			<span class="comment">/* 1 dev/bus, no chipselect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_READY	0x80			<span class="comment">/* slave pulls low to pause */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_DUAL	0x100			<span class="comment">/* transmit with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_QUAD	0x200			<span class="comment">/* transmit with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_DUAL	0x400			<span class="comment">/* receive with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_QUAD	0x800			<span class="comment">/* receive with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_WORD	0x1000			<span class="comment">/* toggle cs after each word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_OCTAL	0x2000			<span class="comment">/* transmit with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_OCTAL	0x4000			<span class="comment">/* receive with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE_HIZ	0x8000			<span class="comment">/* high impedance turnaround */</span></span></span><br><span class="line">	<span class="type">int</span>			irq;</span><br><span class="line">	<span class="type">void</span>			*controller_state; <span class="comment">// 控制器状态的私有数据</span></span><br><span class="line">	<span class="type">void</span>			*controller_data; <span class="comment">// 控制器数据的私有数据</span></span><br><span class="line">	<span class="type">char</span>			modalias[SPI_NAME_SIZE];<span class="comment">// 设备别名</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*driver_override;<span class="comment">// 驱动程序覆盖</span></span><br><span class="line">	<span class="type">int</span>			cs_gpio;	<span class="comment">/* LEGACY: chip select gpio */</span> <span class="comment">// 片选 GPIO 引脚</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>	*<span class="title">cs_gpiod</span>;</span>	<span class="comment">/* chip select gpio desc */</span> <span class="comment">// 片选 GPIO 引脚</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">word_delay</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the statistics */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_statistics</span>	<span class="title">statistics</span>;</span><span class="comment">// 统计数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * likely need more hooks for more protocol options affecting how</span></span><br><span class="line"><span class="comment">	 * the controller talks to each chip, like:</span></span><br><span class="line"><span class="comment">	 *  - memory packing (12 bit samples into low bits, others zeroed)</span></span><br><span class="line"><span class="comment">	 *  - priority</span></span><br><span class="line"><span class="comment">	 *  - chipselect delays</span></span><br><span class="line"><span class="comment">	 *  - ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>spi_write</code> 函数可以向 SPI 从设备发送数据，而 <code>spi_read</code> 函数可以接收从设备发送的数据，<code>spi_read</code> 函数具体内容如下所示：</p>
<h2 id="spi-read"><a href="#spi-read" class="headerlink" title="spi_read()"></a>spi_read()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_read - SPI synchronous read</span></span><br><span class="line"><span class="comment"> * @spi: device from which data will be read</span></span><br><span class="line"><span class="comment"> * @buf: data buffer</span></span><br><span class="line"><span class="comment"> * @len: data buffer size</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function reads the buffer @buf.</span></span><br><span class="line"><span class="comment"> * Callable only from contexts that can sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">spi_read</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>	<span class="title">t</span> =</span> &#123;</span><br><span class="line">			.rx_buf		= buf,</span><br><span class="line">			.len		= len,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟 <code>spi_write</code> 函数相同，<code>spi_read</code> 函数也会对数据进行封包的操作，将数据 buf 以及数据大小 len 封包成 <code>spi_transfer</code> 类型的结构体，<code>struct spi_transfer</code> 是一个描述 SPI 数据传输的结构体，用于配置一次 SPI 数据传输的各种参数，该结构体的具体内容如下所示：</p>
<h3 id="struct-spi-transfer"><a href="#struct-spi-transfer" class="headerlink" title="struct spi_transfer"></a>struct spi_transfer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line">	<span class="comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span></span><br><span class="line"><span class="comment">	 * for MicroWire, one buffer must be null</span></span><br><span class="line"><span class="comment">	 * buffers must work with dma_*map_single() calls, unless</span></span><br><span class="line"><span class="comment">	 *   spi_message.is_dma_mapped reports a pre-existing mapping</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span>	*tx_buf;<span class="comment">// 发送缓冲区</span></span><br><span class="line">	<span class="type">void</span>		*rx_buf;<span class="comment">// 接收缓冲区</span></span><br><span class="line">	<span class="type">unsigned</span>	len;<span class="comment">// 传输数据的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="type">dma_addr_t</span>	tx_dma;<span class="comment">// 发送缓冲区的 DMA 地址</span></span><br><span class="line">	<span class="type">dma_addr_t</span>	rx_dma;<span class="comment">// 接收缓冲区的 DMA 地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">tx_sg</span>;</span><span class="comment">// 发送缓冲区的散列-聚集表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">rx_sg</span>;</span><span class="comment">// 接收缓冲区的散列-聚集表</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span>	cs_change:<span class="number">1</span>;<span class="comment">// 是否在传输后改变片选状态</span></span><br><span class="line">	<span class="type">unsigned</span>	tx_nbits:<span class="number">3</span>;<span class="comment">// 发送的位数（单线、双线或四线传输）</span></span><br><span class="line">	<span class="type">unsigned</span>	rx_nbits:<span class="number">3</span>;<span class="comment">// 接收的位数（单线、双线或四线传输）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NBITS_SINGLE	0x01 <span class="comment">/* 1bit transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NBITS_DUAL		0x02 <span class="comment">/* 2bits transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NBITS_QUAD		0x04 <span class="comment">/* 4bits transfer */</span></span></span><br><span class="line">	u8		bits_per_word;<span class="comment">// 每个字的位数</span></span><br><span class="line">	u16		delay_usecs;<span class="comment">// 传输之间的延迟（微秒）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">delay</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">cs_change_delay</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">word_delay</span>;</span><span class="comment">// 每个字之间的延迟</span></span><br><span class="line">	u32		speed_hz;<span class="comment">// 传输速度（赫兹）</span></span><br><span class="line"></span><br><span class="line">	u32		effective_speed_hz;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	ptp_sts_word_pre;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	ptp_sts_word_post;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ptp_system_timestamp</span> *<span class="title">ptp_sts</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>		timestamped;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_TRANS_FAIL_NO_START	BIT(0)</span></span><br><span class="line">	u16		error;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="spi-sync-transfer"><a href="#spi-sync-transfer" class="headerlink" title="spi_sync_transfer()"></a>spi_sync_transfer()</h3><p>而 <code>spi_write</code> 函数和 <code>spi_read</code> 函数只差在<code>struct spi_transfer</code> 结构体参数的不同，而封装为<code>struct spi_transfer</code> 之后还需要再一次进行封装，<code>spi_write</code> 函数和 <code>spi_read</code> 函数最后都会调用<code>spi_sync_transfer</code> 函数，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_sync_transfer - synchronous SPI data transfer</span></span><br><span class="line"><span class="comment"> * @spi: device with which data will be exchanged</span></span><br><span class="line"><span class="comment"> * @xfers: An array of spi_transfers</span></span><br><span class="line"><span class="comment"> * @num_xfers: Number of items in the xfer array</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Does a synchronous SPI data transfer of the given spi_transfer array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For more specific semantics see spi_sync().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">spi_sync_transfer</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_transfer *xfers,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> num_xfers)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="comment">// 使用给定的传输初始化 SPI 消息</span></span><br><span class="line">	spi_message_init_with_transfers(&amp;msg, xfers, num_xfers);</span><br><span class="line">	<span class="comment">// 同步方式发送 SPI 消息</span></span><br><span class="line">	<span class="keyword">return</span> spi_sync(spi, &amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数主要用于封装 SPI 同步传输操作，简化了调用过程。调用了 <code>spi_message_init_with_transfers</code> 函数进行 SPI 传输数据的初始化，最后调用 <code>spi_sync</code> 函数采用同步的方式发送 SPI 数据，<code>spi_sync</code> 函数的具体内容如下所示：</p>
<h3 id="spi-sync"><a href="#spi-sync" class="headerlink" title="spi_sync()"></a>spi_sync()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_sync - blocking/synchronous SPI data transfers</span></span><br><span class="line"><span class="comment"> * @spi: device with which data will be exchanged</span></span><br><span class="line"><span class="comment"> * @message: describes the data transfers</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call may only be used from a context that may sleep.  The sleep</span></span><br><span class="line"><span class="comment"> * is non-interruptible, and has no timeout.  Low-overhead controller</span></span><br><span class="line"><span class="comment"> * drivers may DMA directly into and out of the message buffers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the SPI device&#x27;s chip select is active during the message,</span></span><br><span class="line"><span class="comment"> * and then is normally disabled between messages.  Drivers for some</span></span><br><span class="line"><span class="comment"> * frequently-used devices may want to minimize costs of selecting a chip,</span></span><br><span class="line"><span class="comment"> * by leaving it selected in anticipation that the next message will go</span></span><br><span class="line"><span class="comment"> * to the same chip.  (That may increase power usage.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also, the caller is guaranteeing that the memory associated with the</span></span><br><span class="line"><span class="comment"> * message will not be freed before this call returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi_sync</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// 锁定 SPI 控制器的总线锁互斥体</span></span><br><span class="line">	mutex_lock(&amp;spi-&gt;controller-&gt;bus_lock_mutex);</span><br><span class="line">    <span class="comment">// 执行同步 SPI 传输</span></span><br><span class="line">	ret = __spi_sync(spi, message);</span><br><span class="line">    <span class="comment">// 解锁 SPI 控制器的总线锁互斥体</span></span><br><span class="line">	mutex_unlock(&amp;spi-&gt;controller-&gt;bus_lock_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(spi_sync);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数的主要作用是确保 SPI 数据传输操作在一个互斥锁的保护下进行，以避免并发传输导致的冲突和数据错误。</p>
<p>通过调用内部的 <code>__spi_sync</code> 函数来执行实际的数据传输。<code>__spi_sync</code>函数如下所示</p>
<h3 id="spi-sync-1"><a href="#spi-sync-1" class="headerlink" title="__spi_sync()"></a>__spi_sync()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __spi_sync(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明并初始化一个完成变量</span></span><br><span class="line">	DECLARE_COMPLETION_ONSTACK(done);</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> *<span class="title">ctlr</span> =</span> spi-&gt;controller;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="comment">// 验证 SPI 设备和消息</span></span><br><span class="line">	status = __spi_validate(spi, message);</span><br><span class="line">	<span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 设置消息完成回调和上下文</span></span><br><span class="line">	message-&gt;complete = spi_complete;</span><br><span class="line">	message-&gt;context = &amp;done;</span><br><span class="line">	message-&gt;spi = spi;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 更新统计信息</span></span><br><span class="line">	SPI_STATISTICS_INCREMENT_FIELD(&amp;ctlr-&gt;statistics, spi_sync);</span><br><span class="line">	SPI_STATISTICS_INCREMENT_FIELD(&amp;spi-&gt;statistics, spi_sync);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we&#x27;re not using the legacy transfer method then we will</span></span><br><span class="line"><span class="comment">	 * try to transfer in the calling context so special case.</span></span><br><span class="line"><span class="comment">	 * This code would be less tricky if we could remove the</span></span><br><span class="line"><span class="comment">	 * support for driver implemented message queues.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;transfer == spi_queued_transfer) &#123;</span><br><span class="line">		spin_lock_irqsave(&amp;ctlr-&gt;bus_lock_spinlock, flags);<span class="comment">// 锁定总线锁旋转锁并保存中断标志</span></span><br><span class="line"></span><br><span class="line">		trace_spi_message_submit(message);<span class="comment">// 记录 SPI 消息提交的跟踪信息</span></span><br><span class="line"></span><br><span class="line">		status = __spi_queued_transfer(spi, message, <span class="literal">false</span>);<span class="comment">// 执行队列传输</span></span><br><span class="line"></span><br><span class="line">		spin_unlock_irqrestore(&amp;ctlr-&gt;bus_lock_spinlock, flags);<span class="comment">// 解锁总线锁旋转锁并恢复中断标志</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		status = spi_async_locked(spi, message);<span class="comment">// 异步锁定传输</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Push out the messages in the calling context if we</span></span><br><span class="line"><span class="comment">		 * can.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ctlr-&gt;transfer == spi_queued_transfer) &#123;<span class="comment">/* 如果可以，则在调用上下文中推送消息 */</span></span><br><span class="line">            <span class="comment">// 更新同步立即传输的统计信息</span></span><br><span class="line">			SPI_STATISTICS_INCREMENT_FIELD(&amp;ctlr-&gt;statistics,</span><br><span class="line">						       spi_sync_immediate);</span><br><span class="line">			SPI_STATISTICS_INCREMENT_FIELD(&amp;spi-&gt;statistics,</span><br><span class="line">						       spi_sync_immediate);</span><br><span class="line">            <span class="comment">// 推送消息</span></span><br><span class="line">			__spi_pump_messages(ctlr, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 等待完成</span></span><br><span class="line">		wait_for_completion(&amp;done);</span><br><span class="line">        <span class="comment">// 获取消息的状态</span></span><br><span class="line">		status = message-&gt;status;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 清除消息的上下文</span></span><br><span class="line">	message-&gt;context = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数的主要作用是在锁定的上下文中同步执行 SPI 消息传输。它负责初始化传输消息，验证消息和设备的有效性，处理传输，并在完成后返回传输的状态。该函数的重点在<code>__spi_pump_messages</code> 推送消息函数，该函数的具体内容如下所示：</p>
<h3 id="spi-pump-messages"><a href="#spi-pump-messages" class="headerlink" title="__spi_pump_messages()"></a>__spi_pump_messages()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __spi_pump_messages - function which processes spi message queue</span></span><br><span class="line"><span class="comment"> * @ctlr: controller to process queue for</span></span><br><span class="line"><span class="comment"> * @in_kthread: true if we are in the context of the message pump thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function checks if there is any spi message in the queue that</span></span><br><span class="line"><span class="comment"> * needs processing and if so call out to the driver to initialize hardware</span></span><br><span class="line"><span class="comment"> * and transfer each message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that it is called both from the kthread itself and also from</span></span><br><span class="line"><span class="comment"> * inside spi_sync(); the queue extraction handling at the top of the</span></span><br><span class="line"><span class="comment"> * function should deal with this safely.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __spi_pump_messages(<span class="keyword">struct</span> spi_controller *ctlr, <span class="type">bool</span> in_kthread)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">xfer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="type">bool</span> was_busy = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock queue */</span></span><br><span class="line">	spin_lock_irqsave(&amp;ctlr-&gt;queue_lock, flags);<span class="comment">/* 锁定消息队列 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we are not already running a message */</span></span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;cur_msg) &#123;<span class="comment">/* 确保没有其他消息正在处理 */</span></span><br><span class="line">		spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If another context is idling the device then defer */</span></span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;idling) &#123;<span class="comment">/* 如果另一个上下文正在空闲设备，则推迟处理 */</span></span><br><span class="line">		kthread_queue_work(ctlr-&gt;kworker, &amp;ctlr-&gt;pump_messages);</span><br><span class="line">		spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if the queue is idle */</span></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;ctlr-&gt;<span class="built_in">queue</span>) || !ctlr-&gt;running) &#123;<span class="comment">/* 检查队列是否空闲 */</span></span><br><span class="line">		<span class="keyword">if</span> (!ctlr-&gt;busy) &#123;</span><br><span class="line">			spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Defer any non-atomic teardown to the thread */</span></span><br><span class="line">		<span class="keyword">if</span> (!in_kthread) &#123;<span class="comment">/* 只有在线程中执行拆除操作 */</span></span><br><span class="line">			<span class="keyword">if</span> (!ctlr-&gt;dummy_rx &amp;&amp; !ctlr-&gt;dummy_tx &amp;&amp;</span><br><span class="line">			    !ctlr-&gt;unprepare_transfer_hardware) &#123;</span><br><span class="line">				spi_idle_runtime_pm(ctlr);</span><br><span class="line">				ctlr-&gt;busy = <span class="literal">false</span>;</span><br><span class="line">				trace_spi_controller_idle(ctlr);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				kthread_queue_work(ctlr-&gt;kworker,</span><br><span class="line">						   &amp;ctlr-&gt;pump_messages);</span><br><span class="line">			&#125;</span><br><span class="line">			spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ctlr-&gt;busy = <span class="literal">false</span>;</span><br><span class="line">		ctlr-&gt;idling = <span class="literal">true</span>;</span><br><span class="line">		spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"></span><br><span class="line">		kfree(ctlr-&gt;dummy_rx);</span><br><span class="line">		ctlr-&gt;dummy_rx = <span class="literal">NULL</span>;</span><br><span class="line">		kfree(ctlr-&gt;dummy_tx);</span><br><span class="line">		ctlr-&gt;dummy_tx = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (ctlr-&gt;unprepare_transfer_hardware &amp;&amp;</span><br><span class="line">		    ctlr-&gt;unprepare_transfer_hardware(ctlr))</span><br><span class="line">			dev_err(&amp;ctlr-&gt;dev,</span><br><span class="line">				<span class="string">&quot;failed to unprepare transfer hardware\n&quot;</span>);</span><br><span class="line">		spi_idle_runtime_pm(ctlr);</span><br><span class="line">		trace_spi_controller_idle(ctlr);</span><br><span class="line"></span><br><span class="line">		spin_lock_irqsave(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line">		ctlr-&gt;idling = <span class="literal">false</span>;</span><br><span class="line">		spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extract head of queue */</span></span><br><span class="line">	msg = list_first_entry(&amp;ctlr-&gt;<span class="built_in">queue</span>, <span class="keyword">struct</span> spi_message, <span class="built_in">queue</span>);<span class="comment">/* 从队列中获取第一个消息 */</span></span><br><span class="line">	ctlr-&gt;cur_msg = msg;</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;msg-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;busy)</span><br><span class="line">		was_busy = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ctlr-&gt;busy = <span class="literal">true</span>;</span><br><span class="line">	spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!was_busy &amp;&amp; ctlr-&gt;auto_runtime_pm) &#123;</span><br><span class="line">		ret = pm_runtime_get_sync(ctlr-&gt;dev.parent);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			pm_runtime_put_noidle(ctlr-&gt;dev.parent);</span><br><span class="line">			dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;Failed to power device: %d\n&quot;</span>,</span><br><span class="line">				ret);</span><br><span class="line">			mutex_unlock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!was_busy)</span><br><span class="line">		trace_spi_controller_busy(ctlr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!was_busy &amp;&amp; ctlr-&gt;prepare_transfer_hardware) &#123;</span><br><span class="line">		ret = ctlr-&gt;prepare_transfer_hardware(ctlr);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(&amp;ctlr-&gt;dev,</span><br><span class="line">				<span class="string">&quot;failed to prepare transfer hardware: %d\n&quot;</span>,</span><br><span class="line">				ret);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ctlr-&gt;auto_runtime_pm)</span><br><span class="line">				pm_runtime_put(ctlr-&gt;dev.parent);</span><br><span class="line"></span><br><span class="line">			msg-&gt;status = ret;</span><br><span class="line">			spi_finalize_current_message(ctlr);</span><br><span class="line"></span><br><span class="line">			mutex_unlock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_spi_message_start(msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctlr-&gt;prepare_message) &#123;</span><br><span class="line">		ret = ctlr-&gt;prepare_message(ctlr, msg);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;failed to prepare message: %d\n&quot;</span>,</span><br><span class="line">				ret);</span><br><span class="line">			msg-&gt;status = ret;</span><br><span class="line">			spi_finalize_current_message(ctlr);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		ctlr-&gt;cur_msg_prepared = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = spi_map_msg(ctlr, msg);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		msg-&gt;status = ret;</span><br><span class="line">		spi_finalize_current_message(ctlr);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ctlr-&gt;ptp_sts_supported &amp;&amp; !ctlr-&gt;transfer_one) &#123;</span><br><span class="line">		list_for_each_entry(xfer, &amp;msg-&gt;transfers, transfer_list) &#123;</span><br><span class="line">			xfer-&gt;ptp_sts_word_pre = <span class="number">0</span>;</span><br><span class="line">			ptp_read_system_prets(xfer-&gt;ptp_sts);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = ctlr-&gt;transfer_one_message(ctlr, msg);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;ctlr-&gt;dev,</span><br><span class="line">			<span class="string">&quot;failed to transfer one message from queue\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prod the scheduler in case transfer_one() was busy waiting */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret)<span class="comment">/* 如果成功传输，则唤醒调度器 *</span></span><br><span class="line"><span class="comment">		cond_resched();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<p>代码 <code>ctlr-&gt;transfer_one_message</code> 是一个函数指针，它指向了 SPI 控制器中负责执行 SPI 消息传输的函数。通过调用这个函数，将当前的 SPI 消息 <code>ctlr-&gt;cur_msg</code> 传递给该函数进行处理。这个函数通常会负责将消息的数据发送到 SPI 设备或从设备接收数据，并与硬件设备进行通信。</p>
<p>因此，<code>ctlr-&gt;transfer_one_message(ctlr, ctlr-&gt;cur_msg)</code>这一行代码的作用是将当前的 SPI 消息传递给 SPI 控制器中的传输函数进行处理，以完成消息的传输操作。</p>
<h3 id="spi-write-then-read"><a href="#spi-write-then-read" class="headerlink" title="spi_write_then_read()"></a>spi_write_then_read()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_write_then_read - SPI synchronous write followed by read</span></span><br><span class="line"><span class="comment"> * @spi: device with which data will be exchanged</span></span><br><span class="line"><span class="comment"> * @txbuf: data to be written (need not be dma-safe)</span></span><br><span class="line"><span class="comment"> * @n_tx: size of txbuf, in bytes</span></span><br><span class="line"><span class="comment"> * @rxbuf: buffer into which data will be read (need not be dma-safe)</span></span><br><span class="line"><span class="comment"> * @n_rx: size of rxbuf, in bytes</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This performs a half duplex MicroWire style transaction with the</span></span><br><span class="line"><span class="comment"> * device, sending txbuf and then reading rxbuf.  The return value</span></span><br><span class="line"><span class="comment"> * is zero for success, else a negative errno status code.</span></span><br><span class="line"><span class="comment"> * This call may only be used from a context that may sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parameters to this routine are always copied using a small buffer.</span></span><br><span class="line"><span class="comment"> * Performance-sensitive or bulk transfer code should instead use</span></span><br><span class="line"><span class="comment"> * spi_&#123;async,sync&#125;() calls with dma-safe buffers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi_write_then_read</span><span class="params">(<span class="keyword">struct</span> spi_device *spi,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="type">void</span> *txbuf, <span class="type">unsigned</span> n_tx,</span></span><br><span class="line"><span class="params">		<span class="type">void</span> *rxbuf, <span class="type">unsigned</span> n_rx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="title function_">DEFINE_MUTEX</span><span class="params">(lock)</span>;<span class="comment">// 定义一个静态互斥锁</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span>	<span class="title">message</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>	<span class="title">x</span>[2];</span></span><br><span class="line">	u8			*local_buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use preallocated DMA-safe buffer if we can.  We can&#x27;t avoid</span></span><br><span class="line"><span class="comment">	 * copying here, (as a pure convenience thing), but we can</span></span><br><span class="line"><span class="comment">	 * keep heap costs out of the hot path unless someone else is</span></span><br><span class="line"><span class="comment">	 * using the pre-allocated buffer or the transfer is too large.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((n_tx + n_rx) &gt; SPI_BUFSIZ || !mutex_trylock(&amp;lock)) &#123;</span><br><span class="line">		local_buf = kmalloc(max((<span class="type">unsigned</span>)SPI_BUFSIZ, n_tx + n_rx),</span><br><span class="line">				    GFP_KERNEL | GFP_DMA);</span><br><span class="line">		<span class="keyword">if</span> (!local_buf)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM; <span class="comment">// 如果内存分配失败，返回错误码</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		local_buf = buf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spi_message_init(&amp;message);<span class="comment">// 初始化 SPI 消息</span></span><br><span class="line">	<span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">	<span class="keyword">if</span> (n_tx) &#123;</span><br><span class="line">		x[<span class="number">0</span>].len = n_tx;</span><br><span class="line">		spi_message_add_tail(&amp;x[<span class="number">0</span>], &amp;message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n_rx) &#123;</span><br><span class="line">		x[<span class="number">1</span>].len = n_rx;</span><br><span class="line">		spi_message_add_tail(&amp;x[<span class="number">1</span>], &amp;message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(local_buf, txbuf, n_tx);<span class="comment">// 将发送数据复制到本地缓冲区</span></span><br><span class="line">	x[<span class="number">0</span>].tx_buf = local_buf;</span><br><span class="line">	x[<span class="number">1</span>].rx_buf = local_buf + n_tx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do the i/o */</span></span><br><span class="line">	status = spi_sync(spi, &amp;message);<span class="comment">/* 执行 I/O 操作 */</span></span><br><span class="line">	<span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">memcpy</span>(rxbuf, x[<span class="number">1</span>].rx_buf, n_rx);<span class="comment">// 如果传输成功，将接收数据复制到接收缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x[<span class="number">0</span>].tx_buf == buf)<span class="comment">// 释放锁或释放内存</span></span><br><span class="line">		mutex_unlock(&amp;lock);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		kfree(local_buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;<span class="comment">// 返回传输状态</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(spi_write_then_read);</span><br></pre></td></tr></table></figure>



<h1 id="mcp2515-驱动编写"><a href="#mcp2515-驱动编写" class="headerlink" title="mcp2515 驱动编写"></a>mcp2515 驱动编写</h1><h2 id="复位函数"><a href="#复位函数" class="headerlink" title="复位函数"></a>复位函数</h2><p>MCP2515 具有五种模式，分别为：</p>
<ul>
<li>配置模式</li>
<li>正常模式</li>
<li>休眠模式</li>
<li>仅监听模式</li>
<li>环回模式</li>
</ul>
<emp>只有在配置模式下，才能对关键寄存器进行初始化和配置</emp>，当 MCP2515 上电或者复位时，器件会自动进入配置模式，而 MCP2515 提供了一系列的 SPI 指令，SPI 指令表如下图所示：

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144052698.png" alt="MCP2515 指令集" loading="lazy">通过向 MCP2515 发送上述 SPI 指令就能实现复位、读、写等操作，复位操作对应的指令格式为 <code>11000000</code>。示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi_dev</span>;</span> <span class="comment">// SPI 设备指针</span></span><br><span class="line"><span class="comment">// MCP2515 芯片复位函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mcp2515_reset</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> write_buf[] = &#123;<span class="number">0xc0</span>&#125;; <span class="comment">// 复位指令 0x11000000 即 0xc0</span></span><br><span class="line">	ret = spi_write(spi_dev, write_buf, <span class="keyword">sizeof</span>(write_buf)); <span class="comment">// 发送复位命令</span></span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;spi_write is error\n&quot;</span>); <span class="comment">// 打印错误信息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读寄存器函数"><a href="#读寄存器函数" class="headerlink" title="读寄存器函数"></a>读寄存器函数</h2><p>TODO</p>
<h2 id="配置模式下寄存器的配置"><a href="#配置模式下寄存器的配置" class="headerlink" title="配置模式下寄存器的配置"></a>配置模式下寄存器的配置</h2><p>TOOD</p>
<h2 id="修改工作模式"><a href="#修改工作模式" class="headerlink" title="修改工作模式"></a>修改工作模式</h2><p>TODO</p>
<h2 id="完善-write-和-read-函数"><a href="#完善-write-和-read-函数" class="headerlink" title="完善 write 和 read 函数"></a>完善 write 和 read 函数</h2><p>TODO</p>
<h1 id="Linux-中通用-SPI-设备驱动"><a href="#Linux-中通用-SPI-设备驱动" class="headerlink" title="Linux 中通用 SPI 设备驱动"></a>Linux 中通用 SPI 设备驱动</h1><p>跟 I2C 设备类似，在 Linux内核中也有着通用 SPI 设备驱动，menuconfig路径如下：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Device</span> <span class="type">Drivers</span></span><br><span class="line">	&gt; <span class="type">SPI</span> sup<span class="keyword">port</span></span><br><span class="line">		[] <span class="type">User</span> mode <span class="type">SPI</span> device driver sup<span class="keyword">port</span></span><br></pre></td></tr></table></figure>

<p>除了内核支持之外，还需要修改设备树，由于之前已经使能了 SPI0，所以这直接修改之前编写的 mcp2515 设备树节点，修改完成的 mcp2515 节点如下所示：<code>rockchip,spidev</code></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi0</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">	</span></span><br><span class="line"><span class="symbol">	mcp2515:</span><span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,spidev&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>开发板启动之后，如果存在&#x2F;dev&#x2F;spidev0.0 设备节点，证明设备树及内核配置正确，</p>
<p><code>/dev/spidev0.0</code> 表示一个 SPI 总线上的具体设备。0.0 是一个标识符，用于区分系统中的不同 SPI 控制器和设备。这个标识符由两部分组成：</p>
<ul>
<li>第一个数字 0：表示 SPI 总线的编号。一个系统中可能有多个 SPI 控制器，每个控制器对应一个总线编号，从 0 开始。</li>
<li>第二个数字 0：表示连接在该 SPI 总线上的具体设备编号。一个 SPI 总线上可以连接多个设备，每个设备通过片选信号（Chip Select, CS）进行区分，设备编号从 0 开始。</li>
</ul>
<h2 id="spidev-test-工具"><a href="#spidev-test-工具" class="headerlink" title="spidev_test 工具"></a>spidev_test 工具</h2><p><code>spidev_test</code> 是一个用于测试和调试 SPI 设备的命令行工具，通常在 Linux 系统上使用，它允许用户直接通过 SPI 总线与设备进行通信，可以发送数据并接收来自设备的响应。<code>spidev_test</code> 源码位于topeet Linux 源码的 <code>kernel/tools/spi</code> 目录下，编译要交叉编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">CC=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-lin</span><br><span class="line">ux-gnu/bin/aarch64-linux-gnu-gcc</span><br><span class="line">LD=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-lin</span><br><span class="line">ux-gnu/bin/aarch64-linux-gnu-ld</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>基本介绍</strong>：spidev_test 是一个用于测试和验证 Linux 中 SPI 设备驱动程序的用户空间工具。它使用 spidev 接口与 SPI 设备通信。这个工具主要用来检查 SPI 设备是否工作正常，以及对 SPI 设备进行基本的读写操作。</p>
</li>
<li><p><strong>主要选项和参数</strong>：</p>
<ul>
<li><code>-D /dev/spidevX.Y</code>：指定要测试的 SPI 设备节点。</li>
<li><code>-s &lt;speed&gt;</code>：设置 SPI 时钟频率（以 Hz 为单位），例如 -s 1000000 表示 1 MHz。</li>
<li><code>-d &lt;delay&gt;</code>：设置数据传输之间的延迟时间（以微秒为单位）。</li>
<li><code>-b &lt;bits per word&gt;</code>：设置每个数据字的位数，通常是 8 或 16。</li>
<li><code>-H</code>：以十六进制模式显示传输的数据。</li>
</ul>
</li>
<li><p><strong>示例操作</strong></p>
<ul>
<li>读取设备信息：<code>spidev_test -D /dev/spidevX.Y -s 1000000</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144134950.png" alt="读取设备信息" loading="lazy"></p>
<p>这会使用 1 MHz 的时钟频率从 SPI 设备读取数据，默认情况下以十六进制显示</p>
<ul>
<li>写入和读取数据：<code>spidev_test -D /dev/spidevX.Y -s 1000000 -b 8 -d 1000 -H -p &#39;hello&#39;</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144141950.png" alt="写入和读取数据" loading="lazy"></p>
<p>这条命令会向 SPI 设备写入字符串 ‘hello’，并以十六进制模式显示设备的响应数据。<code>-b 8</code>指定每个字的位数为 8，<code>-d 1000</code> 设置 1000 微秒的延迟。</p>
</li>
<li><p><strong>连续传输</strong>：<code>spidev_test -D /dev/spidevX.Y -s 1000000 -b 8 -p &#39;abcdefgh&#39;</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144154098.png" alt="连续传输" loading="lazy"></p>
</li>
</ul>
<p>这个示例将连续发送字节 ‘abcdefgh’ 到 SPI 设备。</p>
<h2 id="spidev-fdx-工具"><a href="#spidev-fdx-工具" class="headerlink" title="spidev_fdx 工具"></a>spidev_fdx 工具</h2><ul>
<li><p><strong>基本介绍</strong>：spidev_fdx 是一个用于全双工 SPI 通信测试的命令行工具，主要用于在Linux 系统上与 SPI 设备进行双向数据传输和测试。</p>
</li>
<li><p><strong>主要选项和参数</strong></p>
<ul>
<li><code>-D /dev/spidevX.Y</code>：指定要测试的 SPI 设备节点。</li>
<li><code>-s &lt;speed&gt;</code>：设置 SPI 时钟频率（以 Hz 为单位），例如 -s 1000000 表示 1 MHz。</li>
<li><code>-w &lt;write_data&gt;</code>：指定要写入到 SPI 设备的数据，可以是十六进制或 ASCII 格式的字符串。</li>
<li><code>-r &lt;read_size&gt;</code>：指定从 SPI 设备读取的数据大小（以字节为单位）。</li>
<li><code>-b &lt;bits per word&gt;</code>：设置每个数据字的位数，通常是 8 或 16。</li>
<li><code>-d &lt;delay&gt;</code>：设置数据传输之间的延迟时间（以微秒为单位）。</li>
</ul>
</li>
<li><p><strong>示例操作</strong></p>
<ul>
<li><p><strong>发送和接收数据</strong>：<code>spidev_fdx -D /dev/spidevX.Y -s 1000000 -w &#39;hello&#39; -r 5</code></p>
<p>这会向 SPI 设备写入字符串 ‘hello’，并从设备读取 5 个字节的响应数据。</p>
</li>
<li><p>设置时钟频率和延迟：<code>spidev_fdx -D /dev/spidevX.Y -s 500000 -d 200 -w &#39;abcdef&#39; -r 10</code></p>
<p>这个示例将 SPI 时钟频率设置为 500 kHz，数据写入延迟为 200 微秒，并向设备写入字符串 ‘abcdef’，然后读取 10 个字节的响应数据。</p>
</li>
</ul>
</li>
</ul>
<h2 id="应用程序中如何使用-SPI"><a href="#应用程序中如何使用-SPI" class="headerlink" title="应用程序中如何使用 SPI"></a>应用程序中如何使用 SPI</h2><p>可以参考 <code>spidev_test</code> 工具的源码</p>
<h1 id="Linux中使用模拟SPI"><a href="#Linux中使用模拟SPI" class="headerlink" title="Linux中使用模拟SPI"></a>Linux中使用模拟SPI</h1><p>首先将模拟 SPI 驱动编译进内核，在 make menuconfig 图形化配置界面中选中如下选项</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D<span class="function"><span class="title">evice</span> Drivers ---&gt;</span></span><br><span class="line">	[*]SPI <span class="function"><span class="title">support</span> --&gt;</span></span><br><span class="line">		&lt;*&gt; GPIO-based bitbanging SPI Master <span class="comment">//选中</span></span><br></pre></td></tr></table></figure>

<p>软件 SPI 选定的引脚为开发板背面的 4 个 GPIO，具体引脚功能图如下所示：</p>
<table>
<thead>
<tr>
<th>RK3568 网络标号</th>
<th>对应 GPIO</th>
<th>模拟功能</th>
</tr>
</thead>
<tbody><tr>
<td>DVP_PWREN0_H_GPIO0_B0</td>
<td>GPIO0_B0</td>
<td>SCLK</td>
</tr>
<tr>
<td>PDM_SDI3_M0_ADC</td>
<td>GPIO1_B0</td>
<td>MISO</td>
</tr>
<tr>
<td>PDM_SDI2_M0_ADC</td>
<td>GPIO1_B1</td>
<td>MOSI</td>
</tr>
<tr>
<td>PDM_SDI1_M0_ADC</td>
<td>GPIO1_B2</td>
<td>CS</td>
</tr>
</tbody></table>
<p>设备树修改步骤如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spi5:</span> <span class="title class_">spi@gpiol</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;spi-gpio&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="attr">gpio-sck</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> RK_PB0_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">gpio-miso</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB0_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">gpio-mosi</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB1_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">cs-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB2_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">num-chipselects</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi5_gpios</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>然后对 pinctrl 节点进行追加，设置引脚复用：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spi5_gpios:</span> <span class="title class_">gpios</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span> RK_PB0 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">					<span class="params">&lt;<span class="number">1</span> RK_PB0 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">					<span class="params">&lt;<span class="number">1</span> RK_PB1 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">					<span class="params">&lt;<span class="number">1</span> RK_PB2 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">	&gt;<span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>最后修改之前编写的 mcp2515 节点</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi5</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">	mcp2515:</span><span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,spidev&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/spidev5.0</span><br><span class="line">./spidev_test -D /dev/spidev5.0 -v</span><br></pre></td></tr></table></figure>



<h1 id="移植官方-mcp2515-驱动"><a href="#移植官方-mcp2515-驱动" class="headerlink" title="移植官方 mcp2515 驱动"></a>移植官方 mcp2515 驱动</h1><p>Linux 内 核 源 码 中 默 认 已 经 有 了 MCP2515 的 驱 动 程 序 ， 驱 动 具 体 路 径 为<code>drivers/net/can/spi/mcp251x.c</code>，所以只需要在<code>make menuconfig</code> 图形化配置界面选中即可：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Networking</span> sup<span class="keyword">port</span></span><br><span class="line">	&gt; <span class="type">CAN</span> bus subsystem sup<span class="keyword">port</span></span><br><span class="line">		&gt; <span class="type">CAN</span> <span class="type">Device</span> <span class="type">Drivers</span></span><br><span class="line">			&gt; <span class="type">CAN</span> <span class="type">SPI</span> interfaces</span><br><span class="line">				&lt;*&gt; <span class="type">Microchip</span> <span class="type">MCP251x</span> and <span class="type">MCP25625</span> <span class="type">SPI</span> <span class="type">CAN</span> controllers</span><br></pre></td></tr></table></figure>

<p>然后在设备树中添加如下节点：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi0</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">	mcp2515:</span> <span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;microchip,mcp2515&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;RK_PB0 IRQ_TYPE_EDGE_FALLING&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">		pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;mcp2515_int</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;clk8m</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">	</span></span><br><span class="line"><span class="symbol">	clk8m:</span> <span class="title class_">clk8m</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line">		<span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">8000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>在 pinctrl 节点下添加以下内容</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mcp2515-gpio<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">	mcp2515_int:</span><span class="title class_">mcp2515-int</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span> RK_PB0 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br><span class="line"><span class="comment"># 回环测试</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 <span class="built_in">type</span> can bitrate 250000</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 <span class="built_in">type</span> can loopback on</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> up can1</span><br><span class="line">candump can1 -L &amp;</span><br><span class="line">cansend can1 123#1122334455667788</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/2512303/">https://even629.com/posts/2512303/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><div class="post-share"><div class="social-share" data-image="/images/linux_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center liquidGlass-wrapper" id="my-custom-card-author"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status">🐟<span>认真摸鱼中</span></div></div></div><div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" target="_blank" title="github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" target="_blank" title="email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com/519280138" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="rss"><i class="fas fa-rss" style="color: #000000;"></i></a></div></div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"> <div class="newYear-slider"> <div class="swiper-wrapper"> <div class="swiper-slide" style="background-image:url(/img/happy_new_year1.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year2.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year3.webp)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year4.gif)"></div> </div> </div> <div id="newYear-main"> <div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div> </div></div><div class="sticky_layout"><div class="card-widget liquidGlass-wrapper" id="card-toc"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI%E5%9F%BA%E7%A1%80"><span class="toc-text">SPI基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E7%89%B9%E7%82%B9"><span class="toc-text">SPI特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-text">SPI硬件连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">SPI 通信原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E6%9E%81%E6%80%A7%E5%92%8C%E7%9B%B8%E4%BD%8D"><span class="toc-text">SPI极性和相位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iTOP-RK3568-%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84-SPI-%E6%8E%A5%E5%8F%A3"><span class="toc-text">iTOP-RK3568 处理器中的 SPI 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI0"><span class="toc-text">SPI0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI1"><span class="toc-text">SPI1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI2"><span class="toc-text">SPI2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI3"><span class="toc-text">SPI3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mcp2515"><span class="toc-text">mcp2515</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-text">SPI子系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%B1%82"><span class="toc-text">SPI设备驱动层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E9%80%82%E9%85%8D%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%B1%82"><span class="toc-text">SPI适配器驱动层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI-%E6%A0%B8%E5%BF%83%E5%B1%82"><span class="toc-text">SPI 核心层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8SPI%E5%A4%96%E8%AE%BE%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99"><span class="toc-text">通用SPI外设框架编写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reg-%E5%92%8C-spi-max-frequency%E5%B1%9E%E6%80%A7"><span class="toc-text">reg 和 spi-max-frequency属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rockchip-spi-probe"><span class="toc-text">rockchip_spi_probe()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#devm-spi-register-controller"><span class="toc-text">devm_spi_register_controller()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spi-register-controller"><span class="toc-text">spi_register_controller()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#of-register-spi-devices"><span class="toc-text">of_register_spi_devices()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#of-register-spi-device"><span class="toc-text">of_register_spi_device()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#of-spi-parse-dt"><span class="toc-text">of_spi_parse_dt()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E7%A4%BA%E4%BE%8B"><span class="toc-text">注册字符设备示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">SPI通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#spi-write"><span class="toc-text">spi_write()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-spi-device"><span class="toc-text">struct spi_device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spi-read"><span class="toc-text">spi_read()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-spi-transfer"><span class="toc-text">struct spi_transfer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi-sync-transfer"><span class="toc-text">spi_sync_transfer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi-sync"><span class="toc-text">spi_sync()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi-sync-1"><span class="toc-text">__spi_sync()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi-pump-messages"><span class="toc-text">__spi_pump_messages()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi-write-then-read"><span class="toc-text">spi_write_then_read()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mcp2515-%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99"><span class="toc-text">mcp2515 驱动编写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E5%87%BD%E6%95%B0"><span class="toc-text">复位函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%AF%84%E5%AD%98%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-text">读寄存器函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">配置模式下寄存器的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">修改工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%96%84-write-%E5%92%8C-read-%E5%87%BD%E6%95%B0"><span class="toc-text">完善 write 和 read 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E4%B8%AD%E9%80%9A%E7%94%A8-SPI-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-text">Linux 中通用 SPI 设备驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#spidev-test-%E5%B7%A5%E5%85%B7"><span class="toc-text">spidev_test 工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spidev-fdx-%E5%B7%A5%E5%85%B7"><span class="toc-text">spidev_fdx 工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-SPI"><span class="toc-text">应用程序中如何使用 SPI</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%8B%9FSPI"><span class="toc-text">Linux中使用模拟SPI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E6%A4%8D%E5%AE%98%E6%96%B9-mcp2515-%E9%A9%B1%E5%8A%A8"><span class="toc-text">移植官方 mcp2515 驱动</span></a></li></ol></div></div></div><div class="card-widget card-recent-post liquidGlass-wrapper"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2601133/" title="Linux 网络设备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux 网络设备"/></a><div class="content"><a class="title" href="/posts/2601133/" title="Linux 网络设备">Linux 网络设备</a><time datetime="2026-01-13T14:00:00.000Z" title="发表于 2026-01-13 22:00:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601143/" title="Linux ADC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux ADC"/></a><div class="content"><a class="title" href="/posts/2601143/" title="Linux ADC">Linux ADC</a><time datetime="2026-01-13T13:18:00.000Z" title="发表于 2026-01-13 21:18:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601093/" title="Linux CAN"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux CAN"/></a><div class="content"><a class="title" href="/posts/2601093/" title="Linux CAN">Linux CAN</a><time datetime="2026-01-09T07:56:00.000Z" title="发表于 2026-01-09 15:56:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601063/" title="Linux Watchdog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux Watchdog"/></a><div class="content"><a class="title" href="/posts/2601063/" title="Linux Watchdog">Linux Watchdog</a><time datetime="2026-01-06T05:09:00.000Z" title="发表于 2026-01-06 13:09:00">2026-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601053/" title="Linux RTC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux RTC"/></a><div class="content"><a class="title" href="/posts/2601053/" title="Linux RTC">Linux RTC</a><time datetime="2026-01-05T14:09:00.000Z" title="发表于 2026-01-05 22:09:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601043/" title="Linux PWM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux PWM"/></a><div class="content"><a class="title" href="/posts/2601043/" title="Linux PWM">Linux PWM</a><time datetime="2026-01-04T10:59:00.000Z" title="发表于 2026-01-04 18:59:00">2026-01-04</time></div></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a target="_blank" rel="noopener" href="https://github.com/even629" title="github"><i class="fab fa-github"></i></a><a href="/img/qq.jpg" title="qq"><i class="fa-brands fa-qq"></i></a><a href="mailto:zhaohang731005515@proton.me" title="email"><i class="fas fa-envelope"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/519280138" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a href="/atom.xml" title="rss"><i class="fas fa-rss"></i></a></div><div class="copyright">&copy;2024 - 2026 By even629</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Frame-Hexo-blue.svg" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Theme-Butterfly.svg" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Source-Github.svg" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Copyright-BY--NC--SA.4.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"> </span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.stopSakura();"><i class="fa-solid fa-feather"></i><span data-zh="樱花特效" data-en="toggle sakura"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '4fbbafcb116e331e1f69be80efcdac62'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.js"></script><script src="/js/sakura.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/solarlunar.js"></script><script src="/js/newYear.js"></script><script src="/js/pop-up-window.js"></script><script data-pjax src="/js/nav.js"></script><script data-pjax src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><svg style="display: none">
<filter
  id="glass-distortion"
  x="0%"
  y="0%"
  width="100%"
  height="100%"
  filterUnits="objectBoundingBox"
>
  <feTurbulence
    type="fractalNoise"
    baseFrequency="0.01 0.01"
    numOctaves="1"
    seed="5"
    result="turbulence"
  />
  <!-- Seeds: 14, 17,  -->

  <feComponentTransfer in="turbulence" result="mapped">
    <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
    <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
    <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
  </feComponentTransfer>

  <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />

  <feSpecularLighting
    in="softMap"
    surfaceScale="5"
    specularConstant="1"
    specularExponent="100"
    lighting-color="white"
    result="specLight"
  >
    <fePointLight x="-200" y="-200" z="300" />
  </feSpecularLighting>

  <feComposite
    in="specLight"
    operator="arithmetic"
    k1="0"
    k2="1"
    k3="1"
    k4="0"
    result="litImage"
  />

  <feDisplacementMap
    in="SourceGraphic"
    in2="softMap"
    scale="150"
    xChannelSelector="R"
    yChannelSelector="G"
  />
  </filter>
</svg>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr class="custom-hr"/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><script async src="//at.alicdn.com/t/c/font_4847823_upluhme7cv.js"></script><!-- hexo injector body_end end --></body></html>