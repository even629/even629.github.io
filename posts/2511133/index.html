<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux高级字符设备进阶 | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux高级字符设备进阶">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高级字符设备进阶">
<meta property="og:url" content="https://even629.com/posts/2511133/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="Linux高级字符设备进阶">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/linux_cover.webp">
<meta property="article:published_time" content="2025-11-13T12:31:13.000Z">
<meta property="article:modified_time" content="2025-11-13T12:31:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/linux_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/2511133/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux高级字符设备进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.png', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom_card_author.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/newYear.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/beautify_label_h.css"><link rel="stylesheet" href="/css/equipment.css"><link rel="stylesheet" href="/css/liquid_glass.css"><link rel="stylesheet" href="/css/tag_plugin_plus.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="常想一二，不思八九" type="application/atom+xml">
</head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/linux_top_image.jpg);"><nav class="liquidGlass-wrapper" id="nav" style="--glass-border-radius: 2rem;"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box" style="display:flex;align-items:center;justify-content:center;width:100%"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" alt="Logo"></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 菜单项--><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><!-- 显示当前标题名称--><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">常想一二，不思八九</a></center></div></div><!-- 右侧功能区域（新增容器）--><div id="nav-right-container"><!-- 搜索按钮（移动到右侧）--><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><!-- 移动端汉堡菜单按钮--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux高级字符设备进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-13T12:31:13.000Z" title="发表于 2025-11-13 20:31:13">2025-11-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-13T12:31:13.000Z" title="更新于 2025-11-13 20:31:13">2025-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2511133/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-11-13</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>

<hr>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="IO操作过程"><a href="#IO操作过程" class="headerlink" title="IO操作过程"></a>IO操作过程</h2><p>一个完整的 IO 流程，通常包含以下关键环节：</p>
<ul>
<li>IO 调用：应用程序通过系统调用接口向内核发起 IO 请求（如读取文件）。</li>
<li>IO 执行：内核收到请求之后，通过驱动程序操作硬件完成具体 IO（如从磁盘读取数据），并将最终结果返回给用户空间。</li>
</ul>
<p>完整的 IO 过程需要包含以下三个步骤:</p>
<ol>
<li>用户空间的应用程序向内核发起 IO 调用请求(系统调用)</li>
<li>内核操作系统准备数据，把 IO 设备的数据加载到内核缓冲区</li>
<li>操作系统拷贝数据，把内核缓冲区的数据拷贝到用户进程缓冲区</li>
</ol>
<h2 id="IO模型的分类"><a href="#IO模型的分类" class="headerlink" title="IO模型的分类"></a>IO模型的分类</h2><blockquote>
<p> 在实际开发中，IO 操作常常成为影响程序性能的关键因素。假设有一个场景：从磁盘读取100MB 数据并处理，读取数据耗时 20 秒，处理数据也需要 20 秒。如果采用最传统的顺序流程——读取完再处理，那么整个流程耗时约 40 秒，效率明显偏低。那么能不能在等待数据的同时对数据进行处理呢？当然可以！这时候就轮到 IO 编程模型来出场了。</p>
</blockquote>
<p>在 POSIX &#x2F; Linux 的定义下：IO模型有阻塞IO，非阻塞IO，信号驱动IO，IO多路复用，异步IO。其中前四个被称之为同步IO</p>
<ul>
<li><strong>同步IO</strong><ul>
<li><strong>阻塞IO</strong></li>
<li><strong>非阻塞IO</strong></li>
<li><strong>IO多路复用</strong></li>
<li><strong>信号驱动IO</strong></li>
</ul>
</li>
<li><strong>异步IO</strong></li>
</ul>
<blockquote>
<p>同步和异步的区别在于<strong>是否等待IO的执行结果，或者说数据拷贝到用户空间，是谁来完成的</strong>？。</p>
<p><strong>同步IO：</strong> <strong>最终把数据从内核拷贝到用户空间的动作，都是由用户线程在调用 <code>read()</code> 时完成的</strong></p>
<p><strong>异步IO:</strong></p>
<ul>
<li>用户态发起 IO 请求 → 立刻返回</li>
<li>内核在后台完成 IO</li>
<li>数据已拷贝到用户空间</li>
<li>内核通知进程：IO 完成</li>
</ul>
</blockquote>
<h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p>进程进行 IO 操作时(如 read 操作)，首先会发起一个系统调用，从而转到内核空间进行处理，<strong>内核空间的数据没有准备就绪时，进程会被阻塞，不会继续向下执行</strong>，直到内核空间的数据准备完成后，数据才会从内核空间拷贝到用户空间，最后返回应用进程，由用户空间进行数据的处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223192855030.png" alt="阻塞IO模型" loading="lazy"></p>
<p>阻塞 IO 的可以及时地获取结果，并立刻对获取到的结果进行处理，然而在获取结果之前，无法去处理其他任务，需要时刻对结果进行监听。比如<strong>C语言的scanf函数</strong>。</p>
<h3 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h3><p>和阻塞 IO 模型不同，非阻塞 IO 进行 IO 操作时，<strong>如果内核数据没有准备好，内核会立即向进程返回 err</strong>，不会进行阻塞；如果内核空间数据准备就绪，内核会立即把数据返回给用户空间的进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223192902316.png" alt="同步非阻塞IO" loading="lazy"></p>
<p>非阻塞 IO 的优点是效率高，同样的时间内可以做别的事。但是缺点也很明显，当需要频繁检查数据就绪状态时可能导致较高的 CPU 占用率。为了解决此问题，非阻塞 IO 通常与 IO多路复用技术结合使用。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>select()、poll()和 epoll()函数是实现 IO 多路复用的机制。</p>
<p>IO 多路复用可以让<strong>单个进程监控多个描述符，当发现某个描述符就绪以后，就会通知程序进行相应的读写操作</strong>。</p>
<p>以 select()函数为例，如图所示。使用时需要向 select()传入待监听的文件描述符集合以及超时时间。</p>
<p>当执行 select()时，系统会触发一次系统调用，<strong>内核将遍历检查这些描述符是否触发了目标事件</strong>（如可读、可写）。若检测到事件则立即返回，若<strong>未检测到事件，进程将进入阻塞状态并休眠</strong>，<strong>直到任一描述符就绪或超时为止</strong>。</p>
<p>当 select()返回后，用户空间需遍历所有描述符，逐一确认具体是哪个触发了事件，从而实现单线程同时管理多个 IO操作的效果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223192917822.png" alt="IO多路复用" loading="lazy"></p>
<p>IO 多路复用的优点是一个进程&#x2F;线程可以同时监听和处理多路 IO，效率成倍提高。但是 IO多路复用并不是能医治百病的良药，<strong>虽然 IO 多路复用可以监听多个 IO，但是实际上对结果的处理也只能依次进行</strong>，比较<strong>适合 IO 密集但是每一路 IO 数据量不多且到达时间分散的场合</strong>（如网络聊天）。</p>
<p>另外 select 监听的描述符有上限（一般描述符最大不超过 1024），而且<strong>需要遍历究竟是哪一个 IO 产生了数据</strong>。因此 IO 较多时，效率不高（这个问题被 epoll 解决）。</p>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>信号驱动 IO 指的是<strong>进程会预先告知内核，当某个描述符发生事件时，内核要向该进程发送 SIGIO 信号进行通知</strong>，进程可以在信号处理函数中对该事件进行处理。</p>
<p>例如在 Linux 系统中，用户按下 ctrl+C 终止运行中的任务时，系统实际上是对该进程发送一个 SIGINT 信号，该信号的默认处理函数就是退出当前程序。</p>
<p>具体到 IO 模型上，进程需要先为 SIGIO 信号注册相应的信号处理函数，并打开对应描述符的信号驱动。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 IO操作函数处理数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223192910323.png" alt="信号驱动IO" loading="lazy"></p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><code>aio_read()</code>函数常常用于异步 IO，当进程使用 <code>aio_read()</code>读取数据时，<strong>如果数据尚未准备就绪就立即返回，不会阻塞</strong>。</p>
<p>若数据准备就绪就会把数据从内核空间拷贝到用户空间的缓冲区中，然后<strong>执行定义好的回调函数对接收到的数据进行处理</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223192927061.png" alt="异步IO" loading="lazy"></p>
<p>但是对于Linux AIO，Linux AIO <strong>只支持 direct I&#x2F;O</strong> 模式的<strong>存储文件</strong> （storage file），而且主要用在<strong>数据库这一细分领域</strong>；</p>
<p>而<code>io_uring</code> 支持存储文件和网络文件（network sockets），也支持更多的异步系统调用 （<code>accept/openat/stat/...</code>），而非仅限于 <code>read/write</code> 系统调用。</p>
<h2 id="等待队列实现阻塞IO"><a href="#等待队列实现阻塞IO" class="headerlink" title="等待队列实现阻塞IO"></a>等待队列实现阻塞IO</h2><p>在 Linux 驱动程序中，<strong>阻塞进程可以使用等待队列来实现</strong>。</p>
<p>等待队列是实现阻塞和唤醒的内核机制，<strong>等待队列以双循环链表为基础结构</strong>，其中链表头和链表项两部分别表示等待队列头和等待队列元素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223192935098.png" alt="等待队列" loading="lazy"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>include&#x2F;linux&#x2F;wait.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> <span class="title">wait_queue_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">	<span class="type">void</span>			*private;</span><br><span class="line">	<span class="type">wait_queue_func_t</span>	func;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>;</span></span><br></pre></td></tr></table></figure>





<h3 id="初始化等待队列"><a href="#初始化等待队列" class="headerlink" title="初始化等待队列"></a>初始化等待队列</h3><table>
<thead>
<tr>
<th>API</th>
<th>用途</th>
<th>说明 &#x2F; 参数</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td><code>DECLARE_WAIT_QUEUE_HEAD(name)</code></td>
<td>静态定义等待队列头</td>
<td>生成一个名为 <code>name</code> 的全局&#x2F;静态等待队列头</td>
<td>最常用方式</td>
</tr>
<tr>
<td><code>init_waitqueue_head(wq)</code></td>
<td>动态初始化等待队列头</td>
<td>适用于动态分配结构体中的等待队列头</td>
<td>需要先分配内存</td>
</tr>
</tbody></table>
<h3 id="等待队列项API"><a href="#等待队列项API" class="headerlink" title="等待队列项API"></a>等待队列项API</h3><blockquote>
<p>这类API大部分情况下不用用到，task一般是current</p>
</blockquote>
<table>
<thead>
<tr>
<th>API</th>
<th>用途</th>
<th>说明 &#x2F; 参数</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td><code>DECLARE_WAITQUEUE(name, task)</code></td>
<td>静态创建一个等待队列项</td>
<td><code>task</code> 通常填 <code>current</code></td>
<td>全局或静态场景</td>
</tr>
<tr>
<td><code>init_waitqueue_entry(&amp;entry, task)</code></td>
<td>动态初始化队列项</td>
<td>task 通常为 <code>current</code></td>
<td>动态创建项</td>
</tr>
<tr>
<td><code>add_wait_queue(head, entry)</code></td>
<td>将等待项加入等待队列</td>
<td>非排他 wait</td>
<td>多用于底层调用（不建议直接用）</td>
</tr>
<tr>
<td><code>add_wait_queue_exclusive(head, entry)</code></td>
<td>排他 wait</td>
<td>唤醒时只唤醒 1 个 exclusive 进程</td>
<td>用于写操作等阻塞队列</td>
</tr>
<tr>
<td><code>remove_wait_queue(head, entry)</code></td>
<td>从等待队列移除项</td>
<td>和 add_wait_queue 配对</td>
<td></td>
</tr>
</tbody></table>
<h3 id="睡眠等待API"><a href="#睡眠等待API" class="headerlink" title="睡眠等待API"></a>睡眠等待API</h3><table>
<thead>
<tr>
<th>API</th>
<th>用途</th>
<th>说明</th>
<th>返回值 &#x2F; 注意事项</th>
</tr>
</thead>
<tbody><tr>
<td><code>wait_event(wq, condition)</code></td>
<td>条件不满足 → 睡眠（不可中断）</td>
<td>condition 为真返回</td>
<td><strong>不能被信号打断</strong></td>
</tr>
<tr>
<td><code>wait_event_timeout(wq, condition, timeout)</code></td>
<td>不可中断睡眠 + 超时</td>
<td>timeout 为 jiffies</td>
<td>返回剩余 jiffies 或 0 超时</td>
</tr>
<tr>
<td><code>wait_event_interruptible(wq, condition)</code></td>
<td>可中断睡眠</td>
<td>可被信号打断</td>
<td>被打断时返回 <code>-ERESTARTSYS</code></td>
</tr>
<tr>
<td><code>wait_event_interruptible_timeout(wq, condition, timeout)</code></td>
<td>可中断 + 超时</td>
<td></td>
<td>返回：&gt;0 剩余时间，0 超时，&lt;0 被信号打断</td>
</tr>
<tr>
<td><code>wait_event_killable(wq, condition)</code></td>
<td>仅 fatal signal 打断</td>
<td>比 interruptible 更安全</td>
<td>被杀死信号打断</td>
</tr>
<tr>
<td><code>wait_event_killable_timeout(wq, condition, timeout)</code></td>
<td>killable + timeout</td>
<td></td>
<td>同上</td>
</tr>
</tbody></table>
<h3 id="唤醒API"><a href="#唤醒API" class="headerlink" title="唤醒API"></a>唤醒API</h3><table>
<thead>
<tr>
<th>API</th>
<th>用途</th>
<th>说明 &#x2F; 参数</th>
<th>唤醒规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>wake_up(&amp;wq)</code></td>
<td>唤醒 queue 中所有非 exclusive waiter</td>
<td>不修改任务状态</td>
<td>适合读者多、唤醒不需要限制</td>
</tr>
<tr>
<td><code>wake_up_all(&amp;wq)</code></td>
<td>唤醒所有 waiter</td>
<td>包含 exclusive</td>
<td>强制唤醒所有任务</td>
</tr>
<tr>
<td><code>wake_up_interruptible(&amp;wq)</code></td>
<td>唤醒 <code>TASK_INTERRUPTIBLE</code> 状态任务</td>
<td>适配 interruptible wait</td>
<td></td>
</tr>
<tr>
<td><code>wake_up_interruptible_all(&amp;wq)</code></td>
<td>唤醒所有可中断等待者</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>wake_up_nr(&amp;wq, nr)</code></td>
<td>唤醒 nr 个 exclusive waiter</td>
<td>最常用：<code>wake_up(&amp;wq)</code></td>
<td>exclusive 只唤醒一个</td>
</tr>
</tbody></table>
<p>等待队列里有两类等待者：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>怎么来的</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>非 exclusive</strong></td>
<td><code>add_wait_queue()</code></td>
<td>多读者（read）</td>
</tr>
<tr>
<td><strong>exclusive</strong></td>
<td><code>add_wait_queue_exclusive()</code></td>
<td>写者、资源竞争</td>
</tr>
</tbody></table>
<p>exclusive 的设计目标是：</p>
<blockquote>
<p><strong>避免“惊群（thundering herd）”</strong></p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>步骤一：初始化等待队列头，并将条件置成假(condition&#x3D;0)。</p>
<p>步骤二：在需要阻塞的地方调用 <code>wait_event()</code>，使进程进入休眠状态</p>
<p>步骤三：当条件满足时，需要解除休眠，先将条件(condition&#x3D;1),然后调用 <code>wake_up()</code> 函数唤醒等待队列中的休眠进程。</p>
<p>驱动：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KBUF_CAPACITY 32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">waitqueue_drv_data</span> &#123;</span></span><br><span class="line">        <span class="type">dev_t</span> dev_num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="type">char</span> kbuf[KBUF_CAPACITY];</span><br><span class="line">        <span class="type">bool</span> kbuf_ready;</span><br><span class="line">        <span class="type">wait_queue_head_t</span> waitque;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">waitqueue_drv_data</span> *<span class="title">drv_dat</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DECLARE_WAIT_QUEUE_HEAD(waitque);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitqueue_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        file-&gt;private_data = drv_dat;</span><br><span class="line">        </span><br><span class="line">        pr_info(<span class="string">&quot;waitqueue_test_open is called\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">waitqueue_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">waitqueue_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">size_t</span> len;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果以非阻塞方式打开</span></span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dat-&gt;kbuf_ready)</span><br><span class="line">                        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 以阻塞方式打开</span></span><br><span class="line">                ret = wait_event_interruptible(dat-&gt;waitque, dat-&gt;kbuf_ready == <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_err(<span class="string">&quot;waitque_test_read is interrupted\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len = min(size, (<span class="type">size_t</span>)<span class="built_in">strlen</span>(dat-&gt;kbuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, dat-&gt;kbuf + *offset, len) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        </span><br><span class="line">        dat-&gt;kbuf_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">waitqueue_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">waitqueue_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">size_t</span> len = min(size, (<span class="type">size_t</span>)(KBUF_CAPACITY - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(dat-&gt;kbuf, buf, len) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        dat-&gt;kbuf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        dat-&gt;kbuf_ready = <span class="literal">true</span>;</span><br><span class="line">        wake_up_interruptible(&amp;dat-&gt;waitque);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitqueue_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;waitqueue_test_release is called\n&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = waitqueue_test_open,</span><br><span class="line">        .read = waitqueue_test_read,</span><br><span class="line">        .write = waitqueue_test_write,</span><br><span class="line">        .release = waitqueue_test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">waitqueue_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        drv_dat =</span><br><span class="line">                (<span class="keyword">struct</span> waitqueue_drv_data *)kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> waitqueue_drv_data), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (drv_dat == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> kzalloc_fail;</span><br><span class="line">        err = alloc_chrdev_region(&amp;drv_dat-&gt;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;waitque_drv_chrdev_region&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> alloc_chrdev_region_fail;</span><br><span class="line"></span><br><span class="line">        cdev_init(&amp;drv_dat-&gt;cdev, &amp;fops);</span><br><span class="line">        drv_dat-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">        err = cdev_add(&amp;drv_dat-&gt;cdev, drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> cdev_add_fail;</span><br><span class="line"></span><br><span class="line">        drv_dat-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;chrdev&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;class)) &#123;</span><br><span class="line">                err = PTR_ERR(drv_dat-&gt;class);</span><br><span class="line">                <span class="keyword">goto</span> class_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_dat-&gt;dev =</span><br><span class="line">                device_create(drv_dat-&gt;class, <span class="literal">NULL</span>, drv_dat-&gt;dev_num, <span class="literal">NULL</span>, <span class="string">&quot;waitqueue_test%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;dev)) &#123;</span><br><span class="line">                err = PTR_ERR(drv_dat-&gt;dev);</span><br><span class="line">                <span class="keyword">goto</span> device_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化等待队列</span></span><br><span class="line">        init_waitqueue_head(&amp;drv_dat-&gt;waitque);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">device_create_fail:</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">class_create_fail:</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">cdev_add_fail:</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">alloc_chrdev_region_fail:</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">kzalloc_fail:</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">waitqueue_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        device_destroy(drv_dat-&gt;class, drv_dat-&gt;dev_num);</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(waitqueue_test_init);</span><br><span class="line">module_exit(waitqueue_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@163.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;waitqueue sample&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /dev/waitqueue_test0 &amp;</span><br><span class="line">[   18.186918] waitqueue_test_open is called</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span> &gt; /dev/waitqueue_test0</span><br><span class="line">[   33.059018] waitqueue_test_open is called</span><br><span class="line">[   33.060401] waitqueue_test_release is called</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello Linux&quot;</span> &gt; /dev/waitqueue_test0</span><br><span class="line">[   43.618554] waitqueue_test_open is called</span><br><span class="line">[   43.619516] waitqueue_test_release is called</span><br><span class="line">Hello Linux</span><br></pre></td></tr></table></figure>







<h2 id="非阻塞式访问"><a href="#非阻塞式访问" class="headerlink" title="非阻塞式访问"></a>非阻塞式访问</h2><p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;/dev/xxx_dev&quot;</span>, O_RDWR);<span class="comment">/* 阻塞方式打开 */</span></span><br><span class="line">ret = read(fd, &amp;data, <span class="keyword">sizeof</span>(data));<span class="comment">/* 读取数据 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出对于<strong>设备驱动文件的默认读取方式就是阻塞式的</strong>，所以之前实验例程测试都是采用阻塞 IO。<br>如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;/dev/xxx_dev&quot;</span>, O_RDWR | O_NONBLOCK); <span class="comment">/*非阻塞方式打开 */</span></span><br><span class="line">ret = read(fd, &amp;data, <span class="keyword">sizeof</span>(data)); <span class="comment">/* 读取数据 */</span></span><br></pre></td></tr></table></figure>

<p>使用 open 函数打开“&#x2F;dev&#x2F;xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候是非阻塞方式了。</p>
<p><strong>驱动程序</strong></p>
<p>通过file结构体中的f_flags中查询应用程序是否通过O_NONBLOCK方式打开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">	<span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">		<span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>





<h2 id="IO多路复用的实现"><a href="#IO多路复用的实现" class="headerlink" title="IO多路复用的实现"></a>IO多路复用的实现</h2><p>IO 多路复用是一种同步的 IO 模型。IO 多路复用可以<strong>实现一个进程监视多个文件描述符</strong>。一旦某个文件描述符准备就绪，就通知应用程序进行相应的读写操作。没有文件描述符就绪时就会阻塞应用程序，从而释放出 CPU 资源。</p>
<p>在应用层 Linux 提供了三种实现 IO 多路复用的模型，分别是 select、poll 和 epoll。</p>
<ul>
<li>poll和select基本一样，都可以监听多个文件描述符，通过轮询文件描述符来获取已经准备好的文件描述符</li>
<li>epoll是将主动轮询变成了被动通知，当事件发生时，被动地接收通知。</li>
</ul>
<h3 id="Linux应用层poll"><a href="#Linux应用层poll" class="headerlink" title="Linux应用层poll"></a>Linux应用层poll</h3><table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>监视多个文件描述符的读写事件或异常事件</td>
</tr>
<tr>
<td><strong>原型</strong></td>
<td><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>fds</code>：struct pollfd 数组，描述被监视的文件描述符及事件 <br />- <code>nfds</code>：被监视的 fd 数量<br /> - <code>timeout</code>：超时时间（ms）<br />  &gt;0：等待指定时间;<br />  &#x3D; 0：立即返回;<br />  -1：永远阻塞，直到事件发生</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>&gt;0：返回 <em>revents ≠ 0</em> 的 fd 数量<br /> &#x3D;0：超时 <br />-1：失败</td>
</tr>
</tbody></table>
<p> <strong>struct pollfd</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;       <span class="comment">// 被监视的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 需要监视的事件</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 内核返回的事件</span></span><br><span class="line">&#125;;	</span><br></pre></td></tr></table></figure>

<p><strong>pollfd的events和revents</strong></p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>常值</th>
<th>作为 events 的值</th>
<th>作为 revents 的值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>读事件</td>
<td>POLLIN</td>
<td>✔</td>
<td>✔</td>
<td>有普通数据可读</td>
</tr>
<tr>
<td>读事件</td>
<td>POLLRDNORM</td>
<td>✔</td>
<td>✔</td>
<td>可读（常规数据）</td>
</tr>
<tr>
<td>读事件</td>
<td>POLLRDBAND</td>
<td>✔</td>
<td>✔</td>
<td>可读（带外数据）</td>
</tr>
<tr>
<td>读事件</td>
<td>POLLPRI</td>
<td>✔</td>
<td>✔</td>
<td>可读（高优先级数据）</td>
</tr>
<tr>
<td>写事件</td>
<td>POLLOUT</td>
<td>✔</td>
<td>✔</td>
<td>可写</td>
</tr>
<tr>
<td>写事件</td>
<td>POLLWRNORM</td>
<td>✔</td>
<td>✔</td>
<td>可写（常规数据）</td>
</tr>
<tr>
<td>写事件</td>
<td>POLLWRBAND</td>
<td>✔</td>
<td>✔</td>
<td>可写（带外数据）</td>
</tr>
<tr>
<td>错误事件</td>
<td>POLLERR</td>
<td></td>
<td>✔</td>
<td>发生错误</td>
</tr>
<tr>
<td>错误事件</td>
<td>POLLHUP</td>
<td></td>
<td>✔</td>
<td>发生挂起</td>
</tr>
<tr>
<td>错误事件</td>
<td>POLLNVAL</td>
<td></td>
<td>✔</td>
<td>描述符不是打开的文件</td>
</tr>
</tbody></table>
<h3 id="file-operations-poll"><a href="#file-operations-poll" class="headerlink" title="file_operations.poll"></a>file_operations.poll</h3><table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>告诉内核：当前设备是否可 non-blocking 访问（可读&#x2F;可写）</td>
</tr>
<tr>
<td><strong>原型</strong></td>
<td><code>unsigned int (*poll)(struct file *filp, struct poll_table_struct *wait);</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>filp</code>：文件结构体指针 <br />- <code>wait</code>：内核传入的 poll_table，用于登记等待队列</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>返回状态位掩码（同 POLLIN&#x2F;POLLOUT 等事件）</td>
</tr>
</tbody></table>
<h3 id="驱动中的实现"><a href="#驱动中的实现" class="headerlink" title="驱动中的实现"></a>驱动中的实现</h3><h4 id="poll-wait"><a href="#poll-wait" class="headerlink" title="poll_wait()"></a>poll_wait()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>把驱动中的等待队列加入到 poll_table 中，用于 select&#x2F;poll&#x2F;epoll</td>
</tr>
<tr>
<td><strong>原型</strong></td>
<td><code>void poll_wait(struct file *filp, wait_queue_head_t *queue, poll_table *wait);</code></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/poll.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>- <code>filp</code>：文件 <br /> - <code>queue</code>：等待队列头（wait_queue_head_t） <br /> - <code>wait</code>：poll_table（来自应用层）</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无</td>
</tr>
<tr>
<td><strong>特点</strong></td>
<td><strong>不会阻塞！</strong> 只是登记等待队列</td>
</tr>
</tbody></table>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>app read.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> fd, ret;</span><br><span class="line">        <span class="type">char</span> prefix[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> ops_nr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;[fork error]&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//child</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line">                <span class="built_in">sprintf</span>(prefix, <span class="string">&quot;[child, pid:%d]:&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">                fd = open(<span class="string">&quot;/dev/poll_test0&quot;</span>, O_RDWR);</span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s Error: %s(errno:%d)\n&quot;</span>, prefix, strerror(errno), errno);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// child write for about 10 secs</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ops_nr; i++) &#123;</span><br><span class="line">                        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">                        ret = write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                close(fd);</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s Error: %s(errno:%d)\n&quot;</span>, prefix, strerror(errno),</span><br><span class="line">                                        errno);</span><br><span class="line">                                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                        &#125;</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                close(fd);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">poll_fds</span>[1];</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">sprintf</span>(prefix, <span class="string">&quot;[parent, pid:%d]:&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">                fd = open(<span class="string">&quot;/dev/poll_test0&quot;</span>, O_RDWR);</span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s Error: %s(errno:%d)\n&quot;</span>, prefix, strerror(errno), errno);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                poll_fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">                poll_fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        ret = poll(poll_fds, <span class="keyword">sizeof</span>(poll_fds) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd), <span class="number">3000</span>);</span><br><span class="line">                        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                close(fd);</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s Error: %s(errno:%d)\n&quot;</span>, prefix, strerror(errno),</span><br><span class="line">                                        errno);</span><br><span class="line">                                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (poll_fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                                        ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                                        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                                close(fd);</span><br><span class="line">                                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s Error: %s(errno:%d)\n&quot;</span>, prefix,</span><br><span class="line">                                                        strerror(errno), errno);</span><br><span class="line">                                                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">&quot;%s read: %s, read ret: %d\n&quot;</span>, prefix, buf, ret);</span><br><span class="line">                                        ops_nr--;</span><br><span class="line">                                        <span class="keyword">if</span> (ops_nr == <span class="number">0</span>) &#123;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">&quot;%s poll_fds[0].revents is %d\n&quot;</span>, prefix,</span><br><span class="line">                                               poll_fds[<span class="number">0</span>].revents);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                close(fd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p><strong>驱动程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KBUF_SIZE 32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_test_drv_data</span> &#123;</span></span><br><span class="line">        <span class="type">dev_t</span> dev_num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="type">char</span> kbuf[KBUF_SIZE];</span><br><span class="line">        <span class="type">wait_queue_head_t</span> waitque;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_test_drv_data</span> *<span class="title">drv_dat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        file-&gt;private_data = drv_dat;</span><br><span class="line">        pr_info(<span class="string">&quot;open is called by pid: %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">poll_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">size_t</span> len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_test_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;read is called by pid: %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">                mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line">                <span class="keyword">if</span> (dat-&gt;kbuf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">                &#125;</span><br><span class="line">                mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* wait_event 条件必须“可重入、可重复检查” */</span></span><br><span class="line">                ret = wait_event_interruptible(dat-&gt;waitque, (&#123;</span><br><span class="line">                                                       <span class="type">int</span> ready;</span><br><span class="line">                                                       mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line">                                                       ready = (dat-&gt;kbuf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">                                                       mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                                                       ready;</span><br><span class="line">                                               &#125;));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_info(<span class="string">&quot;pid: %d read is interrupted while waiting\n&quot;</span>, current-&gt;pid);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        len = min(size, <span class="built_in">strlen</span>(dat-&gt;kbuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, dat-&gt;kbuf, len)) &#123;</span><br><span class="line">                mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dat-&gt;kbuf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// reset kbuf string</span></span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">poll_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">size_t</span> len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_test_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;write is called by pid: %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line"></span><br><span class="line">        len = min(size, (<span class="type">size_t</span>)(KBUF_SIZE - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(dat-&gt;kbuf, buf, len)) &#123;</span><br><span class="line">                mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dat-&gt;kbuf[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// make sure kbuf a valid string(end with &#x27;\0&#x27;)</span></span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在解锁后唤醒 */</span></span><br><span class="line">        wake_up_interruptible(&amp;dat-&gt;waitque);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">__poll_t</span> <span class="title function_">poll_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_test_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">__poll_t</span> mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        pr_info(<span class="string">&quot;poll is called by pid: %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">        poll_wait(file, &amp;dat-&gt;waitque, p);        </span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (dat-&gt;kbuf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                mask |= POLLIN | POLLRDNORM;</span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;release is called by pid: %d\n&quot;</span>, current-&gt;pid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = poll_test_open,</span><br><span class="line">        .read = poll_test_read,</span><br><span class="line">        .write = poll_test_write,</span><br><span class="line">        .poll = poll_test_poll,</span><br><span class="line">        .release = poll_test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">poll_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        drv_dat =</span><br><span class="line">                (<span class="keyword">struct</span> poll_test_drv_data *)kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_test_drv_data), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (drv_dat == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> kzalloc_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;drv_dat-&gt;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;test_chrdev_region&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> alloc_chrdev_region_fail;</span><br><span class="line"></span><br><span class="line">        cdev_init(&amp;drv_dat-&gt;cdev, &amp;fops);</span><br><span class="line">        drv_dat-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">        ret = cdev_add(&amp;drv_dat-&gt;cdev, drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> cdev_add_fail;</span><br><span class="line"></span><br><span class="line">        drv_dat-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;chrdev&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;class)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;class);</span><br><span class="line">                <span class="keyword">goto</span> class_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        drv_dat-&gt;dev =</span><br><span class="line">                device_create(drv_dat-&gt;class, <span class="literal">NULL</span>, drv_dat-&gt;dev_num, <span class="literal">NULL</span>, <span class="string">&quot;poll_test%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;dev)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;dev);</span><br><span class="line">                <span class="keyword">goto</span> device_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_dat-&gt;kbuf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// always keep kbuf a valid string</span></span><br><span class="line">        mutex_init(&amp;drv_dat-&gt;lock);</span><br><span class="line">        <span class="comment">// 初始化等待队列</span></span><br><span class="line">        init_waitqueue_head(&amp;drv_dat-&gt;waitque);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">device_create_fail:</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">class_create_fail:</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">cdev_add_fail:</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">alloc_chrdev_region_fail:</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">kzalloc_fail:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">poll_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        device_destroy(drv_dat-&gt;class, drv_dat-&gt;dev_num);</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(poll_test_init);</span><br><span class="line">module_exit(poll_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@163.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a test sample for poll_test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$ insmod poll_test.ko</span><br><span class="line">[   12.171314] poll_test: loading out-of-tree module taints kernel.</span><br><span class="line">$ ./test_poll.o</span><br><span class="line">[   15.908771] open is called by pid: 101</span><br><span class="line">[   15.908795] open is called by pid: 102</span><br><span class="line">[   15.909346] write is called by pid: 102</span><br><span class="line">[   15.909902] poll is called by pid: 101</span><br><span class="line">[   15.910627] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 0, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   15.915991] poll is called by pid: 101</span><br><span class="line">[   16.914086] write is called by pid: 102</span><br><span class="line">[   16.917324] poll is called by pid: 101</span><br><span class="line">[   16.917645] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 1, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   16.918526] poll is called by pid: 101</span><br><span class="line">[   17.917861] write is called by pid: 102</span><br><span class="line">[   17.919219] poll is called by pid: 101</span><br><span class="line">[   17.919745] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 2, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   17.922355] poll is called by pid: 101</span><br><span class="line">[   18.920467] write is called by pid: 102</span><br><span class="line">[   18.921819] poll is called by pid: 101</span><br><span class="line">[   18.923714] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 3, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   18.924807] poll is called by pid: 101</span><br><span class="line">[   19.923667] write is called by pid: 102</span><br><span class="line">[   19.925368] poll is called by pid: 101</span><br><span class="line">[   19.926362] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 4, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   19.927909] poll is called by pid: 101</span><br><span class="line">[   20.926284] write is called by pid: 102</span><br><span class="line">[   20.927049] poll is called by pid: 101</span><br><span class="line">[   20.927249] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 5, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   20.927689] poll is called by pid: 101</span><br><span class="line">[   21.927490] write is called by pid: 102</span><br><span class="line">[   21.928342] poll is called by pid: 101</span><br><span class="line">[   21.928747] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 6, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   21.929097] poll is called by pid: 101</span><br><span class="line">[   22.929789] write is called by pid: 102</span><br><span class="line">[   22.931600] poll is called by pid: 101</span><br><span class="line">[   22.932469] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 7, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   22.934791] poll is called by pid: 101</span><br><span class="line">[   23.932151] write is called by pid: 102</span><br><span class="line">[   23.933917] poll is called by pid: 101</span><br><span class="line">[   23.936726] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 8, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   23.938596] poll is called by pid: 101</span><br><span class="line">[   24.933805] write is called by pid: 102</span><br><span class="line">[   24.935854] poll is called by pid: 101</span><br><span class="line">[   24.936546] <span class="built_in">read</span> is called by pid: 101</span><br><span class="line">[parent, pid:101]: <span class="built_in">read</span>: 9, <span class="built_in">read</span> ret: 2</span><br><span class="line">[   24.937991] release is called by pid: 101</span><br><span class="line">[   25.937143] release is called by pid: 102</span><br></pre></td></tr></table></figure>

<h2 id="信号驱动IO-1"><a href="#信号驱动IO-1" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>信号驱动 IO 不需要应用程序查询设备的状态，一旦设备准备就绪，会触发 SIGIO 信号，进而调用注册的处理函数。</p>
<p>如果要实现信号驱动 IO，需要应用程序和驱动程序配合，应用程序使用信号驱动 IO 的步骤有三步：</p>
<ul>
<li>步骤 1 ：注册信号处理函数 应用程序使用 signal 函数来注册 SIGIO 信号的信号处理函数。</li>
<li>步骤 2： 设置能够接收这个信号的进程(fcntl函数)</li>
<li>步骤 3： 开启信号驱动 IO 通常使用 fcntl 函数的 F_SETFL 命令打开 FASYNC 标志。</li>
</ul>
<blockquote>
<p>用户态可以用O_ASYNC也可以用FASYNC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/aarch64-linux-gnu/include/bits/fcntl-linux.h</span></span><br><span class="line"><span class="comment">/* Define some more compatibility macros to be backward compatible with</span></span><br><span class="line"><span class="comment">   BSD systems which did not managed to hide these kernel macros.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	__USE_MISC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FAPPEND	O_APPEND</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FFSYNC		O_FSYNC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FASYNC		O_ASYNC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FNONBLOCK	O_NONBLOCK</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FNDELAY	O_NDELAY</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* Use misc.  */</span></span></span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="驱动实现"><a href="#驱动实现" class="headerlink" title="驱动实现"></a>驱动实现</h3><p>当应用程序开启信号驱动 IO 时，会触发驱动中的 fasync 函数。所以首先在 file_operations结构体中实现 fasync 函数，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span> fd,<span class="keyword">struct</span> file *filp,<span class="type">int</span> on)</span><br></pre></td></tr></table></figure>

<p>在驱动中的 fasync 函数调用 fasync_helper 函数来操作 fasync_struct 结构体，fasync_helper函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fasync_helper</span><span class="params">(<span class="type">int</span> fd,<span class="keyword">struct</span> file *filp,<span class="type">int</span> on,<span class="keyword">struct</span> fasync_struct **fapp)</span></span><br></pre></td></tr></table></figure>

<p>其中<code>struct fasync_struct</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> &#123;</span></span><br><span class="line">	<span class="type">rwlock_t</span>		fa_lock;</span><br><span class="line">	<span class="type">int</span>			magic;</span><br><span class="line">	<span class="type">int</span>			fa_fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span>	*<span class="title">fa_next</span>;</span> <span class="comment">/* singly linked list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span>		*<span class="title">fa_file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">fa_rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>struct fasync_struct</code> 是内核用来管理「哪些进程希望对某个 file 收到 SIGIO &#x2F; SIGURG 信号」的链表节点。</p>
<ul>
<li><p><strong>每一个 <code>fasync_struct</code> &#x3D; 一个订阅者</strong></p>
</li>
<li><p>驱动里保存的是 <strong>链表头指针</strong></p>
</li>
<li><p><code>kill_fasync()</code> 遍历这条链表发信号</p>
</li>
</ul>
</blockquote>
<p>当设备准备好的时候，<strong>驱动程序需要调用 kill_fasync 函数通知应用程序</strong>，此时应用程序的SIGIO 信号处理函数就会被执行。kill_fasync 负责发送指定的信号，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(<span class="keyword">struct</span> fasync_struct **fp,<span class="type">int</span> sig,<span class="type">int</span> band)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数参数</strong>：<ul>
<li><strong>fp</strong>: 要操作的 <code>fasync_struct</code></li>
<li><strong>sig</strong>: 发送的信号</li>
<li><strong>band</strong>: 可读的时候设置成 POLLIN ，可写的时候设置成 POLLOUT</li>
</ul>
</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>app</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> prefix[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> data_ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigio</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">        data_ready = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;[fork error]&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child write</span></span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line">                <span class="built_in">sprintf</span>(prefix, <span class="string">&quot;[child pid:%d]&quot;</span>, getpid());</span><br><span class="line">                fd = open(<span class="string">&quot;/dev/signal_io_test0&quot;</span>, O_RDWR);</span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        perror(prefix);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INT_MAX; i++) &#123;</span><br><span class="line">                        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Hello num %d&quot;</span>, i);</span><br><span class="line">                        ret = write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                perror(prefix);</span><br><span class="line">                                close(fd);</span><br><span class="line">                                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s: write: %s\n&quot;</span>, prefix, buf);</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                close(fd);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent read by signal</span></span><br><span class="line">                <span class="type">int</span> flags;</span><br><span class="line">                <span class="built_in">sprintf</span>(prefix, <span class="string">&quot;[parent pid:%d]&quot;</span>, getpid());</span><br><span class="line">                fd = open(<span class="string">&quot;/dev/signal_io_test0&quot;</span>, O_RDWR);</span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        perror(prefix);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">sprintf</span>(prefix, <span class="string">&quot;[parent pid:%d]&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 注册SIGIO信号的信号处理函数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// signal(SIGIO, handle_sigio); // better not use signal</span></span><br><span class="line">            </span><br><span class="line">            	<span class="comment">// use sigaction instead</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">                act.sa_handler = handle_sigio;</span><br><span class="line">                sigemptyset(&amp;act.sa_mask); <span class="comment">//当这个信号处理函数正在执行时，哪些信号要被“暂时屏蔽”</span></span><br><span class="line">                act.sa_flags = <span class="number">0</span>; <span class="comment">// 不启用任何特殊行为</span></span><br><span class="line">                sigaction(SIGIO, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 设置能接收这个信号的进程</span></span><br><span class="line">                fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">                <span class="comment">// 3. 开启信号驱动io</span></span><br><span class="line">                flags = fcntl(fd, F_GETFL);</span><br><span class="line">                fcntl(fd, F_SETFL, flags | O_ASYNC);</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        pause(); <span class="comment">// wait for signal</span></span><br><span class="line">                        <span class="keyword">if</span> (data_ready) &#123;</span><br><span class="line">                                data_ready = <span class="number">0</span>;</span><br><span class="line">                                ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;%s: read: %s\n&quot;</span>, prefix, buf);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                close(fd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>驱动程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KBUF_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> &#123;</span></span><br><span class="line">        <span class="type">dev_t</span> dev_num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="type">wait_queue_head_t</span> waitq;</span><br><span class="line">        <span class="type">char</span> kbuf[KBUF_SIZE];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fa</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> *<span class="title">drv_dat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">signal_io_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        file-&gt;private_data = drv_dat;</span><br><span class="line">        pr_info(<span class="string">&quot;signal_io_open is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">signal_io_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">size_t</span> len;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123; <span class="comment">// 非阻塞方式</span></span><br><span class="line">                mutex_lock(&amp;drv_dat-&gt;lock);</span><br><span class="line">                <span class="keyword">if</span> (dat-&gt;kbuf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                        mutex_unlock(&amp;drv_dat-&gt;lock);</span><br><span class="line">                        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">                &#125;</span><br><span class="line">                mutex_unlock(&amp;drv_dat-&gt;lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 阻塞方式</span></span><br><span class="line">                ret = wait_event_interruptible(drv_dat-&gt;waitq, (&#123;</span><br><span class="line">                                   <span class="type">bool</span> status;</span><br><span class="line">                                   mutex_lock(&amp;drv_dat-&gt;lock);</span><br><span class="line">                                   status = (dat-&gt;kbuf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">                                   mutex_unlock(&amp;drv_dat-&gt;lock);</span><br><span class="line">                                   status;</span><br><span class="line">                &#125;));</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        pr_info(<span class="string">&quot;signal_io_read called by pid: %d is interrupted\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line">        len = min(size, <span class="built_in">strlen</span>(dat-&gt;kbuf) + <span class="number">1</span>);        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, dat-&gt;kbuf, len) != <span class="number">0</span>) &#123;</span><br><span class="line">                mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dat-&gt;kbuf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// clear kbuf</span></span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;signal_io_read is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">signal_io_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">int</span> len = min(size, (<span class="type">size_t</span>)(KBUF_SIZE - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(drv_dat-&gt;kbuf, buf, len) != <span class="number">0</span>) &#123;</span><br><span class="line">                mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        dat-&gt;kbuf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        wake_up_interruptible(&amp;dat-&gt;waitq);</span><br><span class="line">        kill_fasync(&amp;dat-&gt;fa, SIGIO, POLLIN);</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;signal_io_write is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">__poll_t</span> <span class="title function_">signal_io_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">__poll_t</span> mask = <span class="number">0</span>;</span><br><span class="line">        pr_info(<span class="string">&quot;signal_io_poll is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line"></span><br><span class="line">        poll_wait(file, &amp;dat-&gt;waitq, p);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dat-&gt;kbuf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                mask |= POLLIN | POLLRDNORM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">signal_io_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        pr_info(<span class="string">&quot;signal_io_fasync is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> fasync_helper(fd, file, on, &amp;dat-&gt;fa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">signal_io_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;signal_io_release is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 强制从异步队列移除 */</span></span><br><span class="line">        signal_io_fasync(<span class="number">-1</span>, file, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = signal_io_open,</span><br><span class="line">        .read = signal_io_read,</span><br><span class="line">        .write = signal_io_write,</span><br><span class="line">        .poll = signal_io_poll,</span><br><span class="line">        .fasync = signal_io_fasync,</span><br><span class="line">        .release = signal_io_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">signal_io_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        drv_dat = (<span class="keyword">struct</span> drv_data *)kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> drv_data), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (drv_dat == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> kzalloc_fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = alloc_chrdev_region(&amp;drv_dat-&gt;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;chrdev_test_region&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> alloc_chrdev_region_fail;</span><br><span class="line"></span><br><span class="line">        cdev_init(&amp;drv_dat-&gt;cdev, &amp;fops);</span><br><span class="line">        drv_dat-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">        ret = cdev_add(&amp;drv_dat-&gt;cdev, drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> cdev_add_fail;</span><br><span class="line"></span><br><span class="line">        drv_dat-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;chrdev_test&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;class)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;class);</span><br><span class="line">                <span class="keyword">goto</span> class_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_dat-&gt;dev =</span><br><span class="line">                device_create(drv_dat-&gt;class, <span class="literal">NULL</span>, drv_dat-&gt;dev_num, <span class="literal">NULL</span>, <span class="string">&quot;signal_io_test%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;dev)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;dev);</span><br><span class="line">                <span class="keyword">goto</span> device_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_dat-&gt;kbuf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 初始化等待队列</span></span><br><span class="line">        init_waitqueue_head(&amp;drv_dat-&gt;waitq);</span><br><span class="line">        <span class="comment">// 初始化互斥锁</span></span><br><span class="line">        mutex_init(&amp;drv_dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">device_create_fail:</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">class_create_fail:</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">cdev_add_fail:</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">alloc_chrdev_region_fail:</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">kzalloc_fail:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">signal_io_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        device_destroy(drv_dat-&gt;class, drv_dat-&gt;dev_num);</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(signal_io_init);</span><br><span class="line">module_exit(signal_io_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@163.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;test sample for signal io&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">$ insmod signal_io.ko</span><br><span class="line">[   13.310579] signal_io: loading out-of-tree module taints kernel.</span><br><span class="line">$ ./test_signal.o</span><br><span class="line">[   16.052738] signal_io_open is called by pid: 102</span><br><span class="line">[   16.052761] signal_io_open is called by pid: 101</span><br><span class="line">[   16.053719] signal_io_write is called by pid: 102</span><br><span class="line">[   16.053816] signal_io_fasync is called by pid: 101</span><br><span class="line">[child pid:102]: write: Hello num 0</span><br><span class="line">[   17.062149] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 1</span><br><span class="line">[   17.063588] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 1</span><br><span class="line">[   18.066214] signal_io_write is called by pid: 102</span><br><span class="line">[   18.068176] signal_io_read is called by pid: 101</span><br><span class="line">[child pid:102]: write: Hello num 2</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 2</span><br><span class="line">[   19.072969] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 3</span><br><span class="line">[   19.078051] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 3</span><br><span class="line">[   20.078613] signal_io_write is called by pid: 102</span><br><span class="line">[   20.079554] signal_io_read is called by pid: 101</span><br><span class="line">[child pid:102]: write: Hello num 4</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 4</span><br><span class="line">[   21.081299] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 5</span><br><span class="line">[   21.082047] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 5</span><br><span class="line">[   22.082641] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 6</span><br><span class="line">[   22.083896] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 6</span><br><span class="line">[   23.085311] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 7</span><br><span class="line">[   23.086379] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 7</span><br><span class="line">[   24.088591] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 8</span><br><span class="line">[   24.091260] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 8</span><br><span class="line">[   25.094550] signal_io_write is called by pid: 102</span><br><span class="line">[   25.095438] signal_io_read is called by pid: 101</span><br><span class="line">[child pid:102]: write: Hello num 9</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 9</span><br><span class="line">[   26.098043] signal_io_write is called by pid: 102</span><br><span class="line">[   26.100002] signal_io_read is called by pid: 101</span><br><span class="line">[child pid:102]: write: Hello num 10</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 10</span><br><span class="line">[   27.103532] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 11</span><br><span class="line">[   27.105751] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 11</span><br><span class="line">[   28.112041] signal_io_write is called by pid: 102</span><br><span class="line">[child pid:102]: write: Hello num 12</span><br><span class="line">[   28.114740] signal_io_read is called by pid: 101</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 12</span><br><span class="line">[   29.118790] signal_io_write is called by pid: 102</span><br><span class="line">[   29.121123] signal_io_read is called by pid: 101</span><br><span class="line">[child pid:102]: write: Hello num 13</span><br><span class="line">[parent pid:101]: <span class="built_in">read</span>: Hello num 13</span><br><span class="line">^C[   29.356357] signal_io_fasync is called by pid: 101</span><br><span class="line">[   29.356383] signal_io_release is called by pid: 102</span><br><span class="line">[   29.356413] signal_io_fasync is called by pid: 102</span><br><span class="line">[   29.356999] signal_io_release is called by pid: 101</span><br><span class="line">[   29.357737] signal_io_fasync is called by pid: 101</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="异步IO-1"><a href="#异步IO-1" class="headerlink" title="异步IO"></a>异步IO</h2><p>异步IO依赖于应用层glibc中的实现，可以不依赖Linux内核</p>
<p>参考：</p>
<div class="tag link"><a class="link-card" title="Linux I/O 方式大汇总（下）—— 异步 I/O" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1915501761361313970"><div class="left"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.zhihu.com/heifetz/favicon.ico"/></div><div class="right"><p class="text">Linux I/O 方式大汇总（下）—— 异步 I/O</p><p class="url">https://zhuanlan.zhihu.com/p/1915501761361313970</p></div></a></div>

<p>对于<code>io_uring</code> 可以参考本站这篇文章</p>
<div class="tag link"><a class="link-card" title="io_uring" href="https://even629.com/posts/2601261/"><div class="left"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">io_uring</p><p class="url">https://even629.com/posts/2601261/</p></div></a></div>

<h1 id="Linux内核定时器"><a href="#Linux内核定时器" class="headerlink" title="Linux内核定时器"></a>Linux内核定时器</h1><p>硬件为内核提供了一个系统定时器来计算流逝的时间（即基于未来时间点的计时方式，以当前时刻为计时开始的起点，以未来的某一时刻为计时的终点），<strong>内核只有在系统定时器的帮助下才能计算和管理时间</strong>，但是<strong>内核定时器的精度并不高</strong>，所以不能作为高精度定时器使用。</p>
<p>并且内核定时器的运行没有周期性，到达计时终点后会自动关闭。如果要实现周期性定时，就要在定时处理函数中重新开启定时器。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Linux 内核中使用 timer_list 结构体表示内核定时器</p>
<p><strong>include&#x2F;linux&#x2F;timer.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment">	 * same cacheline</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		expires;</span><br><span class="line">	<span class="type">void</span>			(*function)(<span class="keyword">struct</span> timer_list *);</span><br><span class="line">	u32			flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="DEFINE-TIMER"><a href="#DEFINE-TIMER" class="headerlink" title="DEFINE_TIMER"></a>DEFINE_TIMER</h2><p><strong>include&#x2F;linux&#x2F;timer.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_INITIALIZER(_function, _flags) &#123;		\</span></span><br><span class="line"><span class="meta">		.entry = &#123; .next = TIMER_ENTRY_STATIC &#125;,	\</span></span><br><span class="line"><span class="meta">		.function = (_function),			\</span></span><br><span class="line"><span class="meta">		.flags = (_flags),				\</span></span><br><span class="line"><span class="meta">		__TIMER_LOCKDEP_MAP_INITIALIZER(		\</span></span><br><span class="line"><span class="meta">			__FILE__ <span class="string">&quot;:&quot;</span> __stringify(__LINE__))	\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function)				\</span></span><br><span class="line"><span class="meta">	struct timer_list _name =				\</span></span><br><span class="line"><span class="meta">		__TIMER_INITIALIZER(_function, 0)</span></span><br></pre></td></tr></table></figure>

<p>可以使用以下代码对定时器和相应的定时处理函数进行定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br></pre></td></tr></table></figure>

<h2 id="add-timer"><a href="#add-timer" class="headerlink" title="add_timer()"></a>add_timer()</h2><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>void add_timer(struct timer_list *timer);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/timer.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 timer</strong></td>
<td>一个已初始化好的定时器对象，必须设置 <code>expires</code>（到期时间） 和 <code>function</code>（回调函数）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>将定时器注册到内核，使其开始计时。当 <code>expires</code> 到达时触发回调函数</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值（void）</td>
</tr>
</tbody></table>
<h2 id="del-timer"><a href="#del-timer" class="headerlink" title="del_timer()"></a>del_timer()</h2><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>int del_timer(struct timer_list *timer);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/timer.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 timer</strong></td>
<td>需要删除的定时器对象</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>从内核中删除定时器，使其不再触发。不会等待回调执行结束（如需等待请使用 <code>del_timer_sync()</code>）</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功删除：<strong>1</strong>（定时器处于激活状态）已经不在激活队列：<strong>0</strong></td>
</tr>
</tbody></table>
<h2 id="mod-timer"><a href="#mod-timer" class="headerlink" title="mod_timer()"></a>mod_timer()</h2><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>int mod_timer(struct timer_list *timer, unsigned long expires);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/timer.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 timer</strong></td>
<td>需要修改的定时器对象</td>
</tr>
<tr>
<td><strong>参数 expires</strong></td>
<td>新的到期时间（单位：jiffies）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>修改定时器的到期时间。如果定时器未激活，会<strong>自动激活</strong>。如果已激活，会<strong>重新开始计时</strong></td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>定时器之前已激活：<strong>1</strong><br />定时器之前未激活：<strong>0</strong></td>
</tr>
</tbody></table>
<p>在使用 add_timer()函数向 Linux 内核注册定时器之前，还需要设置定时时间，定时时间由 timer_list 结构体中的 expires 参数所确定，单位为节拍数，可以通过Linux编译时图形化界面menuconfig设置系统节拍的频率，具体路径如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Kernel Features</span><br><span class="line">	-&gt; Timer <span class="title function_">frequency</span> <span class="params">(&lt;choice&gt; [=y])</span></span><br></pre></td></tr></table></figure>

<p>当前版本内核代码可选的系统节拍率为 100Hz、250Hz、300Hz 和 1000Hz，默认情况下选择300Hz。</p>
<h2 id="全局变量-jiffies"><a href="#全局变量-jiffies" class="headerlink" title="全局变量 jiffies"></a>全局变量 jiffies</h2><p>通过全局变量 jiffies 来记录自系统启动以来产生节拍的总数。jiffies_64 用于 64 位系统，而 jiffies 用于 32 位系统。启动时，内核将该变量初始化为 0，此后，每次时钟中断处理程序都会增加该变量的值，一秒内 jiffes 增加的值为设置的系统节拍数，该变量定义在”include&#x2F;linux&#x2F;jiffies.h”文件中（timer.h 文件中已经包含，不需要重复引用），具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 __cacheline_aligned_in_smp jiffies_64;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>

<h2 id="jiffies-与时间单位转换函数"><a href="#jiffies-与时间单位转换函数" class="headerlink" title="jiffies 与时间单位转换函数"></a>jiffies 与时间单位转换函数</h2><table>
<thead>
<tr>
<th>函数定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int jiffies_to_msecs(const unsigned long j)</strong></td>
<td>将 <code>jiffies</code> 类型的参数 <code>j</code> 转换为对应的毫秒</td>
</tr>
<tr>
<td><strong>int jiffies_to_usecs(const unsigned long j)</strong></td>
<td>将 <code>jiffies</code> 类型的参数 <code>j</code> 转换为对应的微秒</td>
</tr>
<tr>
<td><strong>u64 jiffies_to_nsecs(const unsigned long j)</strong></td>
<td>将 <code>jiffies</code> 类型的参数 <code>j</code> 转换为对应的纳秒</td>
</tr>
<tr>
<td><strong>long msecs_to_jiffies(const unsigned int m)</strong></td>
<td>将毫秒转换为 <code>jiffies</code> 类型</td>
</tr>
<tr>
<td><strong>long usecs_to_jiffies(const unsigned int u)</strong></td>
<td>将微秒转换为 <code>jiffies</code> 类型</td>
</tr>
<tr>
<td><strong>unsigned long nsecs_to_jiffies(u64 n)</strong></td>
<td>将纳秒转换为 <code>jiffies</code> 类型</td>
</tr>
</tbody></table>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> &#123;</span></span><br><span class="line">        <span class="type">dev_t</span> dev_num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">drv_data</span> *<span class="title">drv_dat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_irq_func</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;</span><br><span class="line"></span><br><span class="line">DEFINE_TIMER(timer_test, timer_irq_func);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_mod_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        file-&gt;private_data = drv_dat;</span><br><span class="line">        pr_info(<span class="string">&quot;open is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">timer_mod_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">size_t</span> len = min(<span class="keyword">sizeof</span>(u64) + <span class="number">1</span>, size);</span><br><span class="line">        <span class="type">char</span> kbuf[<span class="number">72</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(kbuf, <span class="keyword">sizeof</span>(kbuf), <span class="string">&quot;%llu&quot;</span>, jiffies64_to_msecs(jiffies_64));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, kbuf, len) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;read is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_mod_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;release is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = timer_mod_test_open,</span><br><span class="line">        .read = timer_mod_test_read,</span><br><span class="line">        .release = timer_mod_test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_irq_func</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;timer_irq_func is called\n&quot;</span>);</span><br><span class="line">        mod_timer(&amp;timer_test, jiffies_64 + msecs_to_jiffies(<span class="number">3000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_mod_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        drv_dat = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> drv_data), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (drv_dat == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> kzalloc_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;drv_dat-&gt;dev_num, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;timer_mod_test_chrdev_region&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> alloc_chrdev_region_fail;</span><br><span class="line"></span><br><span class="line">        cdev_init(&amp;drv_dat-&gt;cdev, &amp;fops);</span><br><span class="line">        drv_dat-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">        ret = cdev_add(&amp;drv_dat-&gt;cdev, drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> cdev_add_fail;</span><br><span class="line"></span><br><span class="line">        drv_dat-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;chrdev&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;class)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;class);</span><br><span class="line">                <span class="keyword">goto</span> class_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_dat-&gt;dev =</span><br><span class="line">                device_create(drv_dat-&gt;class, <span class="literal">NULL</span>, drv_dat-&gt;dev_num, <span class="literal">NULL</span>, <span class="string">&quot;timer_test%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;dev)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;dev);</span><br><span class="line">                <span class="keyword">goto</span> device_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把timer_test设置为5s后</span></span><br><span class="line">        timer_test.expires = jiffies_64 + msecs_to_jiffies(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">// 添加一个定时器</span></span><br><span class="line">        add_timer(&amp;timer_test);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">device_create_fail:</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">class_create_fail:</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">cdev_add_fail:</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">alloc_chrdev_region_fail:</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">kzalloc_fail:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_mod_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 删除定时器</span></span><br><span class="line">        del_timer(&amp;timer_test);</span><br><span class="line">        device_destroy(drv_dat-&gt;class, drv_dat-&gt;dev_num);</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line"></span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line"></span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(timer_mod_test_init);</span><br><span class="line">module_exit(timer_mod_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a test sample for linux timer&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>可以利用原子变量和timer做一个定时器，示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_drv_data</span> &#123;</span></span><br><span class="line">        <span class="type">dev_t</span> dev_num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="type">atomic64_t</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_drv_data</span> *<span class="title">timer_drv_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_sec_func</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;</span><br><span class="line"></span><br><span class="line">DEFINE_TIMER(timer_sec, timer_sec_func);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_sec_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        file-&gt;private_data = timer_drv_data;</span><br><span class="line">        <span class="comment">// 初始化为0</span></span><br><span class="line">        atomic64_set(&amp;timer_drv_data-&gt;sec, <span class="number">0</span>);</span><br><span class="line">        add_timer(&amp;timer_sec);</span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">&quot;open is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">timer_sec_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timer_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> kbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(kbuf, <span class="keyword">sizeof</span>(kbuf), <span class="string">&quot;current sec: %llu\n&quot;</span>, atomic64_read(&amp;dat-&gt;sec));</span><br><span class="line"></span><br><span class="line">        len = min(size, <span class="built_in">strlen</span>(kbuf) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, kbuf, len) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_sec_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        del_timer(&amp;timer_sec);</span><br><span class="line">        pr_info(<span class="string">&quot;release is called by pid: %d\n&quot;</span>, task_pid_nr(current));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = timer_sec_test_open,</span><br><span class="line">        .read = timer_sec_test_read,</span><br><span class="line">        .release = timer_sec_test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_sec_func</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">        atomic64_inc(&amp;timer_drv_data-&gt;sec);</span><br><span class="line">        mod_timer(&amp;timer_sec, get_jiffies_64() + msecs_to_jiffies(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_sec_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        timer_drv_data = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> timer_drv_data), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (timer_drv_data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> kzalloc_fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = alloc_chrdev_region(&amp;timer_drv_data-&gt;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;test_chrdev_region&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> alloc_chrdev_region_fail;</span><br><span class="line"></span><br><span class="line">        cdev_init(&amp;timer_drv_data-&gt;cdev, &amp;fops);</span><br><span class="line">        timer_drv_data-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">        ret = cdev_add(&amp;timer_drv_data-&gt;cdev, timer_drv_data-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> cdev_add_fail;</span><br><span class="line"></span><br><span class="line">        timer_drv_data-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;chrdev&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(timer_drv_data-&gt;class)) &#123;</span><br><span class="line">                ret = PTR_ERR(timer_drv_data-&gt;class);</span><br><span class="line">                <span class="keyword">goto</span> class_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer_drv_data-&gt;dev = device_create(timer_drv_data-&gt;class, <span class="literal">NULL</span>, timer_drv_data-&gt;dev_num,</span><br><span class="line">                                            <span class="literal">NULL</span>, <span class="string">&quot;timer_sec%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(timer_drv_data-&gt;dev)) &#123;</span><br><span class="line">                ret = PTR_ERR(timer_drv_data-&gt;dev);</span><br><span class="line">                <span class="keyword">goto</span> device_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">device_create_fail:</span><br><span class="line">        class_destroy(timer_drv_data-&gt;class);</span><br><span class="line">class_create_fail:</span><br><span class="line">        cdev_del(&amp;timer_drv_data-&gt;cdev);</span><br><span class="line">cdev_add_fail:</span><br><span class="line">        unregister_chrdev_region(timer_drv_data-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">alloc_chrdev_region_fail:</span><br><span class="line">        kfree(timer_drv_data);</span><br><span class="line">kzalloc_fail:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_sec_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        class_destroy(timer_drv_data-&gt;class);</span><br><span class="line"></span><br><span class="line">        cdev_del(&amp;timer_drv_data-&gt;cdev);</span><br><span class="line"></span><br><span class="line">        unregister_chrdev_region(timer_drv_data-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        kfree(timer_drv_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(timer_sec_init);</span><br><span class="line">module_exit(timer_sec_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a sec timer&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="Linux内核打印"><a href="#Linux内核打印" class="headerlink" title="Linux内核打印"></a>Linux内核打印</h1><h2 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h2><p>终端使用 dmseg 命令可以获取内核打印信息，该命令的具体使用方法如下所示：<br><strong>dmesg</strong> 命令</p>
<ul>
<li>英文全称：display message（显示信息）</li>
<li>作用：kernel 会将打印信息存储在 ring buffer 中。可以利用 dmesg 命令来查看内核打印信息</li>
<li>常用参数:<ul>
<li><strong>-C</strong>，–clear 清除内核环形缓冲区</li>
<li><strong>-c</strong>，—-read-clear 读取并清除所有消息</li>
<li><strong>-T</strong>，–显示时间戳</li>
</ul>
</li>
</ul>
<p>dmesg 命令也可以与 grep 命令组合使用。如查找待用 usb 关键字的打印信息，就可以使用如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep usb</span><br></pre></td></tr></table></figure>

<p>与tail命令结合，查看最后100行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span> -n 100</span><br></pre></td></tr></table></figure>







<h2 id="kmsg文件"><a href="#kmsg文件" class="headerlink" title="kmsg文件"></a>kmsg文件</h2><p>内核所有的打印信息都会输出到循环缓冲区 ‘log_buf’，为了能够方便的在用户空间读取内核打印信息，Linux 内核驱动将该循环缓冲区映射到了&#x2F;proc 目录下的文件节点 kmsg。</p>
<p>通过cat 或者其他应用程序读取 Log Buffer 的时候可以不断的等待新的 log，所以<strong>访问&#x2F;proc&#x2F;kmsg的方式适合长时间的读取 log</strong>，一旦有新的 log 就可以被打印出来。</p>
<p>首先使用以下命令读取 kmsg 文件，在没有新的内核打印信息时会阻塞</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kmsg</span><br></pre></td></tr></table></figure>

<h2 id="调整内核打印等级"><a href="#调整内核打印等级" class="headerlink" title="调整内核打印等级"></a>调整内核打印等级</h2><p>内核的日志打印由相应的打印等级来控制，可以通过调整内核打印等级来控制打印日志的输出。使用以下命令查看当前默认打印等级</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>可以看到内核打印等级由四个数字所决定，“7 4 1 7” 分别对应 console_loglevel、default_message_loglevel、minimum_console_loglevel、default_console_loglevel，具体类型说明如下：</p>
<ol>
<li><strong>console_loglevel</strong><ul>
<li>描述：控制哪些级别的消息可以输出到 <strong>终端</strong>（console）。</li>
<li>规则：只有当消息的 log 优先级 <strong>高于 console_loglevel</strong> 时，才会在终端显示。</li>
<li>举例：“7”表示允许所有级别的消息（0~7）都输出到终端。</li>
</ul>
</li>
<li><strong>default_message_loglevel</strong><ul>
<li>描述：<code>printk</code> 函数打印消息时默认的 log 等级（priority）。</li>
<li>举例：“4”表示默认打印的消息级别是 <strong>警告（warning）</strong>。</li>
</ul>
</li>
<li><strong>minimum_console_loglevel</strong><ul>
<li>描述：console_loglevel 可以设置的最小值。</li>
<li>举例：“1”表示 console_loglevel 最低可以设置为 1，也就是 <strong>紧急（emerg）</strong>。</li>
</ul>
</li>
<li><strong>default_console_loglevel</strong><ul>
<li>描述：内核启动时 console_loglevel 的缺省值。</li>
<li>举例：“7”表示缺省情况下允许 <strong>所有等级</strong> 输出到终端。</li>
</ul>
</li>
</ol>
<p><strong>include&#x2F;linux&#x2F;printk.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> console_printk[<span class="number">4</span>] = &#123;</span><br><span class="line">	CONSOLE_LOGLEVEL_DEFAULT,	<span class="comment">/* console_loglevel */</span></span><br><span class="line">	MESSAGE_LOGLEVEL_DEFAULT,	<span class="comment">/* default_message_loglevel */</span></span><br><span class="line">	CONSOLE_LOGLEVEL_MIN,		<span class="comment">/* minimum_console_loglevel */</span></span><br><span class="line">	CONSOLE_LOGLEVEL_DEFAULT,	<span class="comment">/* default_console_loglevel */</span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(console_printk);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>include&#x2F;linux&#x2F;kern_levels.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERN_LEVELS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERN_LEVELS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SOH	<span class="string">&quot;\001&quot;</span>		<span class="comment">/* ASCII Start Of Header */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SOH_ASCII	<span class="string">&#x27;\001&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG	KERN_SOH <span class="string">&quot;0&quot;</span>	<span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT	KERN_SOH <span class="string">&quot;1&quot;</span>	<span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT	KERN_SOH <span class="string">&quot;2&quot;</span>	<span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR	KERN_SOH <span class="string">&quot;3&quot;</span>	<span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING	KERN_SOH <span class="string">&quot;4&quot;</span>	<span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE	KERN_SOH <span class="string">&quot;5&quot;</span>	<span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO	KERN_SOH <span class="string">&quot;6&quot;</span>	<span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG	KERN_SOH <span class="string">&quot;7&quot;</span>	<span class="comment">/* debug-level messages */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEFAULT	<span class="string">&quot;&quot;</span>		<span class="comment">/* the default kernel loglevel */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Annotation for a &quot;continued&quot; line of log printout (only done after a</span></span><br><span class="line"><span class="comment"> * line that had no enclosing \n). Only to be used by core/arch code</span></span><br><span class="line"><span class="comment"> * during early bootup (a continued line is not SMP-safe otherwise).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CONT	KERN_SOH <span class="string">&quot;c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* integer equivalents of KERN_&lt;LEVEL&gt; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_SCHED		-2	<span class="comment">/* Deferred messages from sched code</span></span></span><br><span class="line"><span class="comment"><span class="meta">					 * are set to this special level */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_DEFAULT	-1	<span class="comment">/* default (or last) loglevel */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_EMERG		0	<span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_ALERT		1	<span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_CRIT		2	<span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_ERR		3	<span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_WARNING	4	<span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_NOTICE		5	<span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_INFO		6	<span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGLEVEL_DEBUG		7	<span class="comment">/* debug-level messages */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>数字</th>
<th>等级名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>KERN_EMERG</td>
<td>紧急，系统不可用</td>
</tr>
<tr>
<td>1</td>
<td>KERN_ALERT</td>
<td>警报，需要立即处理</td>
</tr>
<tr>
<td>2</td>
<td>KERN_CRIT</td>
<td>严重错误</td>
</tr>
<tr>
<td>3</td>
<td>KERN_ERR</td>
<td>一般错误</td>
</tr>
<tr>
<td>4</td>
<td>KERN_WARNING</td>
<td>警告</td>
</tr>
<tr>
<td>5</td>
<td>KERN_NOTICE</td>
<td>普通但重要信息</td>
</tr>
<tr>
<td>6</td>
<td>KERN_INFO</td>
<td>信息性消息</td>
</tr>
<tr>
<td>7</td>
<td>KERN_DEBUG</td>
<td>调试消息</td>
</tr>
</tbody></table>
<p>修改内核打印等级：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 4 1 7 &gt; /proc/sys/kernel/printk</span><br><span class="line"><span class="comment"># 如果提示permission denied, 用下面这个命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;7 4 1 7&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>printk 在打印信息前，可以加入相应的打印等级宏定义，具体格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(打印等级 <span class="string">&quot;打印信息&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="llseek定位设备驱动"><a href="#llseek定位设备驱动" class="headerlink" title="llseek定位设备驱动"></a>llseek定位设备驱动</h1><h2 id="应用层lseek"><a href="#应用层lseek" class="headerlink" title="应用层lseek()"></a>应用层lseek()</h2><p>所有打开的文件都有一个<strong>当前文件偏移量（current file offset）</strong>，以下简称为 cfo。cfo 通常是一个<strong>非负整数</strong>，用于表明文件开始处到文件当前位置的字节数。读写操作通常开始于 cfo，并且使 cfo 增大，增量为读写的字节数。文件被打开时，cfo 会被初始化为 0，除非使用了 O_APPEND 。 使用 lseek 函数可以改变文件的 cfo 。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>函数定义</td>
<td><strong>off_t lseek(int fd, off_t offset, int whence);</strong></td>
</tr>
<tr>
<td>头文件</td>
<td><code>#include &lt;sys/types.h&gt;</code><br /><code>#include &lt;unistd.h&gt;</code></td>
</tr>
<tr>
<td>参数 <strong>fd</strong></td>
<td>文件描述符</td>
</tr>
<tr>
<td>参数 <strong>off_t offset</strong></td>
<td>偏移量，<strong>单位为字节</strong>，<strong>正负分别表示向前、向后移动</strong></td>
</tr>
<tr>
<td>参数 <strong>whence</strong></td>
<td>位置基点，可选 <strong>SEEK_SET</strong>（文件开头）、<strong>SEEK_CUR</strong>（当前指针位置）、<strong>SEEK_END</strong>（文件末尾）</td>
</tr>
<tr>
<td>功能</td>
<td>移动文件读写指针；获取文件长度；拓展文件空间</td>
</tr>
<tr>
<td>返回值</td>
<td>成功<strong>返回当前位移(SEEK_CUR)</strong>，失败返回 - 1</td>
</tr>
</tbody></table>
<p><strong>例子</strong>：</p>
<ul>
<li><p>把文件位置指针设置为 100(开头+100个字节)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd,<span class="number">100</span>,SEEK_SET);</span><br></pre></td></tr></table></figure>
</li>
<li><p>把文件位置设置成文件末尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd,<span class="number">0</span>,SEEK_END);</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定当前的文件位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd,<span class="number">0</span>,SEEK_CUR);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="file-operation-llseek"><a href="#file-operation-llseek" class="headerlink" title="file_operation.llseek"></a>file_operation.llseek</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">loff_t</span> (*llseek)(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：文件指针偏移操作（类似 lseek 系统调用）。</li>
<li><strong>参数</strong>：<ul>
<li><code>file</code>：文件对象。</li>
<li><code>offset</code>：偏移量。</li>
<li><code>whence</code>：<ul>
<li><code>SEEK_SET</code>：相对于文件开头</li>
<li><code>SEEK_CUR</code>：相对于当前文件指针</li>
<li><code>SEEK_END</code>：相对于文件末尾</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li>新的文件指针位置（<code>loff_t</code>）</li>
<li>出错返回负值（如 <code>-EINVAL</code>）</li>
</ul>
</li>
</ul>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMEM_SIZE 32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_drv_data</span> &#123;</span></span><br><span class="line">        <span class="type">dev_t</span> dev_num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">        <span class="type">char</span> kmem[KMEM_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">test_drv_data</span> *<span class="title">drv_dat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        file-&gt;private_data = drv_dat;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">test_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*offset &gt;= KMEM_SIZE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// EOF</span></span><br><span class="line">        len = min(size, (<span class="type">size_t</span>)(KMEM_SIZE - *offset));</span><br><span class="line">        </span><br><span class="line">        ret = mutex_lock_interruptible(&amp;dat-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pr_info(<span class="string">&quot;test_read is interrupted while acquiring the mutex\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, dat-&gt;kmem + *offset, len) != <span class="number">0</span>) &#123;</span><br><span class="line">                mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        *offset += len;</span><br><span class="line">        <span class="keyword">return</span> len;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">test_drv_data</span> *<span class="title">dat</span> =</span> file-&gt;private_data;</span><br><span class="line">        <span class="type">size_t</span> len = min(size, (<span class="type">size_t</span>)(KMEM_SIZE - *offset));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*offset &gt; KMEM_SIZE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// EOF</span></span><br><span class="line"></span><br><span class="line">        ret = mutex_lock_interruptible(&amp;dat-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pr_info(<span class="string">&quot;test_read is interrupted while acquiring the mutex\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(dat-&gt;kmem + *offset, buf, len) != <span class="number">0</span>) &#123;</span><br><span class="line">                mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;dat-&gt;lock);</span><br><span class="line">        *offset += len;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">loff_t</span> <span class="title function_">test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">loff_t</span> new_offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (whence) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEEK_SET:</span><br><span class="line">                new_offset = offset;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">                new_offset = file-&gt;f_pos + offset;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEEK_END:</span><br><span class="line">                new_offset = KMEM_SIZE + offset;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_offset &lt; <span class="number">0</span> || new_offset &gt; KMEM_SIZE)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        file-&gt;f_pos = new_offset;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_offset;</span><br><span class="line">        <span class="comment">// return fixed_size_llseek(file, offset, whence, KMEM_SIZE);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = test_open,</span><br><span class="line">        .read = test_read,</span><br><span class="line">        .write = test_write,</span><br><span class="line">        .llseek = test_llseek,</span><br><span class="line">        .release = test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">llseek_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        drv_dat = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test_drv_data), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (drv_dat == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> kzalloc_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;drv_dat-&gt;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;test_chrdev_region&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> alloc_chrdev_region;</span><br><span class="line">        cdev_init(&amp;drv_dat-&gt;cdev, &amp;fops);</span><br><span class="line">        drv_dat-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">        ret = cdev_add(&amp;drv_dat-&gt;cdev, drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> cdev_add_fail;</span><br><span class="line"></span><br><span class="line">        drv_dat-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;chrdev&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;class)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;class);</span><br><span class="line">                <span class="keyword">goto</span> class_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_dat-&gt;dev =</span><br><span class="line">                device_create(drv_dat-&gt;class, <span class="literal">NULL</span>, drv_dat-&gt;dev_num, <span class="literal">NULL</span>, <span class="string">&quot;llseek_test%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drv_dat-&gt;dev)) &#123;</span><br><span class="line">                ret = PTR_ERR(drv_dat-&gt;dev);</span><br><span class="line">                <span class="keyword">goto</span> device_create_fail;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_init(&amp;drv_dat-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">device_create_fail:</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">class_create_fail:</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">cdev_add_fail:</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">alloc_chrdev_region:</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">kzalloc_fail:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">llseek_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        device_destroy(drv_dat-&gt;class, drv_dat-&gt;dev_num);</span><br><span class="line">        class_destroy(drv_dat-&gt;class);</span><br><span class="line">        cdev_del(&amp;drv_dat-&gt;cdev);</span><br><span class="line">        unregister_chrdev_region(drv_dat-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(drv_dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(llseek_test_init);</span><br><span class="line">module_exit(llseek_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a test description for llseek&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>对于固定缓冲区大小的设备，可直接返回内核已经实现好的<code>fixed_size_llseek(file, offset, whence, KMEM_SIZE);</code></strong></p>
<p>测试用例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DEV_PATH &quot;/dev/llseek_test0&quot;</span></span><br><span class="line"><span class="comment">#define BUF_SIZE 64</span></span><br><span class="line"></span><br><span class="line">static void dump_buf(const char *tag, const char *buf, ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s (%zd bytes): \&quot;&quot;</span>, tag, len);</span><br><span class="line">        <span class="keyword">for</span> (ssize_t i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf[i] &gt;= 32 &amp;&amp; buf[i] &lt;= 126)</span><br><span class="line">                        putchar(buf[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\\x%02x&quot;</span>, (unsigned char)buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int fd;</span><br><span class="line">        char buf[BUF_SIZE];</span><br><span class="line">        ssize_t ret;</span><br><span class="line">        off_t off;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open %s\n&quot;</span>, DEV_PATH);</span><br><span class="line">        fd = open(DEV_PATH, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; 0) &#123;</span><br><span class="line">                perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span> 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* ================= write ================= */</span><br><span class="line">        const char *msg = <span class="string">&quot;Hello llseek test!&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[TEST] write \&quot;%s\&quot;\n&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">        ret = write(fd, msg, strlen(msg));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">                perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write ret = %zd\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        /* ================= SEEK_SET ================= */</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[TEST] lseek SEEK_SET 0\n&quot;</span>);</span><br><span class="line">        off = lseek(fd, 0, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (off &lt; 0) &#123;</span><br><span class="line">                perror(<span class="string">&quot;lseek SEEK_SET&quot;</span>);</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current offset = %ld\n&quot;</span>, off);</span><br><span class="line"></span><br><span class="line">        memset(buf, 0, sizeof(buf));</span><br><span class="line">        ret = <span class="built_in">read</span>(fd, buf, sizeof(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        dump_buf(<span class="string">&quot;read&quot;</span>, buf, ret);</span><br><span class="line"></span><br><span class="line">        /* ================= SEEK_CUR ================= */</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[TEST] lseek SEEK_CUR -6\n&quot;</span>);</span><br><span class="line">        off = lseek(fd, -6, SEEK_CUR);</span><br><span class="line">        <span class="keyword">if</span> (off &lt; 0) &#123;</span><br><span class="line">                perror(<span class="string">&quot;lseek SEEK_CUR&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;current offset = %ld\n&quot;</span>, off);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memset(buf, 0, sizeof(buf));</span><br><span class="line">        ret = <span class="built_in">read</span>(fd, buf, 6);</span><br><span class="line">        dump_buf(<span class="string">&quot;read&quot;</span>, buf, ret);</span><br><span class="line"></span><br><span class="line">        /* ================= SEEK_END ================= */</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[TEST] lseek SEEK_END -5\n&quot;</span>);</span><br><span class="line">        off = lseek(fd, -5, SEEK_END);</span><br><span class="line">        <span class="keyword">if</span> (off &lt; 0) &#123;</span><br><span class="line">                perror(<span class="string">&quot;lseek SEEK_END&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;current offset = %ld\n&quot;</span>, off);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memset(buf, 0, sizeof(buf));</span><br><span class="line">        ret = <span class="built_in">read</span>(fd, buf, 5);</span><br><span class="line">        dump_buf(<span class="string">&quot;read&quot;</span>, buf, ret);</span><br><span class="line"></span><br><span class="line">        /* ================= EOF ================= */</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[TEST] read until EOF\n&quot;</span>);</span><br><span class="line">        off = lseek(fd, 0, SEEK_SET);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;seek to %ld\n&quot;</span>, off);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (1) &#123;</span><br><span class="line">                ret = <span class="built_in">read</span>(fd, buf, 8);</span><br><span class="line">                <span class="keyword">if</span> (ret == 0) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;EOF reached\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dump_buf(<span class="string">&quot;chunk&quot;</span>, buf, ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* ================= invalid lseek ================= */</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[TEST] invalid lseek (beyond end)\n&quot;</span>);</span><br><span class="line">        off = lseek(fd, 100, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (off &lt; 0)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;expected error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;unexpected success, off=%ld\n&quot;</span>, off);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ ./test_llseek.o</span><br><span class="line">open /dev/llseek_test0</span><br><span class="line"></span><br><span class="line">[TEST] write <span class="string">&quot;Hello llseek test!&quot;</span></span><br><span class="line">write ret = 18</span><br><span class="line"></span><br><span class="line">[TEST] lseek SEEK_SET 0</span><br><span class="line">current offset = 0</span><br><span class="line"><span class="built_in">read</span> (32 bytes): <span class="string">&quot;Hello llseek test!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">[TEST] lseek SEEK_CUR -6</span><br><span class="line">current offset = 26</span><br><span class="line"><span class="built_in">read</span> (6 bytes): <span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">[TEST] lseek SEEK_END -5</span><br><span class="line">current offset = 27</span><br><span class="line"><span class="built_in">read</span> (5 bytes): <span class="string">&quot;\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">[TEST] <span class="built_in">read</span> <span class="keyword">until</span> EOF</span><br><span class="line">seek to 0</span><br><span class="line">chunk (8 bytes): <span class="string">&quot;Hello ll&quot;</span></span><br><span class="line">chunk (8 bytes): <span class="string">&quot;seek tes&quot;</span></span><br><span class="line">chunk (8 bytes): <span class="string">&quot;t!\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">chunk (8 bytes): <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">EOF reached</span><br><span class="line"></span><br><span class="line">[TEST] invalid lseek (beyond end)</span><br><span class="line">expected error: Invalid argument</span><br></pre></td></tr></table></figure>





<h1 id="ioctl设备操作"><a href="#ioctl设备操作" class="headerlink" title="ioctl设备操作"></a>ioctl设备操作</h1><h2 id="应用层ioctl"><a href="#应用层ioctl" class="headerlink" title="应用层ioctl()"></a>应用层ioctl()</h2><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>int ioctl(int fd, unsigned long op, … &#x2F;* arg *&#x2F; );</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;sys/ioctl.h&gt;</code>（可能需要设备相关头文件，如 <code>linux/ioctl.h</code>）</td>
</tr>
<tr>
<td><strong>参数 fd</strong></td>
<td>打开的设备文件描述符（如 <code>/dev/...</code>）</td>
</tr>
<tr>
<td><strong>参数 op</strong></td>
<td>IO 控制命令（通常通过 <code>_IO</code>, <code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code> 等宏构建）</td>
</tr>
<tr>
<td><strong>参数 arg</strong>（可选）</td>
<td>与 request 命令关联的数据，可以为 <code>int*</code>, <code>void*</code>, <code>struct *</code> 等</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>对设备驱动执行控制命令（非数据读写类），用于配置硬件、获取状态、发送控制指令等</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功：通常为 <strong>0</strong>（也可能返回其他正值，视 request 而定）<br />失败：返回 <strong>-1</strong>，并设置 errno</td>
</tr>
</tbody></table>
<p>上述三个参数中，最重要的是第二个 op参数，为 unsigned int 类型，为了高效的使用 op参数传递更多的控制信息，一个 unsigned int op被拆分为了 4 段，每一段都有各自的意义，unsigned int cmd 位域拆分如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| <span class="number">31</span> <span class="number">30</span> | <span class="number">29</span> <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>. <span class="number">16</span> | <span class="number">15</span> <span class="params">...</span><span class="params">...</span> <span class="number">8</span> | <span class="number">7</span> <span class="params">...</span><span class="params">...</span><span class="params">...</span>. <span class="number">0</span> |</span><br><span class="line">| dir   |         size           |    <span class="keyword">type</span>     |       nr       |</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>op[31:30]</strong>     <strong>dir</strong> <strong>数据（args）的传输方向（读写）</strong></li>
<li><strong>op[29:16]</strong>     <strong>size</strong> <strong>数据（args）的大小</strong></li>
<li><strong>op[15:8]</strong>       <strong>type</strong> <strong>命令的类型，可以理解成命令的密钥</strong>，一般为 ASCII 码（0-255 的一个字符，有部分字符已经被占用，每个字符的序号段可能部分被占用）</li>
<li><strong>op[7:0]</strong>         <strong>nr</strong> <strong>命令的序号</strong>，是一个 8bits 的数字（序号，0-255 之间）</li>
</ul>
<p>op 参数由 <strong>ioctl 合成宏</strong>定义得到，四个合成宏定义如下所示：</p>
<ol>
<li>定义一个命令，但是不需要参数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)</span></span><br><span class="line">   _IOC(_IOC_NONE,(type),(nr),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义一个命令，应用程序从驱动程序读参数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)</span></span><br><span class="line">   _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义一个命令，应用程序向驱动程序写参数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)</span></span><br><span class="line">   _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>定义一个命令，参数是双向传递的（先写再读）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br></pre></td></tr></table></figure>

<p>   宏定义参数说明如下所示：</p>
<ul>
<li><strong>type</strong>：<strong>命令的类型，一般为一个 ASCII 码值</strong>，<strong>一个驱动程序一般使用一个 type</strong></li>
<li><strong>nr</strong>：该命令下序号。一个驱动有多个命令，一般他们的 type，序号不同</li>
<li><strong>size</strong>：args 的类型</li>
</ul>
<p>例如可以使用以下代码定义不需要参数、向驱动程序写参数、向驱动程序读参数三个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br></pre></td></tr></table></figure>
<p>在 Linux 内核的 ioctl 接口中，每个 ioctl 命令只能传递一个用户空间指针（即一个参数）。但这并不意味着只能传一个整数,可以通过 <strong>传递一个结构体指针 来实现“多个参数”</strong>。</p>
<blockquote>
<p><code>SIZE = arg 参数的数据结构大小（字节数）</code>它是驱动创建 ioctl 命令码时自动编码进去的。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IOR(<span class="string">&#x27;M&#x27;</span>, <span class="number">1</span>, <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>会自动把：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>编码进 op。如果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IOW(<span class="string">&#x27;M&#x27;</span>, <span class="number">2</span>, <span class="keyword">struct</span> task_info)</span><br></pre></td></tr></table></figure>

<p>则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_info)</span><br></pre></td></tr></table></figure>

<p>用户调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> <span class="title">info</span>;</span></span><br><span class="line">ioctl(fd, MY_WRITE_TASK, &amp;info);</span><br></pre></td></tr></table></figure>

<p>内核收到后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(&amp;kernel_buffer, (<span class="type">void</span> __user *)arg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_info));</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="file-operations-ioctl"><a href="#file-operations-ioctl" class="headerlink" title="file_operations.ioctl"></a>file_operations.ioctl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">unlocked_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">compat_ioctl</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>unlocked_ioctl</code> 给“本机位宽”的用户程序用</strong></p>
<p> <strong><code>compat_ioctl</code> 给“32 位用户程序跑在 64 位内核”用</strong></p>
</blockquote>
<p>内核会用 <strong>ioctl 分解宏</strong> 解析 cmd：</p>
<ul>
<li><code>_IOC_DIR(cmd)</code> —— 数据方向</li>
<li><code>_IOC_TYPE(cmd)</code> —— 设备 magic</li>
<li><code>_IOC_NR(cmd)</code> —— 命令编号</li>
<li><code>_IOC_SIZE(cmd)</code> —— 传递数据大小</li>
</ul>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> counter; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,fnction_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;this is fnction_test\n&quot;</span>);</span><br><span class="line">    mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(dev1.counter));<span class="comment">//使用mod_timer函数重新设置定时时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;<span class="comment">//设置私有数据</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> TIMER_OPEN:</span><br><span class="line">			add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_CLOSE:</span><br><span class="line">			del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_SET:</span><br><span class="line">			test_dev-&gt;counter = arg;</span><br><span class="line">			timer_test.expires = jiffies_64 + msecs_to_jiffies(test_dev-&gt;counter);<span class="comment">//设置定时时间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.open = cdev_test_open,</span><br><span class="line">	.release = cdev_test_release,</span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> 	dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">	&#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="封装驱动提供的API函数"><a href="#封装驱动提供的API函数" class="headerlink" title="封装驱动提供的API函数"></a>封装驱动提供的API函数</h1><p>作为驱动工程师的我们当然可以理解每一行代码所要完成的功能，而一般情况下，应用都是由专业的应用工程师来进行编写的，上述代码编写方式很不利于应用工程师的理解和程序的移植，所以对于应用程序 API 的封装是一件必然的事情。</p>
<p>编译成库文件，<strong>每个功能函数一个.c文件</strong>，每个编译成一个库文件</p>
<h1 id="优化驱动稳定性和效率"><a href="#优化驱动稳定性和效率" class="headerlink" title="优化驱动稳定性和效率"></a>优化驱动稳定性和效率</h1><h2 id="检测ioctl命令"><a href="#检测ioctl命令" class="headerlink" title="检测ioctl命令"></a>检测ioctl命令</h2><p>ioctl 的 cmd 命令是由合成宏合成得到的，也有相应的分解宏得到各个参数，四个分解宏如下所示：</p>
<ul>
<li>分解 cmd 命令，得到命令的类型：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IOC_TYPE(cmd)</span><br></pre></td></tr></table></figure>

<ul>
<li>分解 cmd 命令，得到数据（args）的传输方向：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IOC_DIR(cmd)</span><br></pre></td></tr></table></figure>

<ul>
<li>分解 cmd 命令，得到命令的序号：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IOC_NR(cmd)</span><br></pre></td></tr></table></figure>

<ul>
<li>分解 cmd 命令，得到数据（args）的大小：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IOC_SIZE(cmd)</span><br></pre></td></tr></table></figure>

<p>可以在驱动中通过上述分解宏对传入的 ioctl 命令类型等参数进行判断，从而得到判断传入的参数是否正确，以此优化驱动的稳定性。</p>
<h2 id="检测传递地址是否合理"><a href="#检测传递地址是否合理" class="headerlink" title="检测传递地址是否合理"></a>检测传递地址是否合理</h2><h3 id="access-ok"><a href="#access-ok" class="headerlink" title="access_ok()"></a>access_ok()</h3><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数原型</strong></td>
<td><strong>int access_ok(const void __user *addr, unsigned long size);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/uaccess.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 addr</strong></td>
<td>用户空间的指针变量，指向要检查的内存块起始地址</td>
</tr>
<tr>
<td><strong>参数 size</strong></td>
<td>要检查的内存块大小（字节数）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>检查指定的用户空间内存块是否可访问（读&#x2F;写），用于保护内核访问用户空间数据安全</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功：<strong>1</strong>（可访问）失败：<strong>0</strong>（不可访问）</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line"><span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分支预测优化"><a href="#分支预测优化" class="headerlink" title="分支预测优化"></a>分支预测优化</h2><p>现在的 CPU 都有 ICache 和流水线机制。即运行当前指令时，ICache 会预读取后面的指令，从而提升效率。但是如果条件分支的结果是跳转到了其他指令，那预取下一条指令就浪费时间了。</p>
<h3 id="likely和unlikely宏"><a href="#likely和unlikely宏" class="headerlink" title="likely和unlikely宏"></a>likely和unlikely宏</h3><p>而我们要用到的 <strong>likely 和 unlikely 宏</strong>，会让编译器总是将大概率执行的代码放在靠前的位置，从而提高驱动的效率。</p>
<p>likely 和 unlikely 宏定义在内核源码include&#x2F;linux&#x2F;compiler.h文件中，具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<p>__builtin_expect 的作用是告知编译器预期表达式 exp 等于 c 的可能性更大，编译器可以根据该因素更好的对代码进行优化，所以 likely 与 unlikely 的作用就是表达性 x 为真的可能性更大（likely）和更小（unlikely）。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unlikely(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>))&#123;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h1><h2 id="调试打印"><a href="#调试打印" class="headerlink" title="调试打印"></a>调试打印</h2><h3 id="dump-stack"><a href="#dump-stack" class="headerlink" title="dump_stack()"></a>dump_stack()</h3><p><code>dump_stack()</code> 的作用是：</p>
<blockquote>
<p><strong>打印当前 CPU 的调用堆栈（call trace）到内核日志中。</strong></p>
</blockquote>
<p>在内核代码中调用它，相当于执行用户态中的 <code>backtrace()</code> 或者 C 库的 <code>printf(&quot;%pS&quot;, __builtin_return_address())</code> 之类的功能。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	dump_stack();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WARN-ON-condition"><a href="#WARN-ON-condition" class="headerlink" title="WARN_ON(condition)"></a>WARN_ON(condition)</h3><p>WARN_ON (condition)函数作用: <strong>在括号中的条件成立时，内核会抛出栈回溯，打印函数的调用关系</strong>。</p>
<p>通常用于内核抛出一个警告，暗示某种不太合理的事情发生了。</p>
<p><strong>WARN_ON 实际上也是调用 dump_stack，只是多了参数 condition 判断条件是否成立</strong>，例如 WARN_ON (1)则条件判断成功，函数会成功执行。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	WARN_ON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BUG-和-BUG-ON-condition"><a href="#BUG-和-BUG-ON-condition" class="headerlink" title="BUG() 和 BUG_ON (condition)"></a>BUG() 和 BUG_ON (condition)</h3><p>内核中有许多地方调用类似 BUG_ON()的语句，它非常像一个内核运行时的断言，意味着本来不该执行到 BUG_ON()这条语句，<strong>一旦 BUG_ON()执行内核就会立刻抛出 oops</strong>(只有Linux出现致命错误时会抛出oops)，导致栈的回溯和错误信息的打印。</p>
<p>大部分体系结构把 BUG()和 BUG_ON()定义成某种非法操作，这样自然会产生需要的 oops。应用层可以看到产生了段错误。</p>
<p>参数 condition 判断条件是否成立，例如 BUG_ON (1)则条件判断成功，函数会成功执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	BUGON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="panic-fmt…"><a href="#panic-fmt…" class="headerlink" title="panic (fmt…)"></a>panic (fmt…)</h3><p>panic (fmt…)函数: <strong>输出打印会造成系统死机并将函数的调用关系以及寄存器值就都打印出来</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	panic(<span class="string">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/2511133/">https://even629.com/posts/2511133/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><div class="post-share"><div class="social-share" data-image="/images/linux_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center liquidGlass-wrapper" id="my-custom-card-author"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status">🐟<span>认真摸鱼中</span></div></div></div><div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" target="_blank" title="github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" target="_blank" title="email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com/519280138" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="rss"><i class="fas fa-rss" style="color: #000000;"></i></a></div></div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"> <div class="newYear-slider"> <div class="swiper-wrapper"> <div class="swiper-slide" style="background-image:url(/img/happy_new_year1.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year2.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year3.webp)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year4.gif)"></div> </div> </div> <div id="newYear-main"> <div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div> </div></div><div class="sticky_layout"><div class="card-widget liquidGlass-wrapper" id="card-toc"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-text">IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">IO操作过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">IO模型的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO"><span class="toc-text">同步阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-text">同步非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">IO多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="toc-text">信号驱动IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="toc-text">异步IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9EIO"><span class="toc-text">等待队列实现阻塞IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-text">初始化等待队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E9%A1%B9API"><span class="toc-text">等待队列项API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E7%AD%89%E5%BE%85API"><span class="toc-text">睡眠等待API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%A4%E9%86%92API"><span class="toc-text">唤醒API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%AE%BF%E9%97%AE"><span class="toc-text">非阻塞式访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">IO多路复用的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%BA%94%E7%94%A8%E5%B1%82poll"><span class="toc-text">Linux应用层poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-operations-poll"><span class="toc-text">file_operations.poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">驱动中的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#poll-wait"><span class="toc-text">poll_wait()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO-1"><span class="toc-text">信号驱动IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">驱动实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO-1"><span class="toc-text">异步IO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">Linux内核定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DEFINE-TIMER"><span class="toc-text">DEFINE_TIMER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add-timer"><span class="toc-text">add_timer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#del-timer"><span class="toc-text">del_timer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mod-timer"><span class="toc-text">mod_timer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-jiffies"><span class="toc-text">全局变量 jiffies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jiffies-%E4%B8%8E%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-text">jiffies 与时间单位转换函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E6%89%93%E5%8D%B0"><span class="toc-text">Linux内核打印</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dmesg"><span class="toc-text">dmesg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmsg%E6%96%87%E4%BB%B6"><span class="toc-text">kmsg文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E6%89%93%E5%8D%B0%E7%AD%89%E7%BA%A7"><span class="toc-text">调整内核打印等级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#llseek%E5%AE%9A%E4%BD%8D%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-text">llseek定位设备驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82lseek"><span class="toc-text">应用层lseek()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#file-operation-llseek"><span class="toc-text">file_operation.llseek</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ioctl%E8%AE%BE%E5%A4%87%E6%93%8D%E4%BD%9C"><span class="toc-text">ioctl设备操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82ioctl"><span class="toc-text">应用层ioctl()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#file-operations-ioctl"><span class="toc-text">file_operations.ioctl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E9%A9%B1%E5%8A%A8%E6%8F%90%E4%BE%9B%E7%9A%84API%E5%87%BD%E6%95%B0"><span class="toc-text">封装驱动提供的API函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%A9%B1%E5%8A%A8%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E6%95%88%E7%8E%87"><span class="toc-text">优化驱动稳定性和效率</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8Bioctl%E5%91%BD%E4%BB%A4"><span class="toc-text">检测ioctl命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%BC%A0%E9%80%92%E5%9C%B0%E5%9D%80%E6%98%AF%E5%90%A6%E5%90%88%E7%90%86"><span class="toc-text">检测传递地址是否合理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#access-ok"><span class="toc-text">access_ok()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E4%BC%98%E5%8C%96"><span class="toc-text">分支预测优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#likely%E5%92%8Cunlikely%E5%AE%8F"><span class="toc-text">likely和unlikely宏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95"><span class="toc-text">驱动调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%89%93%E5%8D%B0"><span class="toc-text">调试打印</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dump-stack"><span class="toc-text">dump_stack()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WARN-ON-condition"><span class="toc-text">WARN_ON(condition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BUG-%E5%92%8C-BUG-ON-condition"><span class="toc-text">BUG() 和 BUG_ON (condition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#panic-fmt%E2%80%A6"><span class="toc-text">panic (fmt…)</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post liquidGlass-wrapper"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2601261/" title="io_uring"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="io_uring"/></a><div class="content"><a class="title" href="/posts/2601261/" title="io_uring">io_uring</a><time datetime="2026-01-26T07:25:13.000Z" title="发表于 2026-01-26 15:25:13">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601133/" title="Linux 网络设备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux 网络设备"/></a><div class="content"><a class="title" href="/posts/2601133/" title="Linux 网络设备">Linux 网络设备</a><time datetime="2026-01-13T14:00:00.000Z" title="发表于 2026-01-13 22:00:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601143/" title="Linux ADC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux ADC"/></a><div class="content"><a class="title" href="/posts/2601143/" title="Linux ADC">Linux ADC</a><time datetime="2026-01-13T13:18:00.000Z" title="发表于 2026-01-13 21:18:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601093/" title="Linux CAN"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux CAN"/></a><div class="content"><a class="title" href="/posts/2601093/" title="Linux CAN">Linux CAN</a><time datetime="2026-01-09T07:56:00.000Z" title="发表于 2026-01-09 15:56:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601063/" title="Linux Watchdog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux Watchdog"/></a><div class="content"><a class="title" href="/posts/2601063/" title="Linux Watchdog">Linux Watchdog</a><time datetime="2026-01-06T05:09:00.000Z" title="发表于 2026-01-06 13:09:00">2026-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601053/" title="Linux RTC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux RTC"/></a><div class="content"><a class="title" href="/posts/2601053/" title="Linux RTC">Linux RTC</a><time datetime="2026-01-05T14:09:00.000Z" title="发表于 2026-01-05 22:09:00">2026-01-05</time></div></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a target="_blank" rel="noopener" href="https://github.com/even629" title="github"><i class="fab fa-github"></i></a><a href="/img/qq.jpg" title="qq"><i class="fa-brands fa-qq"></i></a><a href="mailto:zhaohang731005515@proton.me" title="email"><i class="fas fa-envelope"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/519280138" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a href="/atom.xml" title="rss"><i class="fas fa-rss"></i></a></div><div class="copyright">&copy;2024 - 2026 By even629</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Frame-Hexo-blue.svg" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Theme-Butterfly.svg" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Source-Github.svg" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Copyright-BY--NC--SA.4.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"> </span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.stopSakura();"><i class="fa-solid fa-feather"></i><span data-zh="樱花特效" data-en="toggle sakura"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '8c73b5a083582e4306d7345716c06f9f'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.js"></script><script src="/js/sakura.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/solarlunar.js"></script><script src="/js/newYear.js"></script><script src="/js/pop-up-window.js"></script><script data-pjax src="/js/nav.js"></script><script data-pjax src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><svg style="display: none">
<filter
  id="glass-distortion"
  x="0%"
  y="0%"
  width="100%"
  height="100%"
  filterUnits="objectBoundingBox"
>
  <feTurbulence
    type="fractalNoise"
    baseFrequency="0.01 0.01"
    numOctaves="1"
    seed="5"
    result="turbulence"
  />
  <!-- Seeds: 14, 17,  -->

  <feComponentTransfer in="turbulence" result="mapped">
    <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
    <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
    <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
  </feComponentTransfer>

  <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />

  <feSpecularLighting
    in="softMap"
    surfaceScale="5"
    specularConstant="1"
    specularExponent="100"
    lighting-color="white"
    result="specLight"
  >
    <fePointLight x="-200" y="-200" z="300" />
  </feSpecularLighting>

  <feComposite
    in="specLight"
    operator="arithmetic"
    k1="0"
    k2="1"
    k3="1"
    k4="0"
    result="litImage"
  />

  <feDisplacementMap
    in="SourceGraphic"
    in2="softMap"
    scale="150"
    xChannelSelector="R"
    yChannelSelector="G"
  />
  </filter>
</svg>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr class="custom-hr"/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4847823_upluhme7cv.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><!-- hexo injector body_end end --></body></html>