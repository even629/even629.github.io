<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++ language">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://even629.com/posts/43000/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="C++ language">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/cpp.png">
<meta property="article:published_time" content="2025-10-03T12:12:13.000Z">
<meta property="article:modified_time" content="2025-10-19T08:18:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/cpp.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/43000/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: even629","link":"链接: ","source":"来源: 常想一二，不思八九","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.gif', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/music.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/programming.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avatar.gif" alt="Logo"><span class="site-name">常想一二，不思八九</span></a><a class="nav-page-title" href="/"><span class="site-name">C++</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T12:12:13.000Z" title="发表于 2025-10-03 20:12:13">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T08:18:13.000Z" title="更新于 2025-10-19 16:18:13">2025-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/programming/">programming</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/43000/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-03</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-12</p>
</div></div><div class='timeline-item-content'><p>add next_permutation 生成序列的全排列</p>
</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-19</p>
</div></div><div class='timeline-item-content'><p>add string</p>
</div></div></div>
<hr>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="amp-与-amp-amp-，左值与右值"><a href="#amp-与-amp-amp-，左值与右值" class="headerlink" title="&amp; 与 &amp;&amp;，左值与右值"></a>&amp; 与 &amp;&amp;，左值与右值</h2><ul>
<li><p><strong>左值 (Lvalue)</strong></p>
<ul>
<li><p>有名字，可取地址。</p>
</li>
<li><p>可以出现在赋值符号左边。</p>
</li>
<li><p>例子：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int <span class="variable language_">x</span> = <span class="number">5</span>; <span class="comment">// x 是左值</span></span><br><span class="line"><span class="variable language_">x</span> = <span class="number">10</span>;    <span class="comment">// 可以赋值</span></span><br><span class="line">int* p = &amp;<span class="variable language_">x</span>; <span class="comment">// 可以取地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>右值 (Rvalue)</strong></p>
<ul>
<li><p>临时对象或字面量，没有名字，不能取地址。</p>
</li>
<li><p>通常出现在赋值符号右边。</p>
</li>
<li><p>例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> y = x + <span class="number">2</span>; <span class="comment">// x+2 是右值</span></span><br><span class="line"><span class="built_in">int</span> z = <span class="number">42</span>;    <span class="comment">// 42 是右值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：右值可以绑定到 <strong>右值引用 (<code>&amp;&amp;</code>)</strong>。</p>
</blockquote>
</li>
<li><p>引用类型</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>引用</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T&amp;</code></td>
<td>左值引用（只能绑定到左值）</td>
</tr>
<tr>
<td><code>T&amp;&amp;</code></td>
<td>右值引用（只能绑定到右值）</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;lref = a;   <span class="comment">// 左值引用，a 是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rref = <span class="number">5</span>;  <span class="comment">// 右值引用，5 是右值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>左值引用可以修改左值：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lref = <span class="number">10</span>; <span class="comment">// a = 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>右值引用常用于移动语义：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1); <span class="comment">// 右值引用允许移动资源</span></span><br></pre></td></tr></table></figure>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="引用头文件"><a href="#引用头文件" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a><strong>构造</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空 vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小，默认初始化为0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 5个元素，每个为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小和初始值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>, <span class="number">42</span>)</span></span>;  <span class="comment">// 5个元素，每个为42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 initializer_list</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制另一个 vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组构造</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v6</span><span class="params">(arr, arr + <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h3><ul>
<li><p>返回的是元素的引用</p>
</li>
<li><p>带边界检查的访问如果越界会抛出 <strong>std::out_of_range</strong> 异常</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引访问（不做边界检查）</span></span><br><span class="line"><span class="type">int</span> a = v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 at() 访问（带边界检查）</span></span><br><span class="line"><span class="type">int</span> b = v.<span class="built_in">at</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素</span></span><br><span class="line"><span class="type">int</span> first = v.<span class="built_in">front</span>();</span><br><span class="line"><span class="type">int</span> last = v.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a><strong>修改元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="number">2</span>] = <span class="number">10</span>;     <span class="comment">// 修改索引2的值</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">// 在末尾插入元素</span></span><br><span class="line">v.<span class="built_in">pop_back</span>();   <span class="comment">// 删除末尾元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">20</span>); <span class="comment">// 在索引1位置插入20</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>);      <span class="comment">// 删除索引2的元素</span></span><br><span class="line">v.<span class="built_in">clear</span>();                   <span class="comment">// 清空所有元素</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a><strong>遍历元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    std::cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围 for（C++11+）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : v)</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v[i]</code></td>
<td>O(1)</td>
<td>随机访问</td>
</tr>
<tr>
<td><code>v.at(i)</code></td>
<td>O(1)</td>
<td>随机访问，带边界检查</td>
</tr>
<tr>
<td><code>push_back(x)</code></td>
<td>O(1) 摊销</td>
<td>平均常数时间，偶尔扩容 O(n)</td>
</tr>
<tr>
<td><code>pop_back()</code></td>
<td>O(1)</td>
<td>删除末尾元素</td>
</tr>
<tr>
<td><code>insert(v.begin() + i, x)</code></td>
<td>O(n)</td>
<td>插入到中间，平均移动 n/2 个元素</td>
</tr>
<tr>
<td><code>erase(v.begin() + i)</code></td>
<td>O(n)</td>
<td>删除中间元素，平均移动 n/2 个元素</td>
</tr>
<tr>
<td><code>front()</code> / <code>back()</code></td>
<td>O(1)</td>
<td>访问首尾元素</td>
</tr>
<tr>
<td><code>size()</code> / <code>empty()</code></td>
<td>O(1)</td>
<td>获取大小/是否为空</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>O(n)</td>
<td>清空元素（析构调用）</td>
</tr>
<tr>
<td><code>sort(v.begin(), v.end())</code></td>
<td>O(n log n)</td>
<td>使用 STL 算法排序</td>
</tr>
</tbody>
</table>
</div>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="引用头文件-1"><a href="#引用头文件-1" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br></pre></td></tr></table></figure>
<h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a><strong>构造</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空队列</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q2</span><span class="params">(q1)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="访问队头队尾"><a href="#访问队头队尾" class="headerlink" title="访问队头队尾"></a>访问队头队尾</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队首/队尾元素</span></span><br><span class="line"><span class="type">int</span> front_val = q.<span class="built_in">front</span>();</span><br><span class="line"><span class="type">int</span> back_val  = q.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>
<h3 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队（尾部插入）</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队（头部删除）</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push()</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>front()</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>back()</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul>
<li><p>优先队列，内部默认使用大顶堆</p>
</li>
<li><p>出队时总是弹出队列中 <strong>最大的元素</strong>（默认大顶堆）。</p>
</li>
<li><p>可以自定义比较器实现 <strong>小顶堆</strong>。</p>
</li>
</ul>
<p>priority_queue 没有迭代器，只能利用 pop()和 top()实现遍历</p>
<h3 id="引用头文件-2"><a href="#引用头文件-2" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br></pre></td></tr></table></figure>
<h3 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h3><blockquote>
<p>priority_queue 的泛型参数中第一个是存储元素的类型，第二个是存储元素的容器，默认为 vector，第三个是元素的比较器</p>
</blockquote>
<div class="tip warning faa-horizontal animated"><p>注意 priority_queue 除了能弹出堆顶外，不支持直接修改或删除堆中某一个元素</p>
</div>
<ul>
<li>如果想要删除 priority_queue 中某一个元素，建议考虑能不能配合 unordered_map 实现<strong>懒删除</strong>(只有无效元素到堆顶了才删除，否则只做标记)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br><span class="line"><span class="comment">// 默认构造的全部参数</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,std::less&lt;<span class="type">int</span>&gt;&gt;;</span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq2</span><span class="params">(pq1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从容器构造</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq3</span><span class="params">(v.begin(), v.end())</span></span>; <span class="comment">// 默认最大堆</span></span><br></pre></td></tr></table></figure>
<h3 id="访问堆顶"><a href="#访问堆顶" class="headerlink" title="访问堆顶"></a><strong>访问堆顶</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"><span class="type">int</span> top_val = pq.<span class="built_in">top</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h3 id="弹出堆顶元素"><a href="#弹出堆顶元素" class="headerlink" title="弹出堆顶元素"></a><strong>弹出堆顶元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pq.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure>
<h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><p><strong>方法 1：使用 std::greater<int>实现小顶堆</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; min_pq;</span><br></pre></td></tr></table></figure>
<p><strong>方法 2：自定义结构体/lambda</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125; <span class="comment">// 最小值优先</span></span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; pq_custom;</span><br></pre></td></tr></table></figure>
<p><strong>方法 3：如果是结构体，直接重载&lt;运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt; 运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt; other.age;  <span class="comment">// 默认大顶堆，年龄大的优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Person&gt; pq;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>平均复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push</code></td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>pop</code></td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>top</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>size</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>empty</code></td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>栈，先进后出</p>
<p><code>stack</code> 没有迭代器，不能用 <code>for</code> 循环直接遍历。遍历只能通过 <code>top()</code> + <code>pop()</code>。</p>
<h3 id="引用头文件-3"><a href="#引用头文件-3" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::stack;</span><br></pre></td></tr></table></figure>
<h3 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s1;          <span class="comment">// 空栈</span></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;      <span class="comment">// 拷贝构造</span></span><br></pre></td></tr></table></figure>
<h3 id="入栈-出栈"><a href="#入栈-出栈" class="headerlink" title="入栈/出栈"></a>入栈/出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="comment">// 入栈（push 到栈顶）</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈（pop 栈顶元素）</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure>
<h3 id="访问栈顶元素"><a href="#访问栈顶元素" class="headerlink" title="访问栈顶元素"></a>访问栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看栈顶元素</span></span><br><span class="line"><span class="type">int</span> top_val = s.<span class="built_in">top</span>();  <span class="comment">// 栈顶元素</span></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>平均复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>pop</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>top</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>size</code></td>
<td>O(1)</td>
</tr>
<tr>
<td><code>empty</code></td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map, unordered_map"></a>map, unordered_map</h2><ul>
<li><p>map</p>
<ul>
<li><p><code>map</code> 是 <strong>有序关联容器</strong>，底层通常用 <strong>红黑树</strong> 实现。</p>
</li>
<li><p>每个元素是 <strong>key-value</strong> 对，key 唯一，自动按 key 排序。</p>
</li>
<li><p>适合需要 <strong>按键顺序访问</strong> 的场景。</p>
</li>
</ul>
</li>
<li><p>unordered_map</p>
<ul>
<li><code>unordered_map</code> 是 <strong>哈希表</strong>，无序存储 key-value。</li>
<li>查找、插入和删除平均时间复杂度为 O(1)。</li>
<li>适合快速查找，<strong>不关心顺序</strong>。</li>
</ul>
<blockquote>
<p>GCC 的 <code>unordered_map</code> 自 C++11 起有一个优化：</p>
<ul>
<li><strong>当某个桶内链表长度超过一定阈值（通常是 8）时，链表会转为红黑树</strong>。</li>
<li>这样可以防止 <strong>最坏情况哈希冲突导致的 O(n) 复杂度</strong>，把查找复杂度从 O(n) 降到 O(log n)。</li>
<li>也就是：<strong>链表 → 红黑树</strong>，而不是整个哈希表退化为红黑树。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="引用头文件-4"><a href="#引用头文件-4" class="headerlink" title="引用头文件"></a>引用头文件</h3><p><strong>map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br></pre></td></tr></table></figure>
<p><strong>unordered_map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unordered_map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br></pre></td></tr></table></figure>
<h3 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h3><p><strong>map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空 map</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, string&gt; <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m3 = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>unordered_map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空表</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">unordered_map&lt;<span class="type">int</span>, string&gt; <span class="title">um2</span><span class="params">(um1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um3 = &#123;&#123;<span class="number">1</span>,<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>,<span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p><strong>map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line">string s = m[<span class="number">1</span>];       <span class="comment">// key 必须存在，否则会创建默认值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>unordered_map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line">string s = m[<span class="number">1</span>];       <span class="comment">// key 必须存在，否则会创建默认值</span></span><br></pre></td></tr></table></figure>
<h3 id="插入，修改和元素"><a href="#插入，修改和元素" class="headerlink" title="插入，修改和元素"></a>插入，修改和元素</h3><p><strong>map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;     <span class="comment">// 插入或修改</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>unorder_map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">um.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">um[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">um[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p><strong>map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> hasKey = um.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 0 或 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="number">2</span>);   <span class="comment">// 返回迭代器，找不到返回 m.end()</span></span><br><span class="line"><span class="type">bool</span> hasKey = um.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 0 或 1</span></span><br></pre></td></tr></table></figure>
<p><strong>unordered_map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = um.<span class="built_in">find</span>(<span class="number">2</span>);  <span class="comment">// 返回迭代器，找不到返回 um.end()</span></span><br><span class="line"><span class="type">bool</span> hasKey = um.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 0 或 1</span></span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><strong>map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">1</span>);            <span class="comment">// 根据 key 删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());    <span class="comment">// 根据迭代器删除</span></span><br></pre></td></tr></table></figure>
<p><strong>unordered_map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">um.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">m.<span class="built_in">erase</span>(um.<span class="built_in">begin</span>());    <span class="comment">// 根据迭代器删除</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><strong>map</strong></p>
<blockquote>
<p>map 是按 key 有序遍历的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, value] : m) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>unordered_map</strong></p>
<blockquote>
<p>注意：<code>unordered_map</code> 是无序的，遍历顺序不固定。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, value] : um) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义比较器（仅-map-支持）"><a href="#自定义比较器（仅-map-支持）" class="headerlink" title="自定义比较器（仅 map 支持）"></a>自定义比较器（仅 map 支持）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string, std::greater&lt;<span class="type">int</span>&gt;&gt; m; <span class="comment">// 按 key 降序</span></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>map</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>平均复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入/删除</td>
<td>O(log n)</td>
</tr>
<tr>
<td>查找</td>
<td>O(log n)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(n)</td>
</tr>
<tr>
<td>访问元素</td>
<td>O(log n)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>unordered_map</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>平均复杂度</th>
<th>最坏复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>查找</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>删除</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="set-unordered-set"><a href="#set-unordered-set" class="headerlink" title="set, unordered_set"></a>set, unordered_set</h2><ul>
<li><strong>set</strong><ul>
<li><code>set</code> 是 <strong>有序集合</strong>，底层通常用 <strong>红黑树</strong> 实现。</li>
<li>存储 <strong>唯一元素</strong>，自动按元素大小排序。</li>
<li>适合需要 <strong>有序访问和快速查找唯一元素</strong> 的场景。</li>
</ul>
</li>
<li><strong>unordered_set</strong><ul>
<li><code>unordered_set</code> 是 <strong>哈希表集合</strong>，无序存储唯一元素。</li>
<li>平均查找、插入和删除复杂度为 O(1)。</li>
<li>适合快速查找，不关心顺序。<blockquote>
<p>GCC 的 <code>unordered_set</code> 同样支持 <strong>链表长度超过阈值时桶内树化</strong>，避免最坏情况 O(n)。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="引用头文件-5"><a href="#引用头文件-5" class="headerlink" title="引用头文件"></a>引用头文件</h3><p><strong>set</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::set;</span><br></pre></td></tr></table></figure>
<p><strong>unordered_set</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::unordered_set;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h3><p><strong>set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;               <span class="comment">// 空集合</span></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;           <span class="comment">// 拷贝构造</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;   <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure>
<p><strong>unordered_set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us1;              <span class="comment">// 空集合</span></span><br><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">us2</span><span class="params">(us1)</span></span>;         <span class="comment">// 拷贝构造</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="插入和修改"><a href="#插入和修改" class="headerlink" title="插入和修改"></a>插入和修改</h3><p><strong>set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 插入元素</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 重复元素不会插入</span></span><br></pre></td></tr></table></figure>
<p><strong>unordered_set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 重复元素不会插入</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h3><p><strong>set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">2</span>);   <span class="comment">// 返回迭代器，找不到返回 s.end()</span></span><br><span class="line"><span class="type">bool</span> exists = s.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 返回 0 或 1</span></span><br></pre></td></tr></table></figure>
<p><strong>unordered_set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = us.<span class="built_in">find</span>(<span class="number">2</span>);   <span class="comment">// 返回迭代器，找不到返回 us.end()</span></span><br><span class="line"><span class="type">bool</span> exists = us.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 返回 0 或 1</span></span><br></pre></td></tr></table></figure>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p><strong>set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(<span class="number">2</span>);        <span class="comment">// 根据元素值删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()); <span class="comment">// 根据迭代器删除</span></span><br></pre></td></tr></table></figure>
<p><strong>unordered_set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">us.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">us.<span class="built_in">erase</span>(us.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p><strong>set</strong></p>
<blockquote>
<p>按元素升序遍历</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : s) &#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>unordered_set</strong></p>
<blockquote>
<p>遍历顺序不固定</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : us) &#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义比较器（仅-set-支持）"><a href="#自定义比较器（仅-set-支持）" class="headerlink" title="自定义比较器（仅 set 支持）"></a>自定义比较器（仅 set 支持）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; s; <span class="comment">// 按降序排列</span></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>set</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>平均复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入/删除</td>
<td>O(log n)</td>
</tr>
<tr>
<td>查找</td>
<td>O(log n)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>unordered_set</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>平均复杂度</th>
<th>最坏复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>查找</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>删除</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>绝大多数现代 C++ 编译器（如 GCC/Clang/MSVC）中的 <code>std::string</code> 实现类似：</p>
<ul>
<li>内部使用<strong>动态数组</strong>存储字符</li>
<li>结尾自动维护 <code>&#39;\0&#39;</code>（兼容 C-string）</li>
<li>每个 <code>string</code> 还维护 <code>size</code> 和 <code>capacity</code></li>
</ul>
<p>字符串扩容通常按照<strong>指数方式增长（如 2 倍）</strong>，以减少反复申请内存。</p>
<p><strong>小字符串优化（SSO - Small String Optimization）</strong></p>
<p>SSO 是 <code>std::string</code> 的核心性能优化技术。</p>
<p> <strong>目的：减少堆内存分配，加快小字符串操作</strong></p>
<p>当字符串长度较短（通常 ≤ 15 字符），很多实现会<strong>直接存放在对象内部的小缓冲区</strong>中，而不分配堆内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 很可能不分配堆内存（SSO）</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>避免频繁 <code>new/delete</code></li>
<li>提高性能</li>
<li>减少内存碎片</li>
</ul>
<h3 id="引用头文件-6"><a href="#引用头文件-6" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>
<h3 id="构造-6"><a href="#构造-6" class="headerlink" title="构造"></a>构造</h3><div class="table-container">
<table>
<thead>
<tr>
<th>构造方式</th>
<th>原型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认构造</td>
<td><code>string()</code></td>
<td>创建空字符串</td>
<td><code>string s1; // &quot;&quot;</code></td>
</tr>
<tr>
<td>拷贝构造</td>
<td><code>string(const string&amp; str)</code></td>
<td>拷贝已有字符串</td>
<td><code>string s2(s1);</code></td>
</tr>
<tr>
<td>移动构造</td>
<td><code>string(string&amp;&amp; str)</code></td>
<td>移动已有字符串（C++11 后）</td>
<td><code>string s3(std::move(s1));</code></td>
</tr>
<tr>
<td>C 字符串</td>
<td><code>string(const char* s)</code></td>
<td>从以 <code>\0</code> 结尾的 C 字符串构造</td>
<td><code>string s4(&quot;hello&quot;);</code></td>
</tr>
<tr>
<td>C 字符串 + 长度</td>
<td><code>string(const char* s, size_t n)</code></td>
<td>只取前 n 个字符</td>
<td><code>string s5(&quot;hello world&quot;, 5); // &quot;hello&quot;</code></td>
</tr>
<tr>
<td>重复字符</td>
<td><code>string(size_t n, char c)</code></td>
<td>创建 n 个相同字符组成的字符串</td>
<td><code>string s6(4, &#39;a&#39;); // &quot;aaaa&quot;</code></td>
</tr>
<tr>
<td>区间构造</td>
<td><code>template&lt;class InputIt&gt; string(InputIt first, InputIt last)</code></td>
<td>用迭代器区间初始化</td>
<td><code>vector&lt;char&gt; v&#123;&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;; string s7(v.begin(), v.end());</code></td>
</tr>
<tr>
<td>initializer_list</td>
<td><code>string(std::initializer_list&lt;char&gt; ilist)</code></td>
<td>用列表初始化字符（C++11）</td>
<td><code>string s8(&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;); // &quot;abc&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>默认构造</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">cout &lt;&lt; s<span class="number">1.</span><span class="built_in">size</span>(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>易错点</strong>：空字符串的 <code>c_str()</code> 仍然有效，返回 <code>&quot;&quot;</code>。</li>
</ul>
<hr>
<p><strong>拷贝构造</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">cout &lt;&lt; s3; <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>性能建议</strong>：大字符串尽量使用 <code>const string&amp;</code> 传参，避免拷贝</li>
</ul>
<hr>
<p><strong>移动构造（C++11+）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(std::move(s2))</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特性</strong>：<code>s2</code> 的内容被移动，原对象为空</li>
<li><strong>优势</strong>：避免拷贝内存，提高性能</li>
</ul>
<hr>
<p><strong>C 字符串构造</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">5</span>)</span></span>; <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用场景</strong>：从字面量或 C 风格数组初始化</li>
<li><strong>性能建议</strong>：如果长度已知，用第二个参数避免多余扫描</li>
<li><strong>易错点</strong>：传入非 <code>\0</code> 结尾字符串时，必须指明长度</li>
</ul>
<hr>
<p><strong>重复字符构造</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>; <span class="comment">// &quot;xxxxx&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>区间构造（迭代器）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">char</span>&gt; v&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(v.begin(), v.end())</span></span>; <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>initializer_list 构造（C++11+）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s9</span><span class="params">(&#123;<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;)</span></span>; <span class="comment">// &quot;xyz&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="访问与赋值操作"><a href="#访问与赋值操作" class="headerlink" title="访问与赋值操作"></a>访问与赋值操作</h3><p><strong>下标访问 <code>operator[]</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c = s[<span class="number">1</span>]; <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>;    <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>说明</strong>：</p>
<ul>
<li><p>不进行边界检查，访问越界会导致未定义行为。</p>
</li>
<li><p>移动构造或扩容后，指向原字符的指针或引用可能失效。</p>
</li>
</ul>
</li>
</ul>
<p><strong>安全访问</strong> <code>at()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = s.<span class="built_in">at</span>(<span class="number">1</span>); <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">s.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="string">&#x27;H&#x27;</span>;    <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>说明</strong>：<ul>
<li>会进行范围检查，越界时抛 <code>std::out_of_range</code> 异常。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>访问首尾字符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> f = s.<span class="built_in">front</span>(); <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line"><span class="type">char</span> b = s.<span class="built_in">back</span>();  <span class="comment">// &#x27;o&#x27;</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">front</span>() = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">s.<span class="built_in">back</span>()  = <span class="string">&#x27;!&#x27;</span>;    <span class="comment">// &quot;hello!&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>说明</strong>：<ul>
<li>当字符串为空时调用 <code>front()</code> 或 <code>back()</code> 是未定义行为。</li>
</ul>
</li>
<li><strong>易错点</strong>：<ul>
<li>空字符串访问会触发 UB（未定义行为）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>字符串赋值 assign()</strong></p>
<p><code>assign()</code> 是 <code>std::string</code> 赋值的多用途函数，重载丰富：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string&amp; assign(const string&amp; str)</code></td>
<td>拷贝另一个字符串</td>
<td><code>s.assign(s2);</code></td>
</tr>
<tr>
<td><code>string&amp; assign(string&amp;&amp; str)</code></td>
<td>移动另一个字符串</td>
<td><code>s.assign(std::move(s2));</code></td>
</tr>
<tr>
<td><code>string&amp; assign(const string&amp; str, size_t pos, size_t count)</code></td>
<td>从 str 的子串赋值</td>
<td><code>s.assign(s2, 1, 3); // 取 s2[1..3]</code></td>
</tr>
<tr>
<td><code>string&amp; assign(const char* s)</code></td>
<td>C 字符串赋值</td>
<td><code>s.assign(&quot;world&quot;);</code></td>
</tr>
<tr>
<td><code>string&amp; assign(const char* s, size_t n)</code></td>
<td>前 n 个字符赋值</td>
<td><code>s.assign(&quot;hello world&quot;, 5); // &quot;hello&quot;</code></td>
</tr>
<tr>
<td><code>string&amp; assign(size_t n, char c)</code></td>
<td>重复字符赋值</td>
<td><code>s.assign(4, &#39;x&#39;); // &quot;xxxx&quot;</code></td>
</tr>
<tr>
<td><code>template&lt;class InputIt&gt; string&amp; assign(InputIt first, InputIt last)</code></td>
<td>区间赋值</td>
<td><code>vector&lt;char&gt; v&#123;&#39;a&#39;,&#39;b&#39;&#125;; s.assign(v.begin(), v.end());</code></td>
</tr>
<tr>
<td><code>string&amp; assign(initializer_list&lt;char&gt; il)</code></td>
<td>列表赋值（C++11+）</td>
<td><code>s.assign(&#123;&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;); // &quot;xyz&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><p><strong>追加append</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string&amp; append(const string&amp; str)</code></td>
<td>追加整个字符串</td>
<td><code>s.append(s2);</code></td>
</tr>
<tr>
<td><code>string&amp; append(const string&amp; str, size_t pos, size_t count)</code></td>
<td>追加 str 的子串</td>
<td><code>s.append(s2, 1, 3);</code></td>
</tr>
<tr>
<td><code>string&amp; append(const char* s)</code></td>
<td>追加 C 字符串</td>
<td><code>s.append(&quot;world&quot;);</code></td>
</tr>
<tr>
<td><code>string&amp; append(const char* s, size_t n)</code></td>
<td>追加 C 字符串前 n 个字符</td>
<td><code>s.append(&quot;hello world&quot;, 5); // &quot;hello&quot;</code></td>
</tr>
<tr>
<td><code>string&amp; append(size_t n, char c)</code></td>
<td>追加 n 个相同字符</td>
<td><code>s.append(3, &#39;!&#39;); // &quot;!!!&quot;</code></td>
</tr>
<tr>
<td><code>template&lt;class InputIt&gt; string&amp; append(InputIt first, InputIt last)</code></td>
<td>追加区间</td>
<td><code>vector&lt;char&gt; v&#123;&#39;a&#39;,&#39;b&#39;&#125;; s.append(v.begin(), v.end());</code></td>
</tr>
<tr>
<td><code>string&amp; push_back(char c)</code></td>
<td>追加单个字符</td>
<td><code>s.push_back(&#39;x&#39;);</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>性能建议</strong></p>
<p>优化拼接操作 —— 默认拼接效率低</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.<span class="title function_ invoke__">reserve</span>(<span class="number">1000</span>);  <span class="comment">// 建议预留空间减少扩容</span></span><br></pre></td></tr></table></figure>
<ul>
<li>频繁修改时建议用 <code>std::ostringstream</code> 或 <code>std::string_view</code></li>
</ul>
<p><strong>插入insert</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string&amp; insert(size_t pos, const string&amp; str)</code></td>
<td>在 pos 插入整个字符串</td>
<td><code>s.insert(2, s2);</code></td>
</tr>
<tr>
<td><code>string&amp; insert(size_t pos, const string&amp; str, size_t subpos, size_t count)</code></td>
<td>插入 str 子串</td>
<td><code>s.insert(1, s2, 0, 2);</code></td>
</tr>
<tr>
<td><code>string&amp; insert(size_t pos, const char* s)</code></td>
<td>插入 C 字符串</td>
<td><code>s.insert(0, &quot;Hi&quot;);</code></td>
</tr>
<tr>
<td><code>string&amp; insert(size_t pos, const char* s, size_t n)</code></td>
<td>插入 C 字符串前 n 个字符</td>
<td><code>s.insert(0, &quot;Hello World&quot;, 5);</code></td>
</tr>
<tr>
<td><code>string&amp; insert(size_t pos, size_t n, char c)</code></td>
<td>插入 n 个相同字符</td>
<td><code>s.insert(3, 4, &#39;*&#39;);</code></td>
</tr>
<tr>
<td><code>iterator insert(const_iterator p, char c)</code></td>
<td>插入单字符</td>
<td><code>s.insert(s.begin()+1, &#39;x&#39;);</code></td>
</tr>
<tr>
<td><code>template&lt;class InputIt&gt; void insert(const_iterator p, InputIt first, InputIt last)</code></td>
<td>插入区间</td>
<td><code>s.insert(s.begin(), v.begin(), v.end());</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>删除erase</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string&amp; erase(size_t pos = 0, size_t count = npos)</code></td>
<td>从 pos 开始删除 count 个字符</td>
<td><code>s.erase(2,3);</code></td>
</tr>
<tr>
<td><code>iterator erase(const_iterator p)</code></td>
<td>删除迭代器指向字符</td>
<td><code>s.erase(s.begin()+1);</code></td>
</tr>
<tr>
<td><code>iterator erase(const_iterator first, const_iterator last)</code></td>
<td>删除区间</td>
<td><code>s.erase(s.begin(), s.begin()+3);</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>替换replace</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string&amp; replace(size_t pos, size_t count, const string&amp; str)</code></td>
<td>替换 pos 起 count 个字符为 str</td>
<td><code>s.replace(0,2,&quot;Hi&quot;);</code></td>
</tr>
<tr>
<td><code>string&amp; replace(size_t pos, size_t count, const string&amp; str, size_t subpos, size_t subcount)</code></td>
<td>替换为 str 子串</td>
<td><code>s.replace(0,2,s2,1,2);</code></td>
</tr>
<tr>
<td><code>string&amp; replace(size_t pos, size_t count, const char* s)</code></td>
<td>替换为 C 字符串</td>
<td><code>s.replace(0,2,&quot;OK&quot;);</code></td>
</tr>
<tr>
<td><code>string&amp; replace(size_t pos, size_t count, const char* s, size_t n)</code></td>
<td>替换为 C 字符串前 n 个字符</td>
<td><code>s.replace(0,2,&quot;Hello World&quot;,5);</code></td>
</tr>
<tr>
<td><code>string&amp; replace(size_t pos, size_t count, size_t n, char c)</code></td>
<td>替换为 n 个相同字符</td>
<td><code>s.replace(0,2,3,&#39;*&#39;);</code></td>
</tr>
<tr>
<td><code>iterator replace(const_iterator first, const_iterator last, InputIt first2, InputIt last2)</code></td>
<td>替换迭代器区间</td>
<td><code>s.replace(s.begin(), s.begin()+2,v.begin(),v.end());</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数原型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size_t find(const string&amp; str, size_t pos=0) const</code></td>
<td>从 pos 开始查找子串首次出现位置</td>
<td><code>s.find(&quot;world&quot;); // 6</code></td>
</tr>
<tr>
<td><code>size_t find(const char* s, size_t pos=0) const</code></td>
<td>从 pos 开始查找 C 字符串</td>
<td><code>s.find(&quot;lo&quot;); // 3</code></td>
</tr>
<tr>
<td><code>size_t find(const char* s, size_t pos, size_t n) const</code></td>
<td>查找 C 字符串前 n 个字符</td>
<td><code>s.find(&quot;hello world&quot;, 0, 5); // 查找 &quot;hello&quot;</code></td>
</tr>
<tr>
<td><code>size_t find(char c, size_t pos=0) const</code></td>
<td>查找字符首次出现位置</td>
<td><code>s.find(&#39;o&#39;); // 4</code></td>
</tr>
<tr>
<td><code>size_t rfind(const string&amp; str, size_t pos=npos) const</code></td>
<td>从右向左查找子串</td>
<td><code>s.rfind(&quot;lo&quot;);</code></td>
</tr>
<tr>
<td><code>size_t rfind(char c, size_t pos=npos) const</code></td>
<td>从右向左查找字符</td>
<td><code>s.rfind(&#39;o&#39;);</code></td>
</tr>
<tr>
<td><code>size_t find_first_of(const string&amp; chars, size_t pos=0) const</code></td>
<td>查找任意指定字符集合首次出现</td>
<td><code>s.find_first_of(&quot;aeiou&quot;);</code></td>
</tr>
<tr>
<td><code>size_t find_last_of(const string&amp; chars, size_t pos=npos) const</code></td>
<td>查找任意字符集合最后一次出现</td>
<td><code>s.find_last_of(&quot;aeiou&quot;);</code></td>
</tr>
<tr>
<td><code>size_t find_first_not_of(const string&amp; chars, size_t pos=0) const</code></td>
<td>查找第一个不属于字符集合的位置</td>
<td><code>s.find_first_not_of(&quot;aeiou&quot;);</code></td>
</tr>
<tr>
<td><code>size_t find_last_not_of(const string&amp; chars, size_t pos=npos) const</code></td>
<td>查找最后一个不属于字符集合的位置</td>
<td><code>s.find_last_not_of(&quot;aeiou&quot;);</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数原型</th>
<th>说明</th>
<th>示例</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int compare(const string&amp; str) const</code></td>
<td>比较整个字符串与 str</td>
<td><code>s.compare(&quot;hello&quot;);</code></td>
<td>O(min(n, m))</td>
</tr>
<tr>
<td><code>int compare(size_t pos, size_t count, const string&amp; str) const</code></td>
<td>比较子串 <code>[pos, pos+count)</code> 与 str</td>
<td><code>s.compare(0,2,&quot;he&quot;);</code></td>
<td>O(count)</td>
</tr>
<tr>
<td><code>int compare(size_t pos, size_t count, const string&amp; str, size_t subpos, size_t subcount) const</code></td>
<td>比较 s 子串与 str 子串</td>
<td><code>s.compare(0,2,s2,1,2);</code></td>
<td>O(subcount)</td>
</tr>
<tr>
<td><code>int compare(const char* s) const</code></td>
<td>与 C 字符串比较</td>
<td><code>s.compare(&quot;hello&quot;);</code></td>
<td>O(n)</td>
</tr>
<tr>
<td><code>int compare(size_t pos, size_t count, const char* s) const</code></td>
<td>比较子串与 C 字符串</td>
<td><code>s.compare(0,2,&quot;he&quot;);</code></td>
<td>O(count)</td>
</tr>
<tr>
<td><code>int compare(size_t pos, size_t count, const char* s, size_t n) const</code></td>
<td>比较子串与 C 字符串前 n 个字符</td>
<td><code>s.compare(0,2,&quot;hello&quot;,2); // &quot;he&quot;</code></td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</div>
<p>返回值：</p>
<ul>
<li><p>返回值小于0     s&lt;str, </p>
</li>
<li><p>返回值等于0     s==str,</p>
</li>
<li><p>返回值大于0     s&gt;str</p>
</li>
</ul>
<p>也可以用运算符比较</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>示例</th>
<th>返回类型</th>
<th>比较方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>判断是否相等</td>
<td><code>s == &quot;hello&quot;</code></td>
<td><code>bool</code></td>
<td>大小写敏感 &amp; 按字符逐一比较</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>判断是否不相等</td>
<td><code>s != t</code></td>
<td><code>bool</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>按字典序小于</td>
<td><code>&quot;abc&quot; &lt; &quot;abd&quot;</code></td>
<td><code>bool</code></td>
<td>按 ASCII/Unicode 比较</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>&quot;abc&quot; &lt;= &quot;abc&quot;</code></td>
<td><code>bool</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>按字典序大于</td>
<td><code>&quot;dog&quot; &gt; &quot;cat&quot;</code></td>
<td><code>bool</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>&quot;hi&quot; &gt;= &quot;ha&quot;</code></td>
<td><code>bool</code></td>
<td>同上</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数原型</th>
<th>说明</th>
<th>示例</th>
<th>返回值</th>
<th>注意</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string substr(size_t pos = 0, size_t count = npos) const</code></td>
<td>从位置 <code>pos</code> 开始，截取长度为 <code>count</code> 的子串</td>
<td><code>s.substr(2, 4)</code></td>
<td>返回新 string</td>
<td><code>pos &gt; size()</code> 抛异常</td>
<td>会产生新字符串拷贝，注意性能</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符检查与大小写转换"><a href="#字符检查与大小写转换" class="headerlink" title="字符检查与大小写转换"></a>字符检查与大小写转换</h3><p>需要引入c标准库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>常用字符判断函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isalnum(c)</code></td>
<td>是否为字母或数字</td>
<td><code>&#39;A&#39;,&#39;z&#39;,&#39;3&#39;</code></td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>是否为字母</td>
<td><code>&#39;A&#39;,&#39;b&#39;</code></td>
</tr>
<tr>
<td><code>isdigit(c)</code></td>
<td>是否为数字</td>
<td><code>&#39;0&#39;~&#39;9&#39;</code></td>
</tr>
<tr>
<td><code>islower(c)</code></td>
<td>是否为小写字母</td>
<td><code>&#39;a&#39;</code></td>
</tr>
<tr>
<td><code>isupper(c)</code></td>
<td>是否为大写字母</td>
<td><code>&#39;Z&#39;</code></td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>是否为空白字符（空格/换行/制表）</td>
<td><code>&#39; &#39;,&#39;\n&#39;,&#39;\t&#39;</code></td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>是否为标点符号</td>
<td><code>&#39;,&#39; &#39;.&#39; &#39;!&#39;</code></td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>是否为十六进制数字</td>
<td><code>&#39;0&#39;~&#39;9&#39;,&#39;a&#39;~&#39;f&#39;</code></td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>是否为可打印字符</td>
<td>普通字符</td>
</tr>
<tr>
<td><code>iscntrl(c)</code></td>
<td>是否控制字符</td>
<td><code>&#39;\n&#39; &#39;\r&#39;</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>大小写转换函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tolower(c)</code></td>
<td>字符转小写</td>
<td><code>tolower(&#39;A&#39;) → &#39;a&#39;</code></td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>字符转大写</td>
<td><code>toupper(&#39;b&#39;) → &#39;B&#39;</code></td>
</tr>
</tbody>
</table>
</div>
<p>这两个函数<strong>只作用于单个字符</strong>，要处理字符串需要配合 <code>transform()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;HeLLo&quot;</span>;</span><br><span class="line">	std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::tolower);  <span class="comment">// s = &quot;hello&quot;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>::tolower</code> 里的 <code>::</code> 指的是<strong>全局作用域运算符</strong>，表示用 <strong>全局的 tolower 函数</strong>，避免与某些类成员同名造成歧义。</p>
</blockquote>
<h3 id="字符串与数字的转换"><a href="#字符串与数字的转换" class="headerlink" title="字符串与数字的转换"></a>字符串与数字的转换</h3><p><strong>字符串 → 整型转换函数表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>函数原型</th>
<th>参数说明</th>
<th>返回值说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stoi</code></td>
<td><code>int stoi(const string&amp; str, size_t* pos = 0, int base = 10);</code></td>
<td><code>str</code>: 输入字符串 <code>pos</code>: 返回成功转换的字符数 <code>base</code>: 进制（2~36）</td>
<td>转换后的 <code>int</code></td>
<td><code>stoi(&quot;123&quot;) → 123</code> <code>stoi(&quot;1A&quot;, nullptr, 16) → 26</code></td>
</tr>
<tr>
<td><code>stol</code></td>
<td><code>long stol(const string&amp; str, size_t* pos = 0, int base = 10);</code></td>
<td>同上</td>
<td>转换为 <code>long</code></td>
<td><code>stol(&quot;99999&quot;) → 99999L</code></td>
</tr>
<tr>
<td><code>stoll</code></td>
<td><code>long long stoll(const string&amp; str, size_t* pos = 0, int base = 10);</code></td>
<td>同上</td>
<td>转换为 <code>long long</code></td>
<td><code>stoll(&quot;1234567890123&quot;)</code></td>
</tr>
<tr>
<td><code>stoi</code> (C字符串)</td>
<td><code>int stoi(const char* str, size_t* pos = 0, int base = 10);</code></td>
<td><code>str</code>: C风格字符串</td>
<td>转换为 <code>int</code></td>
<td><code>stoi(&quot;42&quot;) → 42</code></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>字符串 → 浮点型转换函数表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>函数原型</th>
<th>参数说明</th>
<th>返回值说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stof</code></td>
<td><code>float stof(const string&amp; str, size_t* pos = 0);</code></td>
<td><code>str</code>: 字符串 <code>pos</code>: 返回解析字符长度</td>
<td>转为 <code>float</code></td>
<td><code>stof(&quot;3.14&quot;) → 3.14f</code></td>
</tr>
<tr>
<td><code>stod</code></td>
<td><code>double stod(const string&amp; str, size_t* pos = 0);</code></td>
<td>同上</td>
<td>转为 <code>double</code></td>
<td><code>stod(&quot;2.71828&quot;)</code></td>
</tr>
<tr>
<td><code>stold</code></td>
<td><code>long double stold(const string&amp; str, size_t* pos = 0);</code></td>
<td>同上</td>
<td>转为 <code>long double</code></td>
<td><code>stold(&quot;1.6180339887&quot;)</code></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>数字 → 字符串转换 (<code>to_string</code>)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>函数原型</th>
<th>参数说明</th>
<th>返回值说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>to_string</code></td>
<td><code>string to_string(int value);</code></td>
<td><code>value</code>: 数字</td>
<td>返回转换后的字符串</td>
<td><code>to_string(42) → &quot;42&quot;</code></td>
</tr>
<tr>
<td><code>to_string</code></td>
<td><code>string to_string(double value);</code></td>
<td>同上</td>
<td>浮点转字符串</td>
<td><code>to_string(3.14) → &quot;3.140000&quot;</code></td>
</tr>
<tr>
<td><code>to_string</code></td>
<td><code>string to_string(long long value);</code></td>
<td>同上</td>
<td>支持长整型</td>
<td><code>to_string(1234567890123)</code></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>返回值与异常总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>情况</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入不是数字</td>
<td>抛出 <code>std::invalid_argument</code></td>
</tr>
<tr>
<td>数字超出范围</td>
<td>抛出 <code>std::out_of_range</code></td>
</tr>
<tr>
<td>自动去除前导空格</td>
<td>✅ 支持 <code>&quot;  123&quot;</code></td>
</tr>
<tr>
<td>支持符号</td>
<td>✅ <code>&quot;-42&quot;</code> <code>&quot; +88&quot;</code></td>
</tr>
<tr>
<td>支持部分解析</td>
<td>✅ <code>&quot;123abc&quot;</code> → 123</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串与流"><a href="#字符串与流" class="headerlink" title="字符串与流"></a>字符串与流</h3><p><strong>引入头文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"><span class="keyword">using</span> std::istringstream;</span><br><span class="line"><span class="keyword">using</span> std::ostringstream;</span><br></pre></td></tr></table></figure>
<p>三个类</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stringstream</code></td>
<td>读写都支持</td>
<td>通用</td>
</tr>
<tr>
<td><code>istringstream</code></td>
<td>只读输入流</td>
<td>解析字符串</td>
</tr>
<tr>
<td><code>ostringstream</code></td>
<td>只写输出流</td>
<td>构造字符串</td>
</tr>
</tbody>
</table>
</div>
<p>常用操作：</p>
<h3 id="常用函数总览表"><a href="#常用函数总览表" class="headerlink" title="常用函数总览表"></a>常用函数总览表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>str()</code></td>
<td>获取/设置内部字符串</td>
<td><code>ss.str(&quot;123 456&quot;)</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空流状态</td>
<td>必须在重复使用时调用</td>
</tr>
<tr>
<td><code>operator&gt;&gt;</code></td>
<td>提取数据（按空白分割）</td>
<td><code>ss &gt;&gt; x;</code></td>
</tr>
<tr>
<td><code>operator&lt;&lt;</code></td>
<td>插入数据</td>
<td><code>ss &lt;&lt; 42;</code></td>
</tr>
<tr>
<td><code>getline()</code></td>
<td>按行读取</td>
<td><code>getline(ss, s)</code></td>
</tr>
<tr>
<td><code>good()</code> <code>fail()</code></td>
<td>检查流状态</td>
<td>判断解析是否成功</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意重复使用时必须调用clear</p>
</blockquote>
<p>举例：</p>
<p>分割字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;apple banana orange&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>用途</th>
<th>方法</th>
<th>示例</th>
<th>说明</th>
<th>易错点</th>
</tr>
</thead>
<tbody>
<tr>
<td>空白分词</td>
<td><code>ss &gt;&gt; word</code></td>
<td><code>ss &gt;&gt; w1 &gt;&gt; w2</code></td>
<td>按空格、换行、制表符切分</td>
<td>遇到逗号等非空白不会分割</td>
</tr>
<tr>
<td>自定义分隔符</td>
<td><code>getline(ss, word, &#39;,&#39;)</code></td>
<td><code>getline(ss, word, &#39;,&#39;);</code></td>
<td>按 <code>,</code> 切分</td>
<td>必须用 <code>getline</code>，<code>&gt;&gt;</code> 无法自定义分隔符</td>
</tr>
<tr>
<td>解析数字</td>
<td><code>ss &gt;&gt; num</code></td>
<td><code>int x; ss &gt;&gt; x;</code></td>
<td>字符串数字 → int/double</td>
<td>非数字会使流失败，需检查 <code>ss.fail()</code></td>
</tr>
<tr>
<td>拼接字符串</td>
<td><code>oss &lt;&lt; val</code></td>
<td><code>oss &lt;&lt; &quot;ID=&quot; &lt;&lt; 5;</code></td>
<td>高效构造动态字符串</td>
<td>输出结束后 <code>oss.str()</code> 才能获取完整内容</td>
</tr>
</tbody>
</table>
</div>
<h2 id="multiset-multimap"><a href="#multiset-multimap" class="headerlink" title="multiset/multimap"></a>multiset/multimap</h2><p><strong>multiset<T></strong></p>
<ul>
<li>元素 <strong>可重复</strong>，自动按 key 排序</li>
<li>底层通常使用 <strong>红黑树</strong></li>
<li>不支持通过下标访问，只能用迭代器</li>
<li>适合需要 <strong>快速查找和按顺序遍历重复元素</strong></li>
</ul>
<p><strong>multimap<K,V></strong></p>
<ul>
<li>key <strong>可重复</strong>，按 key 排序</li>
<li>底层通常使用 <strong>红黑树</strong></li>
<li>可以通过 <code>equal_range</code> 查找某个 key 的所有元素</li>
</ul>
<h3 id="引用头文件-7"><a href="#引用头文件-7" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::multiset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::multimap;</span><br></pre></td></tr></table></figure>
<h3 id="构造-7"><a href="#构造-7" class="headerlink" title="构造"></a><strong>构造</strong></h3><p><strong>multiset</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>&gt; ms;            <span class="comment">// 空 multiset</span></span><br><span class="line"><span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">ms2</span><span class="params">(ms)</span></span>;        <span class="comment">// 拷贝构造</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; ms3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure>
<p><strong>multimap</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>,string&gt; mm;            <span class="comment">// 空 multimap</span></span><br><span class="line"><span class="function">multimap&lt;<span class="type">int</span>,string&gt; <span class="title">mm2</span><span class="params">(mm)</span></span>;       <span class="comment">// 拷贝构造</span></span><br><span class="line">multimap&lt;<span class="type">int</span>,string&gt; mm3 = &#123;&#123;<span class="number">1</span>,<span class="string">&quot;a&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;b&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;; <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a><strong>插入元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 可以重复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line">mm.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="string">&quot;b&quot;</span>&#125;);</span><br><span class="line">mm.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="string">&quot;c&quot;</span>&#125;); <span class="comment">// key 可以重复</span></span><br></pre></td></tr></table></figure>
<h3 id="查找元素-2"><a href="#查找元素-2" class="headerlink" title="查找元素"></a><strong>查找元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="keyword">auto</span> it = ms.<span class="built_in">find</span>(<span class="number">2</span>);       <span class="comment">// 返回第一个 2 的迭代器</span></span><br><span class="line"><span class="type">size_t</span> cnt = ms.<span class="built_in">count</span>(<span class="number">2</span>);   <span class="comment">// 2 出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line"><span class="keyword">auto</span> range = mm.<span class="built_in">equal_range</span>(<span class="number">2</span>); <span class="comment">// 返回 key=2 的元素区间 [first, second)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除元素-2"><a href="#删除元素-2" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line">ms.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">// 删除所有值为 2 的元素</span></span><br><span class="line"><span class="keyword">auto</span> it = ms.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">ms.<span class="built_in">erase</span>(it);         <span class="comment">// 删除单个迭代器指向的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line">mm.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">// 删除所有 key=2 的元素</span></span><br><span class="line"><span class="keyword">auto</span> it2 = mm.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">mm.<span class="built_in">erase</span>(it2);        <span class="comment">// 删除单个迭代器指向的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a><strong>遍历</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : ms) &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key,value] : mm) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>multiset / multimap</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>O(log n)</td>
</tr>
<tr>
<td>查找</td>
<td>O(log n)</td>
</tr>
<tr>
<td>删除</td>
<td>O(log n)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><h3 id="引用头文件-8"><a href="#引用头文件-8" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br></pre></td></tr></table></figure>
<h3 id="构造-8"><a href="#构造-8" class="headerlink" title="构造"></a><strong>构造</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt; tp =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tp2 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;hi&quot;</span>); <span class="comment">// 自动推断类型</span></span><br></pre></td></tr></table></figure>
<h3 id="访问元素-2"><a href="#访问元素-2" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h3><ul>
<li>不能像 pair 一样访问，使用 std::get<0>(tuple)<blockquote>
<p>注意，这里 get<index>要求 index 是常量，编译期可知的常量，因此不能利用它来遍历</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tp);</span><br><span class="line"><span class="type">int</span> b = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tp);</span><br><span class="line"><span class="type">int</span> c = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tp);</span><br></pre></td></tr></table></figure>
<ul>
<li>c++17 起可以用结构化绑定,这样更优雅些</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [a, b, c] = tuple;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以使用 std::tie</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">std::<span class="built_in">tie</span>(a, b, std::ignore) = tp;</span><br></pre></td></tr></table></figure>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a><strong>修改</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a><strong>获取长度</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple 长度</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> n = std::tuple_size&lt;<span class="keyword">decltype</span>(tp)&gt;::value; <span class="comment">// n=3</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a><strong>遍历</strong></h3><p>不常用，使用结构化绑定 + fold 表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> tp = <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fold expression 遍历</span></span><br><span class="line">std::<span class="built_in">apply</span>([](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">    ((cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), ...);</span><br><span class="line">&#125;, tp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="引用头文件-9"><a href="#引用头文件-9" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><strong>基本用法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::greater&lt;int&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 按非递减顺序排序（升序）</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 按非递增顺序排序（降序）</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),std::greater&lt;<span class="type">int</span>&gt;)</span><br></pre></td></tr></table></figure>
<p><strong>自定义比较器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; people = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Carol&quot;</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄升序</span></span><br><span class="line">std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](<span class="type">const</span> Person &amp;a, <span class="type">const</span> Person &amp;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄降序</span></span><br><span class="line">std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](<span class="type">const</span> Person &amp;a, <span class="type">const</span> Person &amp;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.age &gt; b.age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="tip warning faa-horizontal animated"><p>std::sort 的标准要求是 稳定性不保证，如果需要稳定排序请使用 std::stable_sort</p>
</div>
<blockquote>
<ul>
<li><strong>稳定排序</strong>：如果两个元素相等，排序前它们的相对顺序在排序后保持不变。</li>
<li><strong>不稳定排序</strong>：相等元素的相对顺序在排序后可能被打乱。</li>
</ul>
</blockquote>
<h3 id="min-max"><a href="#min-max" class="headerlink" title="min, max"></a>min, max</h3><p><strong>基本用法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mi = std::<span class="built_in">min</span>(a, b); <span class="comment">// mi = 5</span></span><br><span class="line"><span class="type">int</span> ma = std::<span class="built_in">max</span>(a, b); <span class="comment">// ma = 10</span></span><br></pre></td></tr></table></figure>
<p><strong>自定义比较器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p1&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, p2&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回年龄小的</span></span><br><span class="line"><span class="keyword">auto</span> youngest = std::<span class="built_in">min</span>(p1, p2, [](<span class="type">const</span> Person &amp;x, <span class="type">const</span> Person &amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> oldest = std::<span class="built_in">max</span>(p1, p2, [](<span class="type">const</span> Person &amp;x, <span class="type">const</span> Person &amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>可接受 initializer_list (C++11 及以上)</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> x = std::min(&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;); // x = <span class="number">1</span></span><br><span class="line"><span class="attribute">int</span> y = std::max(&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;); // y = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="min-element-max-element"><a href="#min-element-max-element" class="headerlink" title="min_element/max_element"></a>min_element/max_element</h3><p>min_element 和 max_element 返回的迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// 查找最小/最大值</span></span><br><span class="line"><span class="type">int</span> mn = *std::<span class="built_in">min_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> mx = *std::<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>反转有序容器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">std::<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul>
<li>顺序查找区间内第一个等于给定值的元素，返回迭代器。找不到返回 <code>end</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">// it 指向 5</span></span><br><span class="line"><span class="keyword">if</span>(it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul>
<li>统计区间内某个值出现的次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt = std::<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">// cnt = 3</span></span><br></pre></td></tr></table></figure>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单参数变换（Unary Operation）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt first, InputIt last, OutputIt d_first, UnaryOperation unary_op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双参数变换（Binary Operation）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> BinaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt1 first1, InputIt1 last1, InputIt2 first2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   OutputIt d_first, BinaryOperation binary_op)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::tolower);</span><br></pre></td></tr></table></figure>
<p>使用的是 <strong>单参数版本</strong>（Unary Operation），意思是：</p>
<ul>
<li>输入区间：<code>[s.begin(), s.end())</code></li>
<li>输出区间起始：<code>s.begin()</code>（原地修改字符串）</li>
<li>对每个字符应用操作：<code>::tolower</code></li>
</ul>
<blockquote>
<p> <code>::tolower</code> 里的 <code>::</code> 指的是<strong>全局作用域运算符</strong>，表示用 <strong>全局的 tolower 函数</strong>，避免与某些类成员同名造成歧义。</p>
</blockquote>
<p>也可以不使用 <code>tolower</code>，传你自己的处理逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), [](<span class="type">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> ? c - <span class="number">32</span> : c;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>双参数变换</strong></p>
<p>两个数组元素相加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(a.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// result[i] = a[i] + b[i]</span></span><br><span class="line">    <span class="built_in">transform</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">              [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : result) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：11 22 33 44</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><ul>
<li>对已排序序列执行二分查找，返回 <code>bool</code>，判断是否存在</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h3><ul>
<li><strong>返回迭代器</strong>，<strong>要求序列已排序</strong></li>
<li><code>lower_bound(begin,end,val)</code>：返回第一个 <strong>&gt;= val</strong> 的位置</li>
<li><code>upper_bound(begin,end,val)</code>：返回第一个 <strong>&gt; val</strong> 的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> lb = std::<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">// 指向第一个 2</span></span><br><span class="line"><span class="keyword">auto</span> ub = std::<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">// 指向 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> distance = std::<span class="built_in">distance</span>(std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), startTime),</span><br><span class="line">                         std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), endTime));</span><br></pre></td></tr></table></figure>
<h3 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h3><ul>
<li>返回 <code>[lower_bound, upper_bound)</code> 的迭代器对，区间包含所有等于给定值的元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> range = std::<span class="built_in">equal_range</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出所有 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="next-permutation-prev-permutation"><a href="#next-permutation-prev-permutation" class="headerlink" title="next_permutation/prev_permutation"></a>next_permutation/prev_permutation</h3><p>生成下一个字典序排列，可以用于<strong>生成一个序列的全排列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// v是字典序列最小</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也用于<strong>生成一个数组的所有长度为 m 的数字组合</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化标记数组</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">select</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">fill</span>(select.<span class="built_in">end</span>() - m, select.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// 后 m 个为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 select 生成组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (select[i]) std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 prev_permutation</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>; <span class="comment">// 组合长度</span></span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建选择标记数组</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">select</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">fill</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">begin</span>() + m, <span class="number">1</span>); <span class="comment">// 前 m 个选中</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 用 prev_permutation 生成所有组合</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; combo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (select[i]) combo.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(combo);</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">prev_permutation</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : c) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><ul>
<li><code>fill(begin,end,val)</code>：填充整个区间为指定值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">7</span>); <span class="comment">// v = &#123;7,7,7,7,7&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">select</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">fill</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">begin</span>() + m, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><ul>
<li><code>iota(begin,end,start)</code>：生成连续整数序列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">iota</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">10</span>); <span class="comment">// v = &#123;10,11,12,13,14&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="copy-swap-replace-remove-remove-if"><a href="#copy-swap-replace-remove-remove-if" class="headerlink" title="copy / swap / replace / remove / remove_if"></a><strong>copy / swap / replace / remove / remove_if</strong></h3><ul>
<li><code>copy(begin,end,out_it)</code>：拷贝区间到另一容器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dst</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dst.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>swap(a,b)</code> / <code>iter_swap(it1,it2)</code>：交换元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(a,b);</span><br><span class="line">std::<span class="built_in">iter_swap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>()<span class="number">+1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>replace(begin,end,old_val,new_val)</code>：替换区间内元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>remove(begin,end,val)</code> / <code>remove_if(begin,end,pred)</code>：逻辑移除（需要配合 <code>erase</code>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>), v.<span class="built_in">end</span>());</span><br><span class="line">v.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="set-operations（集合操作）"><a href="#set-operations（集合操作）" class="headerlink" title="set operations（集合操作）"></a>set operations（集合操作）</h3><ul>
<li>序列必须 <strong>已排序</strong></li>
<li><code>merge(a,b,out)</code>：合并两个已排序序列</li>
<li><code>set_union(a,b,out)</code>：并集</li>
<li><code>set_intersection(a,b,out)</code>：交集</li>
<li><code>set_difference(a,b,out)</code>：差集</li>
<li><code>unique(begin,end)</code>：去除相邻重复元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a = &#123;1,2,2,3&#125;;</span><br><span class="line">vector&lt;int&gt; b = &#123;2,3,4&#125;;</span><br><span class="line">vector&lt;int&gt; out;</span><br><span class="line"></span><br><span class="line">std::set_union(a.begin(),a.end(),b.begin(),b.end(),std::back_inserter(out));</span><br><span class="line">// out = &#123;1,2,2,3,4&#125;</span><br><span class="line"></span><br><span class="line">a.erase(std::unique(a.begin(),a.end()), a.end()); // 去重 a = &#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="accumulate-all-of-any-of-none-of-for-each"><a href="#accumulate-all-of-any-of-none-of-for-each" class="headerlink" title="accumulate / all_of / any_of / none_of / for_each"></a><strong>accumulate / all_of / any_of / none_of / for_each</strong></h3><ul>
<li><code>accumulate(begin,end,init)</code>：区间求和（或自定义操作）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// sum = 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>all_of(begin,end,pred)</code> / <code>any_of</code> / <code>none_of</code>：判断区间元素是否满足条件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> all_even = std::<span class="built_in">all_of</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;);</span><br><span class="line"><span class="type">bool</span> any_even = std::<span class="built_in">any_of</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>for_each(begin,end,f)</code>：区间遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;x)&#123; x++; &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>算法</th>
<th>功能</th>
<th>时间复杂度</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>sort</strong></td>
<td>排序（不稳定）</td>
<td><code>O(n log n)</code></td>
<td><code>std::sort(v.begin(), v.end());</code></td>
</tr>
<tr>
<td><strong>stable_sort</strong></td>
<td>稳定排序</td>
<td><code>O(n log² n)</code> 最坏，平均 <code>O(n log n)</code></td>
<td><code>std::stable_sort(v.begin(), v.end());</code></td>
</tr>
<tr>
<td><strong>min / max</strong></td>
<td>两数取最小/最大</td>
<td><code>O(1)</code></td>
<td><code>std::min(a,b); std::max(a,b);</code></td>
</tr>
<tr>
<td><strong>min_element / max_element</strong></td>
<td>区间最小/最大元素迭代器</td>
<td><code>O(n)</code></td>
<td><code>*std::min_element(v.begin(), v.end());</code></td>
</tr>
<tr>
<td><strong>reverse</strong></td>
<td>反转区间</td>
<td><code>O(n)</code></td>
<td><code>std::reverse(v.begin(), v.end());</code></td>
</tr>
<tr>
<td><strong>find</strong></td>
<td>顺序查找</td>
<td><code>O(n)</code></td>
<td><code>auto it = std::find(v.begin(),v.end(),5);</code></td>
</tr>
<tr>
<td><strong>count</strong></td>
<td>统计出现次数</td>
<td><code>O(n)</code></td>
<td><code>std::count(v.begin(),v.end(),2);</code></td>
</tr>
<tr>
<td><strong>binary_search</strong></td>
<td>是否存在（二分，需有序）</td>
<td><code>O(log n)</code></td>
<td><code>std::binary_search(v.begin(),v.end(),5);</code></td>
</tr>
<tr>
<td><strong>lower_bound</strong></td>
<td>第一个 <strong>&gt;= val</strong>（二分）</td>
<td><code>O(log n)</code></td>
<td><code>auto it=std::lower_bound(v.begin(),v.end(),2);</code></td>
</tr>
<tr>
<td><strong>upper_bound</strong></td>
<td>第一个 <strong>&gt; val</strong>（二分）</td>
<td><code>O(log n)</code></td>
<td><code>auto it=std::upper_bound(v.begin(),v.end(),2);</code></td>
</tr>
<tr>
<td><strong>equal_range</strong></td>
<td>返回等于 val 的区间</td>
<td><code>O(log n)</code></td>
<td><code>auto r=std::equal_range(v.begin(),v.end(),2);</code></td>
</tr>
<tr>
<td><strong>fill</strong></td>
<td>区间赋值</td>
<td><code>O(n)</code></td>
<td><code>std::fill(v.begin(), v.end(), 7);</code></td>
</tr>
<tr>
<td><strong>iota</strong></td>
<td>连续赋值（需 <code>&lt;numeric&gt;</code>）</td>
<td><code>O(n)</code></td>
<td><code>std::iota(v.begin(),v.end(),10);</code></td>
</tr>
<tr>
<td><strong>copy</strong></td>
<td>拷贝区间</td>
<td><code>O(n)</code></td>
<td><code>std::copy(src.begin(),src.end(),dst.begin());</code></td>
</tr>
<tr>
<td><strong>swap / iter_swap</strong></td>
<td>交换元素</td>
<td><code>O(1)</code></td>
<td><code>std::swap(a,b);</code></td>
</tr>
<tr>
<td><strong>replace</strong></td>
<td>替换指定值</td>
<td><code>O(n)</code></td>
<td><code>std::replace(v.begin(),v.end(),2,5);</code></td>
</tr>
<tr>
<td><strong>remove / remove_if</strong></td>
<td>逻辑删除（需 <code>erase</code>）</td>
<td><code>O(n)</code></td>
<td><code>v.erase(std::remove(v.begin(),v.end(),5),v.end());</code></td>
</tr>
<tr>
<td><strong>unique</strong></td>
<td>去除相邻重复（逻辑删除）</td>
<td><code>O(n)</code></td>
<td><code>v.erase(std::unique(v.begin(),v.end()),v.end());</code></td>
</tr>
<tr>
<td><strong>set_union</strong></td>
<td>并集（需有序）</td>
<td><code>O(n+m)</code></td>
<td><code>std::set_union(a.begin(),a.end(),b.begin(),b.end(),back_inserter(out));</code></td>
</tr>
<tr>
<td><strong>set_intersection</strong></td>
<td>交集（需有序）</td>
<td><code>O(n+m)</code></td>
<td><code>std::set_intersection(...);</code></td>
</tr>
<tr>
<td><strong>set_difference</strong></td>
<td>差集（需有序）</td>
<td><code>O(n+m)</code></td>
<td><code>std::set_difference(...);</code></td>
</tr>
<tr>
<td><strong>merge</strong></td>
<td>合并两个有序序列</td>
<td><code>O(n+m)</code></td>
<td><code>std::merge(a.begin(),a.end(),b.begin(),b.end(),out.begin());</code></td>
</tr>
<tr>
<td><strong>accumulate</strong></td>
<td>区间累加（需 <code>&lt;numeric&gt;</code>）</td>
<td><code>O(n)</code></td>
<td><code>int sum=std::accumulate(v.begin(),v.end(),0);</code></td>
</tr>
<tr>
<td><strong>all_of / any_of / none_of</strong></td>
<td>区间条件判断</td>
<td><code>O(n)</code></td>
<td><code>std::all_of(v.begin(),v.end(),[](int x)&#123;return x%2==0;&#125;);</code></td>
</tr>
<tr>
<td><strong>for_each</strong></td>
<td>遍历执行函数</td>
<td><code>O(n)</code></td>
<td><code>std::for_each(v.begin(),v.end(),[](int &amp;x)&#123;x++;&#125;);</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="utility"><a href="#utility" class="headerlink" title="utility"></a>utility</h2><h3 id="引用头文件-10"><a href="#引用头文件-10" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><h4 id="引用头文件-11"><a href="#引用头文件-11" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br></pre></td></tr></table></figure>
<h4 id="构造-9"><a href="#构造-9" class="headerlink" title="构造"></a><strong>构造</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 自动推断类型</span></span><br></pre></td></tr></table></figure>
<h4 id="访问元素-3"><a href="#访问元素-3" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = p.first;</span><br><span class="line"><span class="type">int</span> b = p.second;</span><br></pre></td></tr></table></figure>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>std::move 其实是将参数 t 转换为一个右值引用类型，不会拷贝内存，不会释放资源，不会调用构造函数和析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 std::vector<int> 为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; b = std::<span class="built_in">move</span>(a);</span><br></pre></td></tr></table></figure>
<p>这里：std::move(a) 把 a 变成右值引用。编译器会选择 vector 的移动构造函数，而不是拷贝构造。<br>移动构造函数做的事：</p>
<ul>
<li>把 a 的内部指针直接“偷走”，交给 b。</li>
<li>把 a 的指针设为空，避免析构时释放同一块内存。</li>
</ul>
<p>所以最后：b 持有 {1,2,3} 的数据。a 变成空的（size()==0，但仍然是合法对象）</p>
<p>总结：<br>nums1 = std::move(vec);</p>
<ul>
<li>旧内容自动释放（移动赋值内部完成）</li>
<li>新内容接管</li>
<li>vec 变空<br>不需要自己手动调用析构函数。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/43000/">https://even629.com/posts/43000/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/programming/">programming</a></div><div class="post-share"><div class="social-share" data-image="/images/cpp.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/11/" title="leetcode每日一题 P11 盛水最多的容器"><img class="cover" src="/images/leetcode_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">leetcode每日一题 P11 盛水最多的容器</div></div><div class="info-2"><div class="info-item-1">双指针</div></div></div></a><a class="pagination-related" href="/posts/407/" title="leetcode每日一题 P407 接雨水II"><img class="cover" src="/images/leetcode_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">leetcode每日一题 P407 接雨水II</div></div><div class="info-2"><div class="info-item-1">小顶堆，BFS</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/42882/" title="C"><img class="cover" src="/images/C_lang.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-07-19</div><div class="info-item-2">C</div></div><div class="info-2"><div class="info-item-1">C language</div></div></div></a><a class="pagination-related" href="/posts/43001/" title="数据结构"><img class="cover" src="/images/data_structure.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-20</div><div class="info-item-2">数据结构</div></div><div class="info-2"><div class="info-item-1">数据结构</div></div></div></a><a class="pagination-related" href="/posts/50010/" title="Golang"><img class="cover" src="/images/golang_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-14</div><div class="info-item-2">Golang</div></div><div class="info-2"><div class="info-item-1">golang笔记</div></div></div></a><a class="pagination-related" href="/posts/2510240/" title="rust std"><img class="cover" src="/images/rust_cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-24</div><div class="info-item-2">rust std</div></div><div class="info-2"><div class="info-item-1">rust笔记</div></div></div></a><a class="pagination-related" href="/posts/42871/" title="rust language basics"><img class="cover" src="/images/rust_cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-22</div><div class="info-item-2">rust language basics</div></div><div class="info-2"><div class="info-item-1">rust笔记</div></div></div></a><a class="pagination-related" href="/posts/2510270/" title="rustlings"><img class="cover" src="/images/rust_cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-27</div><div class="info-item-2">rustlings</div></div><div class="info-2"><div class="info-item-1">rustlings记录</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center" id="my-custom-card-author"><div class="avatar-img"><img src="/img/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/even629"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告：欢迎留言~</span></div><div class="announcement_content">--- ZH ❤️ YW ---</div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-%E4%B8%8E-amp-amp-%EF%BC%8C%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">&amp; 与 &amp;&amp;，左值与右值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">2.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">2.1.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.3.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.4.</span> <span class="toc-text">修改元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.5.</span> <span class="toc-text">遍历元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.6.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue"><span class="toc-number">2.2.</span> <span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E9%98%9F%E5%A4%B4%E9%98%9F%E5%B0%BE"><span class="toc-number">2.2.3.</span> <span class="toc-text">访问队头队尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">入队出队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">2.2.5.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-number">2.3.</span> <span class="toc-text">priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%A0%86%E9%A1%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">访问堆顶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.4.</span> <span class="toc-text">弹出堆顶元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">2.3.5.</span> <span class="toc-text">自定义比较器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">2.3.6.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack"><span class="toc-number">2.4.</span> <span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E6%A0%88-%E5%87%BA%E6%A0%88"><span class="toc-number">2.4.3.</span> <span class="toc-text">入栈&#x2F;出栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">2.4.4.</span> <span class="toc-text">访问栈顶元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">2.4.5.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-unordered-map"><span class="toc-number">2.5.</span> <span class="toc-text">map, unordered_map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%92%8C%E5%85%83%E7%B4%A0"><span class="toc-number">2.5.4.</span> <span class="toc-text">插入，修改和元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">2.5.5.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.5.6.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.7.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8%EF%BC%88%E4%BB%85-map-%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">2.5.8.</span> <span class="toc-text">自定义比较器（仅 map 支持）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">2.5.9.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-unordered-set"><span class="toc-number">2.6.</span> <span class="toc-text">set, unordered_set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E4%BF%AE%E6%94%B9"><span class="toc-number">2.6.3.</span> <span class="toc-text">插入和修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0-1"><span class="toc-number">2.6.4.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="toc-number">2.6.5.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-1"><span class="toc-number">2.6.6.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8%EF%BC%88%E4%BB%85-set-%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">2.6.7.</span> <span class="toc-text">自定义比较器（仅 set 支持）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-number">2.6.8.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">2.7.</span> <span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-6"><span class="toc-number">2.7.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-6"><span class="toc-number">2.7.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.3.</span> <span class="toc-text">访问与赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.4.</span> <span class="toc-text">修改操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.5.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">2.7.6.</span> <span class="toc-text">字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%B8%B2"><span class="toc-number">2.7.7.</span> <span class="toc-text">字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.8.</span> <span class="toc-text">字符检查与大小写转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.9.</span> <span class="toc-text">字符串与数字的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%B5%81"><span class="toc-number">2.7.10.</span> <span class="toc-text">字符串与流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E8%A7%88%E8%A1%A8"><span class="toc-number">2.7.11.</span> <span class="toc-text">常用函数总览表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiset-multimap"><span class="toc-number">2.8.</span> <span class="toc-text">multiset&#x2F;multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-7"><span class="toc-number">2.8.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-7"><span class="toc-number">2.8.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">2.8.3.</span> <span class="toc-text">插入元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0-2"><span class="toc-number">2.8.4.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-2"><span class="toc-number">2.8.5.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-2"><span class="toc-number">2.8.6.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-6"><span class="toc-number">2.8.7.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple"><span class="toc-number">2.9.</span> <span class="toc-text">tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-8"><span class="toc-number">2.9.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-8"><span class="toc-number">2.9.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-2"><span class="toc-number">2.9.3.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">2.9.4.</span> <span class="toc-text">修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6"><span class="toc-number">2.9.5.</span> <span class="toc-text">获取长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-3"><span class="toc-number">2.9.6.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#algorithm"><span class="toc-number">2.10.</span> <span class="toc-text">algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-9"><span class="toc-number">2.10.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">2.10.2.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-max"><span class="toc-number">2.10.3.</span> <span class="toc-text">min, max</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-element-max-element"><span class="toc-number">2.10.4.</span> <span class="toc-text">min_element&#x2F;max_element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-number">2.10.5.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-number">2.10.6.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count"><span class="toc-number">2.10.7.</span> <span class="toc-text">count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transform"><span class="toc-number">2.10.8.</span> <span class="toc-text">transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binary-search"><span class="toc-number">2.10.9.</span> <span class="toc-text">binary_search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lower-bound-upper-bound"><span class="toc-number">2.10.10.</span> <span class="toc-text">lower_bound&#x2F;upper_bound</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equal-range"><span class="toc-number">2.10.11.</span> <span class="toc-text">equal_range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-permutation-prev-permutation"><span class="toc-number">2.10.12.</span> <span class="toc-text">next_permutation&#x2F;prev_permutation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill"><span class="toc-number">2.10.13.</span> <span class="toc-text">fill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iota"><span class="toc-number">2.10.14.</span> <span class="toc-text">iota</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-swap-replace-remove-remove-if"><span class="toc-number">2.10.15.</span> <span class="toc-text">copy &#x2F; swap &#x2F; replace &#x2F; remove &#x2F; remove_if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-operations%EF%BC%88%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.10.16.</span> <span class="toc-text">set operations（集合操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accumulate-all-of-any-of-none-of-for-each"><span class="toc-number">2.10.17.</span> <span class="toc-text">accumulate &#x2F; all_of &#x2F; any_of &#x2F; none_of &#x2F; for_each</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-7"><span class="toc-number">2.10.18.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#utility"><span class="toc-number">2.11.</span> <span class="toc-text">utility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-10"><span class="toc-number">2.11.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pair"><span class="toc-number">2.11.2.</span> <span class="toc-text">pair</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6-11"><span class="toc-number">2.11.2.1.</span> <span class="toc-text">引用头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-9"><span class="toc-number">2.11.2.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-3"><span class="toc-number">2.11.2.3.</span> <span class="toc-text">访问元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-move"><span class="toc-number">2.11.3.</span> <span class="toc-text">std::move</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2510312/" title="ARM CHI"><img src="/images/arm-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM CHI"/></a><div class="content"><a class="title" href="/posts/2510312/" title="ARM CHI">ARM CHI</a><time datetime="2025-10-31T12:59:13.000Z" title="发表于 2025-10-31 20:59:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2510311/" title="ARM ACE"><img src="/images/arm-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM ACE"/></a><div class="content"><a class="title" href="/posts/2510311/" title="ARM ACE">ARM ACE</a><time datetime="2025-10-31T12:42:13.000Z" title="发表于 2025-10-31 20:42:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2510310/" title="ARM AXI"><img src="/images/arm-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM AXI"/></a><div class="content"><a class="title" href="/posts/2510310/" title="ARM AXI">ARM AXI</a><time datetime="2025-10-31T12:15:13.000Z" title="发表于 2025-10-31 20:15:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/230/" title="面试经典150题 P230 二叉搜索树中第 K 小的元素"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经典150题 P230 二叉搜索树中第 K 小的元素"/></a><div class="content"><a class="title" href="/posts/230/" title="面试经典150题 P230 二叉搜索树中第 K 小的元素">面试经典150题 P230 二叉搜索树中第 K 小的元素</a><time datetime="2025-10-31T07:00:00.000Z" title="发表于 2025-10-31 15:00:00">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/98/" title="面试经典150题 P98 验证二叉搜索树"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经典150题 P98 验证二叉搜索树"/></a><div class="content"><a class="title" href="/posts/98/" title="面试经典150题 P98 验证二叉搜索树">面试经典150题 P98 验证二叉搜索树</a><time datetime="2025-10-31T06:44:13.000Z" title="发表于 2025-10-31 14:44:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/98/" title="面试经典150题 P530 二叉搜索树的最小绝对差"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经典150题 P530 二叉搜索树的最小绝对差"/></a><div class="content"><a class="title" href="/posts/98/" title="面试经典150题 P530 二叉搜索树的最小绝对差">面试经典150题 P530 二叉搜索树的最小绝对差</a><time datetime="2025-10-31T06:16:13.000Z" title="发表于 2025-10-31 14:16:13">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a title="GitHub" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/even629"><i class="fab fa-regular fa-github"></i></a><a title="Mail" href="mailto:zhaohang731005515@proton.me" rel="external nofollow noreferrer"><i class="fas fa-regular fa-envelope"></i></a></div><div class="copyright">&copy;2014 - 2025 By even629</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();" rel="external nofollow noreferrer"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();" rel="external nofollow noreferrer"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '05de19c51a55da0c53dfa8445346b94c'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code      
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'src'
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}"></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/even629/even629.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/pop-up-window.js"></script><script defer src="/js/light.js"></script><script src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('category-bar');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><!-- hexo injector body_end end --></body></html>