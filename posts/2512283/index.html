<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux I2C | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux I2C">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux I2C">
<meta property="og:url" content="https://even629.com/posts/2512283/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="Linux I2C">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/linux_cover.webp">
<meta property="article:published_time" content="2025-12-28T11:55:13.000Z">
<meta property="article:modified_time" content="2025-12-28T11:55:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/linux_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/2512283/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux I2C',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.png', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom_card_author.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/newYear.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/beautify_label_h.css"><link rel="stylesheet" href="/css/equipment.css"><link rel="stylesheet" href="/css/liquid_glass.css"><link rel="stylesheet" href="/css/tag_plugin_plus.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="常想一二，不思八九" type="application/atom+xml">
</head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/linux_top_image.jpg);"><nav class="liquidGlass-wrapper" id="nav" style="--glass-border-radius: 2rem;"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box" style="display:flex;align-items:center;justify-content:center;width:100%"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" alt="Logo"></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 菜单项--><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><!-- 显示当前标题名称--><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">常想一二，不思八九</a></center></div></div><!-- 右侧功能区域（新增容器）--><div id="nav-right-container"><!-- 搜索按钮（移动到右侧）--><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><!-- 移动端汉堡菜单按钮--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux I2C</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-28T11:55:13.000Z" title="发表于 2025-12-28 19:55:13">2025-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-28T11:55:13.000Z" title="更新于 2025-12-28 19:55:13">2025-12-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">19.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2512283/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-28</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>

<hr>
<h1 id="I2C简介"><a href="#I2C简介" class="headerlink" title="I2C简介"></a>I2C简介</h1><p>荷兰著名电子公司飞利浦(Philips)公司发明了一种名为I2C(Inter-Integrated Circuit)的集成电路互连通信协议。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204417959.png" alt="I2C" loading="lazy"></p>
<p>在<strong>空闲状态下</strong>，<strong>SDA 和 SCL 一般被上拉电阻拉高，保持高电平状态</strong>，在需要进行数据传输的时候，通过 SCL 和 SDA 的高低电平来产生 I2C 总线所需要的信号进行数据传递。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>总线拓扑结构</strong></li>
</ul>
<p>I2C 总线采用主从式架构,由一个主设备(Master)和一个或多个从设备(Slave)组成。主设备负责发起数据传输,从设备则响应主设备的请求。</p>
<ul>
<li><strong>物理层接口</strong><br>I2C 总线使用两根线路进行通信:<ul>
<li><p>SCL(Serial Clock Line)时钟线,由主设备提供时钟信号。</p>
</li>
<li><p>SDA(Serial Data Line)数据线,用于双向传输数据。</p>
</li>
</ul>
</li>
</ul>
<p>这两根线通常需要上拉电阻来保持信号的高电平状态。</p>
<ul>
<li><strong>通信协议</strong></li>
</ul>
<p>I2C 采用<strong>同步串行通信</strong>方式, 主设备发起通信并提供时钟。主设备首先发送一个”启动”信号,然后发送从设备地址和数据传输方向(读或写)。从设备在收到自己的地址后,会发送应答信号,表示已准备好接收或发送数据。之后主设备和从设备就可以开始传输数据。通信结束时,主设<br>备发送”停止”信号。</p>
<ul>
<li><p><strong>时钟频率</strong><br>I2C 总线支持多种通信速率,常见的有:</p>
<ul>
<li><p>标准模式(Standard mode):100kbps</p>
</li>
<li><p>快速模式(Fast mode):400kbps</p>
</li>
<li><p>高速模式(High-speed mode):3.4Mbps</p>
</li>
</ul>
</li>
<li><p><strong>寻址机制</strong><br>I2C 使用 7 位地址空间,最多可寻址 127 个从设备。地址空间的前 7 位用于指定从设备,最后1 位用于表示读&#x2F;写方向。<br>每一个 12C 外设都会对应一个唯一的地址(这个地址可以从 I2C 外设器件的数据手册中得到），主机和从机之间的通信就是通过这个地址来确定主机要和哪个从机进行通信的。</p>
</li>
<li><p><strong>多主机支持</strong><br>I2C 总线支持多个主设备共享同一总线, <strong>通过仲裁机制避免冲突</strong>。当多个主设备同时试图占用总线时,<strong>优先级最高的主设备将获得总线控制权</strong>。</p>
</li>
<li><p>其他特点:</p>
<ul>
<li><strong>总线最大电容限制为 400pF</strong>。</li>
<li><strong>以字节为单位传输数据</strong>。</li>
<li>存在硬件 I2C 和软件 I2C 两种实现方式。</li>
</ul>
</li>
</ul>
<h2 id="RK3568-上的I2C"><a href="#RK3568-上的I2C" class="headerlink" title="RK3568 上的I2C"></a>RK3568 上的I2C</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204419324.png" alt="rk3568 I2C" loading="lazy"></p>
<ul>
<li>支持 6 路 I2C 接口，分别为 I2C0、I2C1、I2C2、I2C3、I2C4、I2C5</li>
<li>支持 7 位和 10 位地址模式</li>
<li>软件可编程时钟频率</li>
<li>I2C 总线上的数据传输速率可达<ul>
<li>标准模式最高 100Kbit&#x2F;s</li>
<li>快速模式最高 400Kbit&#x2F;s</li>
<li>快速模式加最高 1Mbit&#x2F;s</li>
</ul>
</li>
</ul>
<h3 id="硬件I2C与软件I2C"><a href="#硬件I2C与软件I2C" class="headerlink" title="硬件I2C与软件I2C"></a>硬件I2C与软件I2C</h3><p>这里的 6 路 I2C 接口指的是<strong>硬件 I2C</strong>，<strong>在 SOC 上有专用的硬件 I2C 电路</strong>，关于硬件 I2C的介绍如下所示</p>
<h4 id="硬件-I2C"><a href="#硬件-I2C" class="headerlink" title="硬件 I2C"></a>硬件 I2C</h4><p><strong>硬件 I2C</strong>，<strong>在 SOC 上有专用的硬件 I2C 电路</strong></p>
<ul>
<li><strong>实现方式</strong>:通过专用的硬件 I2C 接口电路来实现 I2C 总线协议。</li>
<li><strong>优点</strong>: CPU 占用低,I2C 总线由硬件电路自动完成。传输速率高,可以达到 400kbit&#x2F;s 或 3.4Mbit&#x2F;s。更加可靠和稳定,不易受外部干扰。</li>
<li><strong>缺点</strong>: 需要专用的硬件 I2C 接口电路支持,成本相对较高。接口固定,不如软件 I2C 那么灵活。</li>
<li><strong>适用范围</strong>：适用于高速、大量数据传输的场合,如 LCD、EEPROM 等外设的连接。</li>
</ul>
<h4 id="软件-I2C"><a href="#软件-I2C" class="headerlink" title="软件 I2C"></a>软件 I2C</h4><p>指的是<strong>通过 GPIO 口模拟 SCL 和 SDA 信号线</strong>，在硬件 I2C 不够用的情况下，可以通过 GPIO 来模拟软件 I2C,关于软件 I2C 的介绍如下所示：</p>
<ul>
<li><strong>实现方式</strong>: 通过软件模拟 I2C 总线协议,使用通用 I&#x2F;O 口来模拟 SCL 和 SDA 信号线。</li>
<li><strong>优点</strong>: 灵活性强,可以在任何 I&#x2F;O 口上实现 I2C 接口。成本低,不需要额外的硬件支持。</li>
<li><strong>缺点</strong>: CPU 占用较高,因为需要在软件中模拟 I2C 时序。传输速率较低,受 CPU 性能限制,一般在 100kbit&#x2F;s 左右。</li>
<li><strong>适用范围</strong>：适用于低速、少量数据传输的场合。</li>
</ul>
<h2 id="I2C的上拉电阻"><a href="#I2C的上拉电阻" class="headerlink" title="I2C的上拉电阻"></a>I2C的上拉电阻</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204417959.png" alt="上拉电阻" loading="lazy"></p>
<p>在I2C中在 SDA 数据线和 SCL 时钟线上都需要接一个上拉电阻</p>
<h3 id="接上拉电阻的作用"><a href="#接上拉电阻的作用" class="headerlink" title="接上拉电阻的作用"></a>接上拉电阻的作用</h3><ul>
<li><strong>保证总线空闲时保持高电平</strong></li>
</ul>
<p><strong>I2C 总线采用开漏&#x2F;开集电极输出, 当没有设备驱动总线时, 总线会处于高阻态</strong>。如果不接上拉电阻,总线电平将不确定,很容易受到噪声干扰。接上拉电阻可以<strong>确保总线空闲时保持稳定的高电平</strong>。</p>
<ul>
<li><strong>实现线与功能</strong></li>
</ul>
<p><strong>I2C 总线允许多个设备挂载在同一总线上</strong>。<strong>当一个设备拉低总线时,其他设备的输出也会被拉低。这就是线与功能,实现总线仲裁</strong>。如果不接上拉电阻,当总线空闲时电平不确定,一个设备拉低总线时其他设备无法感知到总线电平变化,无法实现线与功能。</p>
<p>而这里的上拉电阻也并不能随意进行取值,需要考虑<strong>总线电容</strong>的影响。I2C 总线上存在各种寄生电容,可以等效成一个 RC 充电电路，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204420160.png" alt="等效RC充电电路" loading="lazy"></p>
<p><strong>当总线从低电平转为高电平时,需要通过上拉电阻为总线供电</strong>,充电总线电容。</p>
<ul>
<li><p>如果上拉电阻取值过大,充电时间过长,会导致上升沿过慢,可能影响通信；</p>
</li>
<li><p>如果上拉电阻取值过小，则无法产生低电平</p>
</li>
</ul>
<p>所以在 I2C 规范中要求总线电容不能超过 400PF,通常建议在 1k 至 10k 欧姆之间选择,能够既保证上升沿速度,又能够可靠拉低总线电平</p>
<h3 id="I2C上拉电阻阻值计算"><a href="#I2C上拉电阻阻值计算" class="headerlink" title="I2C上拉电阻阻值计算"></a>I2C上拉电阻阻值计算</h3><h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><p>公式：<br>$$<br>R_{\text{p(min)}} &#x3D; \frac{V_{\text{DD}} - V_{\text{OL(max)}}}{I_{\text{O}}}<br>$$</p>
<ul>
<li>$ V_{\text{DD} }$          通常为 5V 或 3.3V 等常用的供电电压,在 iTOP-RK3568开发板上为 3.3V</li>
<li>$V_{\text{OL(max)}}$  表示器件在低电平时的最大输出电压,具体数值表格如下所示，由于 VDD 为3.3V，所以 VOL 的最大值为 0.4</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204424118.png" alt="器件在低电平时的最大输出电压" loading="lazy"></p>
<ul>
<li>$I_{\text{O}}$         器件在低电平时的最大灌入电流,具体数值表格如下所示，通过$V_{\text{OL}}$ 值为 0.4，可以得到 $I_{\text{O}}$在常规模式下和快速模式下的值为 3ma。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204425159.png" alt="器件在低电平时的最大灌入电流" loading="lazy"></p>
<p><strong>计算</strong>：</p>
<ol>
<li>确定 $V_{\text{DD}}$、$V_{\text{OL(max)}}$ 和 $I_{\text{OL}}$ 的值： 在 RK3568 中，$V_{\text{DD}} &#x3D; 3.3,\text{V}$，取 $V_{\text{OL(max)}} &#x3D; 0.4,\text{V}$，对应的 $I_{\text{OL}} &#x3D; 3,\text{mA}$。 </li>
<li>代入公式： $ R_{\text{p(min)}} &#x3D; \frac{V_{\text{DD}} - V_{\text{OL(max)}}}{I_{\text{OL}}} $ 计算得到上拉电阻的最小值：$ R_{\text{p(min)}} &#x3D; \frac{3.3,\text{V} - 0.4,\text{V}}{3,\text{mA}} &#x3D; \frac{2.9,\text{V}}{0.003,\text{A}} \approx 966.7,\Omega$通常可取标准电阻值 <strong>910 Ω</strong> 或 <strong>1 kΩ</strong>（若允许略低于理论最小值，需结合实际总线电容和速度要求）。</li>
</ol>
<h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><p>公式：<br>$$<br>R_{\text{p(max)}} &#x3D; \frac{0.8473 \cdot C_{\text{b}}}{t_{\text{r}}}<br>$$</p>
<ul>
<li>$R_{\text{p(max)}}$：上拉电阻的最大值（单位：Ω）  </li>
<li>$C_{\text{b}}$：总线电容（单位：F），包括 PCB 走线电容、引脚电容和器件输入电容之和  </li>
<li>$t_{\text{r}}$：高电平上升时间（单位：s），一般上升时间是从 0.3VDD 到 0.7VDD，具体可以从数据手册获得</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204428426.png" alt="高电平上升时间" loading="lazy"></p>
<p>根据上图可以得到</p>
<ul>
<li>在标准模式下 $t_{\text{r}}$的取值为 ≤ 1000ns。</li>
<li>在快速模式下$t_{\text{r}}$ 的取值为 ≤ 300ns。</li>
<li>在超快速模式下 $t_{\text{r}}$ 的取值为≤ 120ns</li>
</ul>
<p><strong>计算</strong>：</p>
<p>I²C 工作在标准模式下，上拉电压为 $3.3,\text{V}$，引脚电容为 $10,\text{pF}$，连接电容为 $30,\text{pF}$，高电平上升时间 $t_{\text{r}} &#x3D; 1000,\text{ns}$。计算上拉电阻的最大值。</p>
<ol>
<li><strong>计算总线电容</strong>： $   C_{\text{b}} &#x3D; 10,\text{pF} + 30,\text{pF} &#x3D; 40,\text{pF} &#x3D; 40 \times 10^{-12},\text{F}   $</li>
<li><strong>代入公式</strong>：   $   R_{\text{p(max)}} &#x3D; \frac{0.8473 \cdot C_{\text{b}}}{t_{\text{r}}} $</li>
<li><strong>代入数值计算</strong>：  $   R_{\text{p(max)}} &#x3D; \frac{0.8473 \times 40 \times 10^{-12},\text{F}}{1000 \times 10^{-9},\text{s}} &#x3D; \frac{33.892 \times 10^{-12}}{10^{-6}},\Omega &#x3D; 33.892 \times 10^{3},\Omega \approx 33.89,\text{k}\Omega   $</li>
</ol>
<p>因此，上拉电阻的最大值约为 <strong>33.89 kΩ</strong>。</p>
<h4 id="具体选择"><a href="#具体选择" class="headerlink" title="具体选择"></a>具体选择</h4><p>一般来说,I2C 总线速度越快,所需的上拉电阻值越小，具体选择如下所示：</p>
<ul>
<li><p>100kbps: 一般选择 10k 上拉电阻</p>
</li>
<li><p>400kbps: 一般选择 4.7k 上拉电阻</p>
</li>
<li><p>1Mbps: 一般选择 2.2k 上拉电阻</p>
</li>
</ul>
<p>当然上述选择未必正确,需要根据实际测试结果进行调整。在实际使用中,可以先根据经验选择一个上拉电阻值试用,无需过于纠结于计算公式</p>
<h2 id="I2C通信时序"><a href="#I2C通信时序" class="headerlink" title="I2C通信时序"></a>I2C通信时序</h2><h3 id="起始信号与终止信号"><a href="#起始信号与终止信号" class="headerlink" title="起始信号与终止信号"></a>起始信号与终止信号</h3><p>所有的交互都是<strong>以 START(S) 信号开始</strong>, 并<strong>以 STOP(P)信号终止</strong>，具体的起始信号和终止信号通信时序图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204454169.png" alt="起始与终止时序" loading="lazy"></p>
<ul>
<li><strong>起始信号(START)</strong>：是由总线控制器生成（即主机）的,定义为 <strong>SDA 线从高电平到低电平的跳变,同时 SCL线保持高电平</strong>。</li>
<li><strong>终止信号(STOP)</strong>：是由总线控制器生成的,定义为 <strong>SDA 线从低电平到高电平的跳变,同时 SCL线保持高电平</strong>。</li>
</ul>
<blockquote>
<p>在 START 信号之后,总线被认为是忙碌状态,直到 STOP 信号出现后总线才被认为空闲</p>
</blockquote>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ol>
<li><strong>每一个传输到 SDA 线上的字节长度都必须是 8 位</strong>。每次传输可以包含任意数量的字节。</li>
<li><strong>每个字节之后都必须跟一个应答位(Acknowledge bit)</strong>。</li>
<li>数据以<strong>最高有效位(MSB)优先的顺序</strong>传输。</li>
<li>如果目标设备在处理内部中断等操作时无法立即接收或发送另一个完整的字节数据,它<strong>可以通过拉低 SCL 线来将控制器置于等待状态</strong>。当目标设备准备好接收下一字节数据时**,释放 SCL 线即可继续数据传输**。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204430022.png" alt="I2C数据格式" loading="lazy"></p>
<h3 id="应答信号和非应答信号"><a href="#应答信号和非应答信号" class="headerlink" title="应答信号和非应答信号"></a>应答信号和非应答信号</h3><ul>
<li>应答信号发生在每个字节传输之后。应答位让接收设备向发送设备表明字节数据已经成功接收,可以发送下一个字节了。<ul>
<li><strong>应答信号</strong>：当<strong>发送设备在第 9 个时钟脉冲期间释放 SDA 线时</strong>, <strong>接收设备可以拉低 SDA 线并在此时钟高电平期间保持稳定低电平</strong></li>
<li><strong>非应答信号</strong>：<strong>在第 9 个时钟脉冲期间 SDA 线保持高电平</strong>, 控制器可以产生停止信号中止传输,或者重复启动信号开始新的传输</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204433254.png" alt="应答信号与非应答信号" loading="lazy"></p>
<p>导致产生 NACK 信号的 5 种情况包括:</p>
<ul>
<li>总线上没有接收设备响应发送的地址</li>
<li>接收设备正忙于其他实时功能而无法开始通信</li>
<li>接收设备在传输过程中收到不能理解的数据或命令</li>
<li>接收设备无法再接收更多数据字节</li>
<li>控制器-接收器必须向目标发送器表明传输结束。</li>
</ul>
<h3 id="读写方向"><a href="#读写方向" class="headerlink" title="读写方向"></a>读写方向</h3><ol>
<li><p>数据传输格式，首先<strong>发送一个 7 位的目标地址</strong>, <strong>后跟一个读&#x2F;写方向位(R&#x2F;W 位)</strong>。</p>
</li>
<li><p>读&#x2F;写方向位是第 8 位, <strong>0 表示写操作(WRITE)</strong>，<strong>1 表示读操作(READ)</strong>。</p>
</li>
</ol>
<blockquote>
<p>数据传输总是<strong>由控制器产生的停止信号(P)来结束</strong>。但<strong>如果控制器需要继续在总线上通信,它可以产生一个重复起始信号(Sr)来寻址其他目标设备,而无需先产生停止条件</strong>。</p>
<p>这样就可以在同一次传输过程中实现各种读&#x2F;写格式的组合</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204433344.png" alt="读写" loading="lazy"></p>
<h2 id="I2C波形"><a href="#I2C波形" class="headerlink" title="I2C波形"></a>I2C波形</h2><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204434134.png" alt="写操作" loading="lazy"></p>
<p>在数据传输之前，主机要先<strong>发送一个起始信号</strong>，起始信号为 SDA 线从高电平到低电平的跳变,同时 SCL 线保持高电平，就对应图所示部分,逻辑分析仪软件也用一个绿色的远点进行了标注。</p>
<p>可以将写操作分为以下步骤：</p>
<ol>
<li><strong>主机发送一个起始信号</strong></li>
<li><strong>主机发送 I2C 外设的地址和写操作，等待应答信号</strong></li>
<li>从机发送应答信号</li>
<li><strong>主机要发送寄存器的地址，等待应答信号</strong></li>
<li>从机发送应答信号</li>
<li><strong>主机发送要写入的寄存器的数据，等待应答信号</strong></li>
<li>从机发送应答信号</li>
<li><strong>主机要发送终止信号，如果写多个寄存器，重复 6,7 步骤</strong></li>
</ol>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p><strong>无论是读操作还是写操作，都要先写入 I2C 外设地址，所以最开始的波形是相同的</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204436936.png" alt="读操作" loading="lazy"></p>
<p>可以将读操作分为以下步骤：</p>
<ol>
<li><strong>主机发送一个起始信号</strong></li>
<li><strong>主机要发送 12C 外设地址和写操作，等待应答信号</strong></li>
<li>从机发送应答信号</li>
<li><strong>主机要发送要读取的寄存器的地址，等待应答信号</strong></li>
<li>从机发送应答信号</li>
<li><strong>主机发送起始信号</strong></li>
<li><strong>主机发送要读取的 12C 外设的地址和读操作，等待应答信号</strong></li>
<li>从机发送应答信号</li>
<li>从机发送数据，也就是要读取的寄存器的数据，等待应答或者非应答信号</li>
<li><strong>主机如果不在读取数据，就要发送非应答信号，如果继续读取，就发送应答信号</strong></li>
</ol>
<h1 id="I2C子系统框架"><a href="#I2C子系统框架" class="headerlink" title="I2C子系统框架"></a>I2C子系统框架</h1><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359810.png" alt="I2C子系统框架" loading="lazy"></p>
<h3 id="I2C设备驱动层"><a href="#I2C设备驱动层" class="headerlink" title="I2C设备驱动层"></a>I2C设备驱动层</h3><p>I2C 设备驱动层的主要作用为编写驱动程序,<strong>使 I2C 外设能够正常工作</strong>，然后<strong>创建了对应的设备节点</strong>，提供了标准化的接口,使得上层应用程序能够方便地与 I2C 设备进行交互。</p>
<p>具体来说,I2C 设备驱动层包含以下几个关键部分:</p>
<ul>
<li><strong>i2c_client</strong><ul>
<li><strong>代表一个连接到 I2C 总线上的从设备</strong></li>
<li>包含从设备的地址、所属的 I2C 适配器等信息</li>
</ul>
</li>
<li><strong><code>/dev/i2X</code> 设备节点</strong><ul>
<li>为上层应用程序提供设备访问的接口</li>
<li>通过打开&#x2F;读写&#x2F;控制设备节点,应用程序可以与 I2C 设备进行交互</li>
<li>内核 I2C 子系统负责将应用程序的操作转发到对应的 i2c_driver</li>
</ul>
</li>
<li><strong><code>i2c_driver</code></strong><ul>
<li>实现了具体 I2C 从设备的驱动程序</li>
<li>负责设备的初始化、读写、配置等操作</li>
<li>通过 i2c_client 与设备进行交互</li>
<li>向上层提供设备访问的标准化接口</li>
</ul>
</li>
<li><strong>I2C 总线子系统</strong><ul>
<li>管理整个 I2C 总线,包括注册&#x2F;注销 I2C 适配器和从设备</li>
<li>协调 i2c_client 和 i2c_driver 之间的交互</li>
<li>为上层提供统一的 I2C 访问接口</li>
</ul>
</li>
</ul>
<h3 id="I2C-核心层"><a href="#I2C-核心层" class="headerlink" title="I2C 核心层"></a>I2C 核心层</h3><p>I2C 核心层位于 I2C 设备驱动层和 I2C 适配器驱动层中间，起到了承上启下的作用，负责 I2C 设备驱动层和 I2C 适配器驱动层之间数据的传递，I2C 核心层的主要函数为 </p>
<ul>
<li><code>i2c_master_send</code></li>
<li><code>i2c_master_recv</code></li>
<li><code>i2c_transfer</code></li>
</ul>
<p><code>i2c_master_send</code>和<code>i2c_master_recv</code>这两个函数负责<strong>生成符合 I2C 协议的时序和数据帧</strong>,并通过对应的 I2C 适配器驱动程序进行实际的总线操作。</p>
<blockquote>
<p>其中 <code>i2c_master_send</code> 和<code>i2c_master_recv</code> 函数，是 I2C 核心层提供的基本读写接口。</p>
<p><code>i2c_master_send</code> 用于向 I2C 从设备发送数据, <code>i2c_master_recv</code> 用于从从设备接收数据。</p>
<p>它们分别接受如下参数:</p>
<ul>
<li><code>struct i2c_client *client</code>: 指向目标 I2C 从设备的指针</li>
<li><code>const char *buf/char *buf</code>: 数据缓冲区</li>
<li><code>int count</code>: 要发送&#x2F;接收的字节数</li>
</ul>
</blockquote>
<p>而 <code>i2c_transfer</code> 函数是一个更加综合的 I2C 传输函数，<code>i2c_master_send</code> 和 <code>i2c_master_recv</code>函数实际上便是调用的 <code>i2c_transfer</code></p>
<blockquote>
<p>i2c_transfer 函数它接受如下参数:</p>
<ul>
<li><code>struct i2c_adapter *adap</code>: 指向目标 I2C 适配器的指针</li>
<li><code>struct i2c_msg *msgs</code>: 指向一个 I2C 消息数组的指针</li>
<li><code>int num</code>: 消息数组中的消息数量</li>
</ul>
</blockquote>
<p>既然已经在 I2C 设备驱动层中创建了对应的设备节点，有了驱动程序就可以直接对 I2C 具体硬件进行操作了，但是在 I2C 子系<br>统并不是这样实现的，而是添加了 I2C 核心层和 I2C 适配器驱动层，那为什么要这样设计呢？</p>
<p>最主要的原因是通过驱动分层可以<strong>解决多个应用同时访问一个 I2C 设备冲突的问题</strong>，除此之外通过这种<strong>模块化设计</strong>,可以提高了代码的复用性和可维护性，使得 I2C 核心层和设备驱动程序可以独立开发和升级，I2C 适配器驱动程序也可以针对不同的硬件平台进行优化。</p>
<h3 id="I2C适配器驱动层"><a href="#I2C适配器驱动层" class="headerlink" title="I2C适配器驱动层"></a>I2C适配器驱动层</h3><p>I2C 适配器驱动层是 I2C 子系统的另一个重要组成部分,它负责<strong>实现具体的 I2C 硬件控制器的驱动程序</strong>。I2C 适配器驱动程序的作用如下所示：</p>
<ul>
<li>提供标准化的 I2C 传输接口,供 I2C 核心层调用</li>
<li>实现 I2C 总线协议的时序控制和数据收发</li>
<li>管理 I2C 总线上的从设备</li>
<li>处理 I2C 总线错误和异常情况</li>
</ul>
<h2 id="I2C-client-代码编写-设备树"><a href="#I2C-client-代码编写-设备树" class="headerlink" title="I2C client 代码编写(设备树)"></a>I2C client 代码编写(设备树)</h2><h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>在 <code>rk3568.dtsi</code> 设备树中有关于 I2C0、I2C1、I2C2、I2C3、I2C4、I2C5 的设备树节点，这里只列举出了 I2C1 的设备树节点，具体如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i2c1:</span> <span class="title class_">i2c@fe5a0000</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3399-i2c&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe5a0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_I2C1&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_I2C1&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">47</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;i2c1_xfer</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p><code>i2c1: i2c@fe5a0000</code> 节点代表 I2C1 控制器，如果 I2C 外设挂载到了 I2C1 上，就可以直接在 I2C1 控制器的节点下添加 I2C 外设的子节点，FT5X06 的设备树节点就在 <code>kernel/arch/arm64/boot/dts/rockchip/topeet-screen-lcds.dts</code> 中，具体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	ft5x061:ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">				status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">				compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">				reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">				touch-gpio = &lt;&amp;gpio3 RK_PA5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">				interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">				interrupts = &lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">				reset-gpio = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">				touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">				touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该节点向 I2C1 控制器节点追加了 FT5X06 触摸芯片相关的节点。即<strong>ft5x06作为i2c1的子节点</strong></p>
<h3 id="取消rk3568原本的驱动"><a href="#取消rk3568原本的驱动" class="headerlink" title="取消rk3568原本的驱动"></a>取消rk3568原本的驱动</h3><ol>
<li>在menuconfig中取消FT5X06驱动的勾选</li>
<li>在<code>topeet-screen-lcds.dts</code>中选用<code>LCD_TYPE_MIPI</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_TYPE_MIPI       <span class="comment">//in vp 1</span></span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_LVDS_10_1_1024X600  //in vp 2</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_LVDS_10_1_1280X800_gt9271 //in vp 2</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_LVDS_7_0   //in vp 2</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_EDP_VGA  //in vp 0</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_HDMI_VP0   //hdmi in vp 0</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_HDMI_VP1   //hdmi in vp 1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>原本的ft5x06设备树节点status从okay设置为disabled</li>
</ol>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LCD_TYPE_MIPI)</span></span><br><span class="line">...</span><br><span class="line"><span class="variable">&amp;ft5x061</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="FT5X06-Client编写"><a href="#FT5X06-Client编写" class="headerlink" title="FT5X06 Client编写"></a>FT5X06 Client编写</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;i2c1</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">	myft5x06:</span> <span class="title class_">my-ft5x06@38</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-ft5x06&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>



<p>关于追加的设备树节点描述如下所示：</p>
<ul>
<li><code>&amp;i2c1</code>: 表示对 I2C 控制器 1 进行引用。</li>
<li><code>status = &quot;okay&quot;;</code>: 表示启用 I2C 控制器 1。</li>
<li><code>myft5x06: my-ft5x06@38</code>: 定义了一个设备节点,命名为 myft5x06。<code>my-ft5x06@38</code>表示这个设备的 I2C 地址为 0x38。</li>
<li><code>compatible = &quot;my-ft5x06&quot;;</code>: 这个属性用于标识设备的类型,这里表示这是一个名为”my-ft5x06”的设备。</li>
<li><code>reg = &lt;0x38&gt;;</code>: 这个属性定义了设备在 I2C 总线上的地址,这里为 0x38</li>
</ul>
<p>而 FT5X06 触摸芯片除了 I2C 部分，还有另外两个 GPIO 分别为中断引脚和复位引脚，每个引脚对应的功能匹配表格如下所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204400010.png" alt="ft5x06两个 GPIO 分别为中断引脚和复位引脚" loading="lazy"></p>
<p>因此我们在设备树中也要描述</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;i2c1</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">	myft5x06:</span> <span class="title class_">my-ft5x06@38</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-ft5x06&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reset-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> RK_PB6 GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts-gpio</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio3</span> RK_PA5 GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">		pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;myft5x06_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</code>: 定义了设备的复位引脚,连接到<code>GPIO0</code> 的 RK_PB6 引脚,电平为低电平有效。</li>
<li><code>interrupt-parent = &lt;&amp;gpio3&gt;;</code>: 指定中断的父节点为 GPIO3。</li>
<li><code>interrupts-gpio = &lt;&amp;gpio3 RK_PA5 GPIO_ACTIVE_LOW&gt;;</code>: 定义了设备的中断引脚,连接到 GPIO3 的 RK_PA5 引脚,电平为低电平触发。</li>
<li><code>interrupts = &lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;;</code>: 进一步描述了中断的触发方式,为电平低电平触发。</li>
<li><code>pinctrl-names = &quot;default&quot;;</code> 和<code>pinctrl-0 = &lt;&amp;myft5x06_pins&gt;;</code>: 指定了设备使用的默认针脚配置。</li>
</ul>
<p>这里指定的 pinctrl 节点名为 <code>myft5x06_pins</code>，所以还需要对 pinctrl 节点进行追加，追加内容如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="title class_">myft5x06</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">		myft5x06_pins:</span> <span class="title class_">myft5x06-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line">				<span class="params">&lt;<span class="number">0</span> RK_PB6 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">				<span class="params">&lt;<span class="number">0</span> RK_PB6 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="struct-i2c-client"><a href="#struct-i2c-client" class="headerlink" title="struct i2c_client"></a>struct i2c_client</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_client - represent an I2C slave device</span></span><br><span class="line"><span class="comment"> * @flags: see I2C_CLIENT_* for possible flags</span></span><br><span class="line"><span class="comment"> * @addr: Address used on the I2C bus connected to the parent adapter.</span></span><br><span class="line"><span class="comment"> * @name: Indicates the type of the device, usually a chip name that&#x27;s</span></span><br><span class="line"><span class="comment"> *	generic enough to hide second-sourcing and compatible revisions.</span></span><br><span class="line"><span class="comment"> * @adapter: manages the bus segment hosting this I2C device</span></span><br><span class="line"><span class="comment"> * @dev: Driver model device node for the slave.</span></span><br><span class="line"><span class="comment"> * @init_irq: IRQ that was set at initialization</span></span><br><span class="line"><span class="comment"> * @irq: indicates the IRQ generated by this device (if any)</span></span><br><span class="line"><span class="comment"> * @detected: member of an i2c_driver.clients list or i2c-core&#x27;s</span></span><br><span class="line"><span class="comment"> *	userspace_devices list</span></span><br><span class="line"><span class="comment"> * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter</span></span><br><span class="line"><span class="comment"> *	calls it to pass on slave events to the slave driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_client identifies a single device (i.e. chip) connected to an</span></span><br><span class="line"><span class="comment"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span></span><br><span class="line"><span class="comment"> * managing the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> flags;		<span class="comment">/* div., see below		*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_PEC		0x04	<span class="comment">/* Use Packet Error Checking */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_TEN		0x10	<span class="comment">/* we have a ten bit chip address */</span></span></span><br><span class="line">					<span class="comment">/* Must equal I2C_M_TEN below */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SLAVE	0x20	<span class="comment">/* we are the slave */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_HOST_NOTIFY	0x40	<span class="comment">/* We want to use I2C host notify */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_WAKE		0x80	<span class="comment">/* for board_info; true iff can wake */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SCCB		0x9000	<span class="comment">/* Use Omnivision SCCB protocol */</span></span></span><br><span class="line">					<span class="comment">/* Must match I2C_M_STOP|IGNORE_NAK */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit	*/</span></span><br><span class="line">					<span class="comment">/* addresses are stored in the	*/</span></span><br><span class="line">					<span class="comment">/* _LOWER_ 7 bits		*/</span></span><br><span class="line">	<span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span></span><br><span class="line">	<span class="type">int</span> init_irq;			<span class="comment">/* irq set at initialization	*/</span></span><br><span class="line">	<span class="type">int</span> irq;			<span class="comment">/* irq issued by device		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">i2c_slave_cb_t</span> slave_cb;	<span class="comment">/* callback for slave mode	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="用C编写I2C-Client"><a href="#用C编写I2C-Client" class="headerlink" title="用C编写I2C Client"></a>用C编写I2C Client</h3><p>一般使用设备树编写I2C Client，不过在引入设备树之前使用C文件也可以</p>
<h4 id="i2c-get-adapter"><a href="#i2c-get-adapter" class="headerlink" title="i2c_get_adapter()"></a>i2c_get_adapter()</h4><p><code>i2c_get_adapter</code> 函数的主要作用是根据给定的 I2C 适配器编号 nr 从 <code>i2c_adapter_idr</code> 中查找对应的 <code>i2c_adapter</code> 结构体，该函数定义在<code>drivers/i2c/i2c-core-base.c</code>文件中，具体内容如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_adapter *<span class="title function_">i2c_get_adapter</span><span class="params">(<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span></span><br><span class="line">	<span class="comment">// 获取 i2c_adapter_idr 中的锁</span></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 在 i2c_adapter_idr 中查找指定编号的适配器</span></span><br><span class="line">	adapter = idr_find(&amp;i2c_adapter_idr, nr);</span><br><span class="line">	<span class="keyword">if</span> (!adapter)</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">	<span class="comment">// 尝试获取适配器所属模块的引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (try_module_get(adapter-&gt;owner))</span><br><span class="line">        <span class="comment">// 增加适配器 device 的引用计数</span></span><br><span class="line">		get_device(&amp;adapter-&gt;dev);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		adapter = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">// 释放 i2c_adapter_idr 中的锁</span></span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	<span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_get_adapter);</span><br></pre></td></tr></table></figure>

<h4 id="i2c-put-adapter"><a href="#i2c-put-adapter" class="headerlink" title="i2c_put_adapter()"></a>i2c_put_adapter()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_put_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!adap)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	module_put(adap-&gt;owner);</span><br><span class="line">	<span class="comment">/* Should be last, otherwise we risk use-after-free with &#x27;adap&#x27; */</span></span><br><span class="line">	put_device(&amp;adap-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_put_adapter);</span><br></pre></td></tr></table></figure>

<p>当驱动卸载时 <code>i2c_adapter</code>结构体需要被释放，而当结构体 <code>i2c_put_adapter</code> 函数用于释放 <code>i2c_adapter</code> 结构体,<code>i2c_put_adapter</code> 函数也定义在<code>drivers/i2c/i2c-core-base.c</code>文件中</p>
<h4 id="struct-i2c-adaper"><a href="#struct-i2c-adaper" class="headerlink" title="struct i2c_adaper"></a>struct i2c_adaper</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="type">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="type">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> locked_flags;	<span class="comment">/* owned by the I2C core */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_IS_SUSPENDED		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_SUSPEND_REPORTED	1</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">host_notify_domain</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="i2c-new-client-device"><a href="#i2c-new-client-device" class="headerlink" title="i2c_new_client_device()"></a>i2c_new_client_device()</h4><p><code>i2c_new_client_device</code> 函数用于创建和注册与 I2C 总线上对应的设备。注册完成后,I2C 子系统会自动为该设备创建相应的设备节点,供上层应用程序进行访问和控制，该函数同样定义在定义在<code>drivers/i2c/i2c-core-base.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device - instantiate an i2c device</span></span><br><span class="line"><span class="comment"> * @adap: the adapter managing the device</span></span><br><span class="line"><span class="comment"> * @info: describes one I2C device; bus_num is ignored</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create an i2c device. Binding is handled through driver model</span></span><br><span class="line"><span class="comment"> * probe()/remove() methods.  A driver may be bound to this device when we</span></span><br><span class="line"><span class="comment"> * return from this function, or any later moment (e.g. maybe hotplugging will</span></span><br><span class="line"><span class="comment"> * load the driver module).  This call is not appropriate for use by mainboard</span></span><br><span class="line"><span class="comment"> * initialization logic, which usually runs during an arch_initcall() long</span></span><br><span class="line"><span class="comment"> * before any i2c_adapter could exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This returns the new i2c client, which may be saved for later use with</span></span><br><span class="line"><span class="comment"> * i2c_unregister_device(); or an ERR_PTR to describe the error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> i2c_client *</span><br><span class="line"><span class="title function_">i2c_new_client_device</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span>;</span></span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line">	<span class="comment">// 分配 i2c_client 结构体空间</span></span><br><span class="line">	client = kzalloc(<span class="keyword">sizeof</span> *client, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	<span class="comment">// 设置 i2c_client 的适配器指针</span></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line">	<span class="comment">// 从 i2c_board_info 结构体中拷贝相关信息到 i2c_client</span></span><br><span class="line">	client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line">	client-&gt;flags = info-&gt;flags;</span><br><span class="line">	client-&gt;addr = info-&gt;addr;</span><br><span class="line"></span><br><span class="line">	client-&gt;init_irq = info-&gt;irq;</span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;init_irq)</span><br><span class="line">		client-&gt;init_irq = i2c_dev_irq_from_resources(info-&gt;resources,</span><br><span class="line">							 info-&gt;num_resources);</span><br><span class="line"></span><br><span class="line">	strlcpy(client-&gt;name, info-&gt;type, <span class="keyword">sizeof</span>(client-&gt;name));</span><br><span class="line">	<span class="comment">// 检查地址是否有效</span></span><br><span class="line">	status = i2c_check_addr_validity(client-&gt;addr, client-&gt;flags);</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		dev_err(&amp;adap-&gt;dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">			client-&gt;flags &amp; I2C_CLIENT_TEN ? <span class="number">10</span> : <span class="number">7</span>, client-&gt;addr);</span><br><span class="line">		<span class="keyword">goto</span> out_err_silent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for address business */</span></span><br><span class="line">    <span class="comment">// 检查地址是否已被其他设备占用</span></span><br><span class="line">	status = i2c_check_addr_ex(adap, i2c_encode_flags_to_addr(client));</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		dev_err(&amp;adap-&gt;dev,</span><br><span class="line">			<span class="string">&quot;%d i2c clients have been registered at 0x%02x&quot;</span>,</span><br><span class="line">			status, client-&gt;addr);</span><br><span class="line">	<span class="comment">// 设置 i2c_client 的设备信息</span></span><br><span class="line">	client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">	client-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line">	client-&gt;dev.of_node = of_node_get(info-&gt;of_node);</span><br><span class="line">	client-&gt;dev.fwnode = info-&gt;fwnode;</span><br><span class="line"></span><br><span class="line">	i2c_dev_set_name(adap, client, info, status);</span><br><span class="line">	<span class="comment">// 如果有设备属性,添加到设备</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties) &#123;</span><br><span class="line">		status = device_add_properties(&amp;client-&gt;dev, info-&gt;properties);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			dev_err(&amp;adap-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to add properties to client %s: %d\n&quot;</span>,</span><br><span class="line">				client-&gt;name, status);</span><br><span class="line">			<span class="keyword">goto</span> out_err_put_of_node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册设备</span></span><br><span class="line">	status = device_register(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> out_free_props;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">		client-&gt;name, dev_name(&amp;client-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">out_free_props:</span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties)</span><br><span class="line">		device_remove_properties(&amp;client-&gt;dev);</span><br><span class="line">out_err_put_of_node:</span><br><span class="line">	of_node_put(info-&gt;of_node);</span><br><span class="line">out_err_silent:</span><br><span class="line">	kfree(client);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(status);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_new_client_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="i2c-bus-probe"><a href="#i2c-bus-probe" class="headerlink" title="i2c_bus_probe()"></a>i2c_bus_probe()</h5><p><code>i2c_new_client_device()</code>中client-&gt;dev-&gt;bus被赋值为<code>i2c_bus_type</code>,执行<code>i2c_driver</code>的probe之前会先执行<code>i2c_bus_probe()</code>。在这里，对client的irq进行了赋值操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">	.match		= i2c_device_match,</span><br><span class="line">	.probe		= i2c_device_probe,</span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> <span class="title">i2c_client_type</span> =</span> &#123;</span><br><span class="line">	.groups		= i2c_dev_groups,</span><br><span class="line">	.uevent		= i2c_device_uevent,</span><br><span class="line">	.release	= i2c_client_dev_release,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_client_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 device 结构体中获取 i2c_client 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">    <span class="comment">// 从 device 结构体中获取 i2c_driver 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)<span class="comment">// 如果 client 不存在,则返回 0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	client-&gt;irq = client-&gt;init_irq;</span><br><span class="line">	<span class="comment">// 如果 client 没有中断号，则尝试获取中断号</span></span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line">		<span class="type">int</span> irq = -ENOENT;</span><br><span class="line">		<span class="comment">// 如果 client 使用 Host Notify 中断,则使用 i2c_smbus_host_notify_to_irq 获取中断号</span></span><br><span class="line">		<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY) &#123;</span><br><span class="line">			dev_dbg(dev, <span class="string">&quot;Using Host Notify IRQ\n&quot;</span>);</span><br><span class="line">			<span class="comment">/* Keep adapter active when Host Notify is required */</span></span><br><span class="line">			pm_runtime_get_sync(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line">			irq = i2c_smbus_host_notify_to_irq(client);</span><br><span class="line">        <span class="comment">// 如果设备有 DT 节点,则尝试从 DT 节点获取中断号</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">			irq = of_irq_get_byname(dev-&gt;of_node, <span class="string">&quot;irq&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (irq == -EINVAL || irq == -ENODATA)</span><br><span class="line">				irq = of_irq_get(dev-&gt;of_node, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果设备有 ACPI 关联,则尝试从 ACPI 获取中断号</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACPI_COMPANION(dev)) &#123;</span><br><span class="line">			irq = i2c_acpi_get_irq(client);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果获取中断号失败,则设置为 0</span></span><br><span class="line">		<span class="keyword">if</span> (irq == -EPROBE_DEFER) &#123;</span><br><span class="line">			status = irq;</span><br><span class="line">			<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">			irq = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 将获取到的中断号设置到 client 结构体中</span></span><br><span class="line">		client-&gt;irq = irq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 dev-&gt;driver 转换为 i2c_driver 类型</span></span><br><span class="line">	driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * An I2C ID table is not mandatory, if and only if, a suitable OF</span></span><br><span class="line"><span class="comment">	 * or ACPI ID table is supplied for the probing device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果 driver 没有 ID 表,且设备也没有匹配的 OF 或 ACPI ID 表,则返回 -ENODEV</span></span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;id_table &amp;&amp;</span><br><span class="line">	    !acpi_driver_match_device(dev, dev-&gt;driver) &amp;&amp;</span><br><span class="line">	    !i2c_of_match_device(dev-&gt;driver-&gt;of_match_table, client)) &#123;</span><br><span class="line">		status = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 client 需要唤醒功能,则尝试设置唤醒中断</span></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_WAKE) &#123;</span><br><span class="line">		<span class="type">int</span> wakeirq;</span><br><span class="line"></span><br><span class="line">		wakeirq = of_irq_get_byname(dev-&gt;of_node, <span class="string">&quot;wakeup&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (wakeirq == -EPROBE_DEFER) &#123;</span><br><span class="line">			status = wakeirq;</span><br><span class="line">			<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 启用设备的唤醒功能</span></span><br><span class="line">		device_init_wakeup(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">		<span class="comment">// 如果获取到了唤醒中断号,且与普通中断号不同,则设置专用唤醒中断</span></span><br><span class="line">		<span class="keyword">if</span> (wakeirq &gt; <span class="number">0</span> &amp;&amp; wakeirq != client-&gt;irq)</span><br><span class="line">			status = dev_pm_set_dedicated_wake_irq(dev, wakeirq);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>)<span class="comment">// 否则,使用普通中断作为唤醒中断</span></span><br><span class="line">			status = dev_pm_set_wake_irq(dev, client-&gt;irq);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			status = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 如果设置唤醒中断失败,则输出警告</span></span><br><span class="line">		<span class="keyword">if</span> (status)</span><br><span class="line">			dev_warn(&amp;client-&gt;dev, <span class="string">&quot;failed to set up wakeup irq\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 设置设备的时钟默认值</span></span><br><span class="line">	status = of_clk_set_defaults(dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line">	<span class="comment">// 附加 PM 域</span></span><br><span class="line">	status = dev_pm_domain_attach(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When there are no more users of probe(),</span></span><br><span class="line"><span class="comment">	 * rename probe_new to probe.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;probe_new)<span class="comment">// 调用 driver 的 probe_new 或 probe 函数</span></span><br><span class="line">		status = driver-&gt;probe_new(client);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (driver-&gt;probe)</span><br><span class="line">		status = driver-&gt;probe(client,</span><br><span class="line">				       i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		status = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status)<span class="comment">// 如果 probe 函数失败,则清除唤醒中断并分离 PM 域</span></span><br><span class="line">		<span class="keyword">goto</span> err_detach_pm_domain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_detach_pm_domain:</span><br><span class="line">	dev_pm_domain_detach(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">err_clear_wakeup_irq:</span><br><span class="line">	dev_pm_clear_wake_irq(&amp;client-&gt;dev);</span><br><span class="line">	device_init_wakeup(&amp;client-&gt;dev, <span class="literal">false</span>);</span><br><span class="line">put_sync_adapter:</span><br><span class="line">	<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY)</span><br><span class="line">		pm_runtime_put_sync(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="struct-i2c-board-info"><a href="#struct-i2c-board-info" class="headerlink" title="struct i2c_board_info"></a>struct i2c_board_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_board_info - template for device creation</span></span><br><span class="line"><span class="comment"> * @type: chip type, to initialize i2c_client.name</span></span><br><span class="line"><span class="comment"> * @flags: to initialize i2c_client.flags</span></span><br><span class="line"><span class="comment"> * @addr: stored in i2c_client.addr</span></span><br><span class="line"><span class="comment"> * @dev_name: Overrides the default &lt;busnr&gt;-&lt;addr&gt; dev_name if set</span></span><br><span class="line"><span class="comment"> * @platform_data: stored in i2c_client.dev.platform_data</span></span><br><span class="line"><span class="comment"> * @of_node: pointer to OpenFirmware device node</span></span><br><span class="line"><span class="comment"> * @fwnode: device node supplied by the platform firmware</span></span><br><span class="line"><span class="comment"> * @properties: additional device properties for the device</span></span><br><span class="line"><span class="comment"> * @resources: resources associated with the device</span></span><br><span class="line"><span class="comment"> * @num_resources: number of resources in the @resources array</span></span><br><span class="line"><span class="comment"> * @irq: stored in i2c_client.irq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I2C doesn&#x27;t actually support hardware probing, although controllers and</span></span><br><span class="line"><span class="comment"> * devices may be able to use I2C_SMBUS_QUICK to tell whether or not there&#x27;s</span></span><br><span class="line"><span class="comment"> * a device at a given address.  Drivers commonly need more information than</span></span><br><span class="line"><span class="comment"> * that, such as chip type, configuration, associated IRQ, and so on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * i2c_board_info is used to build tables of information listing I2C devices</span></span><br><span class="line"><span class="comment"> * that are present.  This information is used to grow the driver model tree.</span></span><br><span class="line"><span class="comment"> * For mainboards this is done statically using i2c_register_board_info();</span></span><br><span class="line"><span class="comment"> * bus numbers identify adapters that aren&#x27;t yet available.  For add-on boards,</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device() does this dynamically with the adapter already known.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>		type[I2C_NAME_SIZE];<span class="comment">// I2C 设备的类型名称,最大长度为 I2C_NAME_SIZE</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	flags;<span class="comment">// I2C 设备的标志位,用于指定设备的特殊属性</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	addr;<span class="comment">// I2C 设备的地址</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*dev_name;<span class="comment">// I2C 设备的设备名称</span></span><br><span class="line">	<span class="type">void</span>		*platform_data;<span class="comment">// I2C 设备的平台数据,可为 NUL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span><span class="comment">// I2C 设备节点在设备树中的节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span><span class="comment">// I2C 设备节点在 ACPI 中的 fwnode 句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_entry</span> *<span class="title">properties</span>;</span><span class="comment">// I2C 设备的属性列表</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resources</span>;</span><span class="comment">// I2C 设备使用的资源列表</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	num_resources;<span class="comment">// I2C 设备使用的资源数量</span></span><br><span class="line">	<span class="type">int</span>		irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 i2c_adapter 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">i2c_ada</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_board_info 结构体数组,用于描述 ft5x06 设备</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">ft5x06</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .type = <span class="string">&quot;my-ft5x06&quot;</span>,</span><br><span class="line">        .addr = <span class="number">0x38</span>, <span class="comment">// ft5x06 设备的 I2C 地址</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_client_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 I2C 适配器</span></span><br><span class="line">    i2c_ada = i2c_get_adapter(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span> (!i2c_ada)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to get I2C adapter\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 ft5x06 设备</span></span><br><span class="line">    i2c_new_device(i2c_ada, ft5x06);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动的退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_client_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 释放 I2C 适配器</span></span><br><span class="line">    i2c_put_adapter(i2c_ada);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动的初始化和退出入口函数</span></span><br><span class="line">module_init(ft5x06_client_init);</span><br><span class="line">module_exit(ft5x06_client_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="核心层-I2C-通信"><a href="#核心层-I2C-通信" class="headerlink" title="核心层 I2C 通信"></a>核心层 I2C 通信</h2><p>I2C 核心层的主要函数为 <code>i2c_master_send</code>、<code>i2c_master_recv</code> 和 <code>i2c_transfer</code>，其中 <code>i2c_master_send</code> 和<code>i2c_master_recv</code> 函数，是 I2C 核心层提供的基本读写接口。这两个函数负责生成符合 I2C 协议的时序和数据帧,并通过对应的 I2C 适配器驱动程序进行实际的总线操作。两个函数定义在<code>include/linux/i2c.h</code>文件当中</p>
<h3 id="i2c-master-recv"><a href="#i2c-master-recv" class="headerlink" title="i2c_master_recv()"></a>i2c_master_recv()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_recv - issue a single I2C message in master receive mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where to store data read from slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to read, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span><br><span class="line"><span class="params">				  <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-master-send"><a href="#i2c-master-send" class="headerlink" title="i2c_master_send()"></a>i2c_master_send()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_send - issue a single I2C message in master transmit mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Data that will be written to the slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to write, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes written.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_transfer_buffer_flags(client, (<span class="type">char</span> *)buf, count, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-transfer-buffer-flags"><a href="#i2c-transfer-buffer-flags" class="headerlink" title="i2c_transfer_buffer_flags()"></a>i2c_transfer_buffer_flags()</h3><p><code>i2c_master_recv()</code>和<code>i2c_master_send()</code>实际调用了<code>i2c_transfer_buffer_flags()</code>这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/i2c/i2c-core-base.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer_buffer_flags - issue a single I2C message transferring data</span></span><br><span class="line"><span class="comment"> *			       to/from a buffer</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where the data is stored</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to transfer, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> * @flags: The flags to be used for the message, e.g. I2C_M_RD for reads</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes transferred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer_buffer_flags</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">char</span> *buf,</span></span><br><span class="line"><span class="params">			      <span class="type">int</span> count, u16 flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 构建 i2c_msg 结构体,描述本次传输操作</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">		.addr = client-&gt;addr, <span class="comment">// 设置从设备地址</span></span><br><span class="line">		.flags = flags | (client-&gt;flags &amp; I2C_M_TEN),<span class="comment">// 设置传输标志位,包括用户传入的标志位和客户端对象自身的标志位</span></span><br><span class="line">		.len = count,<span class="comment">// 设置传输数据长度</span></span><br><span class="line">		.buf = buf,<span class="comment">// 设置数据缓冲区</span></span><br><span class="line">	&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用 i2c_transfer 函数进行数据传输</span></span><br><span class="line">    <span class="comment">// 该函数会根据传输的消息数量返回实际传输成功的消息数量</span></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If everything went ok (i.e. 1 msg transferred), return #bytes</span></span><br><span class="line"><span class="comment">	 * transferred, else error code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (ret == <span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer_buffer_flags);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数用于通过 I2C 总线传输数据。它首先构建了一个 <code>i2c_msg</code> 结构体,描述本次传输操作,包括从设备地址、传输标志位、数据长度和数据缓冲区。然后调用 <code>i2c_transfer</code> 函数进行实际的数据传输。</p>
<h3 id="i2c-transfer"><a href="#i2c-transfer" class="headerlink" title="i2c_transfer()"></a>i2c_transfer()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer - execute a single or combined I2C message</span></span><br><span class="line"><span class="comment"> * @adap: Handle to I2C bus</span></span><br><span class="line"><span class="comment"> * @msgs: One or more messages to execute before STOP is issued to</span></span><br><span class="line"><span class="comment"> *	terminate the operation; each message begins with a START.</span></span><br><span class="line"><span class="comment"> * @num: Number of messages to be executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, else the number of messages executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that there is no requirement that each message be sent to</span></span><br><span class="line"><span class="comment"> * the same slave address, although that is the most common model.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;algo-&gt;master_xfer) &#123;<span class="comment">// 如果适配器不支持 master_xfer 操作,直接返回错误</span></span><br><span class="line">		dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* REVISIT the fault reporting model here is weak:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When we get an error after receiving N bytes from a slave,</span></span><br><span class="line"><span class="comment">	 *    there is no way to report &quot;N&quot;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When we get a NAK after transmitting N bytes to a slave,</span></span><br><span class="line"><span class="comment">	 *    there is no way to report &quot;N&quot; ... or to let the master</span></span><br><span class="line"><span class="comment">	 *    continue executing the rest of this combined message, if</span></span><br><span class="line"><span class="comment">	 *    that&#x27;s the appropriate response.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When for example &quot;num&quot; is two and we successfully complete</span></span><br><span class="line"><span class="comment">	 *    the first message but get an error part way through the</span></span><br><span class="line"><span class="comment">	 *    second, it&#x27;s unclear whether that should be reported as</span></span><br><span class="line"><span class="comment">	 *    one (discarding status on the second message) or errno</span></span><br><span class="line"><span class="comment">	 *    (discarding status on the first one).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = __i2c_lock_bus_helper(adap);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">// 调用__i2c_transfer 执行实际的消息传输</span></span><br><span class="line">	ret = __i2c_transfer(adap, msgs, num);</span><br><span class="line">	i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);<span class="comment">// 解锁 I2C 总线</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>struct i2c_adapter *adap</code>: 表示要使用的 I2C 适配器。每个 I2C 控制器对应一个 <code>i2c_adapter</code> 结构体,里面包含了这个适配器的各种属性和操作函数。</li>
<li><code>struct i2c_msg *msgs</code>: 指向一个 i2c_msg 结构体数组,用于描述要传输的一个或多个 I2C消息。</li>
</ul>
<h4 id="struct-i2c-msg"><a href="#struct-i2c-msg" class="headerlink" title="struct i2c_msg"></a>struct i2c_msg</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_msg - an I2C transaction segment beginning with START</span></span><br><span class="line"><span class="comment"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span></span><br><span class="line"><span class="comment"> *	bit address, I2C_M_TEN must be set in @flags and the adapter</span></span><br><span class="line"><span class="comment"> *	must support I2C_FUNC_10BIT_ADDR.</span></span><br><span class="line"><span class="comment"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span></span><br><span class="line"><span class="comment"> *	provided unless the adapter exported the relevant I2C_FUNC_*</span></span><br><span class="line"><span class="comment"> *	flags through i2c_check_functionality().</span></span><br><span class="line"><span class="comment"> * @len: Number of data bytes in @buf being read from or written to the</span></span><br><span class="line"><span class="comment"> *	I2C slave address.  For read transactions where I2C_M_RECV_LEN</span></span><br><span class="line"><span class="comment"> *	is set, the caller guarantees that this buffer can hold up to</span></span><br><span class="line"><span class="comment"> *	32 bytes in addition to the initial length byte sent by the</span></span><br><span class="line"><span class="comment"> *	slave (plus, if used, the SMBus PEC); and this value will be</span></span><br><span class="line"><span class="comment"> *	incremented by the number of block data bytes received.</span></span><br><span class="line"><span class="comment"> * @buf: The buffer into which data is read, or from which it&#x27;s written.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_msg is the low level representation of one segment of an I2C</span></span><br><span class="line"><span class="comment"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span></span><br><span class="line"><span class="comment"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span></span><br><span class="line"><span class="comment"> * @i2c_adapter.@master_xfer() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when I2C &quot;protocol mangling&quot; is used, all I2C adapters implement</span></span><br><span class="line"><span class="comment"> * the standard rules for I2C transactions.  Each transaction begins with a</span></span><br><span class="line"><span class="comment"> * START.  That is followed by the slave address, and a bit encoding read</span></span><br><span class="line"><span class="comment"> * versus write.  Then follow all the data bytes, possibly including a byte</span></span><br><span class="line"><span class="comment"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span></span><br><span class="line"><span class="comment"> * bytes have been transferred and ACKed.  If this is the last message in a</span></span><br><span class="line"><span class="comment"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span></span><br><span class="line"><span class="comment"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span></span><br><span class="line"><span class="comment"> * passing certain @flags may have changed those standard protocol behaviors.</span></span><br><span class="line"><span class="comment"> * Those flags are only for use with broken/nonconforming slaves, and with</span></span><br><span class="line"><span class="comment"> * adapters which are known to support the specific mangling options they</span></span><br><span class="line"><span class="comment"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line">	__u16 flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line">					<span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_DMA_SAFE		0x0200	<span class="comment">/* the buffer of this message is DMA safe */</span></span></span><br><span class="line">					<span class="comment">/* makes only sense in kernelspace */</span></span><br><span class="line">					<span class="comment">/* userspace buffers are copied anyway */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_STOP		0x8000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>根据 <code>i2c_master_send</code> 函数传入参数可推断出 0 为写操作</p>
<h4 id="struct-i2c-algorithm"><a href="#struct-i2c-algorithm" class="headerlink" title="struct i2c_algorithm"></a>struct i2c_algorithm</h4><p><code>i2c_transfer</code> 函数自身并没有控制硬件的能力，<br>实际上 <code>master_xfer</code> 才是真正驱动硬件工作的函数，从而实现 I2C 通信，<code>master_xfer</code> 定义在<code>i2c_adapter</code> 结构体的 <code>i2c_algorithm </code>结构体中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_algorithm - represent I2C transfer method</span></span><br><span class="line"><span class="comment"> * @master_xfer: Issue a set of i2c transactions to the given I2C adapter</span></span><br><span class="line"><span class="comment"> *   defined by the msgs array, with num messages available to transfer via</span></span><br><span class="line"><span class="comment"> *   the adapter specified by adap.</span></span><br><span class="line"><span class="comment"> * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this</span></span><br><span class="line"><span class="comment"> *   is not present, then the bus layer will try and convert the SMBus calls</span></span><br><span class="line"><span class="comment"> *   into I2C transfers instead.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @functionality: Return the flags that this algorithm/adapter pair supports</span></span><br><span class="line"><span class="comment"> *   from the ``I2C_FUNC_*`` flags.</span></span><br><span class="line"><span class="comment"> * @reg_slave: Register given client to I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> * @unreg_slave: Unregister given client from I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following structs are for those who like to implement new bus drivers:</span></span><br><span class="line"><span class="comment"> * i2c_algorithm is the interface to a class of hardware solutions which can</span></span><br><span class="line"><span class="comment"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span></span><br><span class="line"><span class="comment"> * to name two of the most common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return codes from the ``master_xfer&#123;_atomic&#125;`` fields should indicate the</span></span><br><span class="line"><span class="comment"> * type of error code that occurred during the transfer, as documented in the</span></span><br><span class="line"><span class="comment"> * Kernel Documentation file Documentation/i2c/fault-codes.rst.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	 * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	 * using common I2C messages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	 * processed, or a negative value on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">				   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">				 <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">				 u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">	<span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>master_xfer</code>和<code>smbus_xfer</code>两个函数都是 I2C 设备驱动层控制硬件的函数，由原厂工程师进行编写，rk3568 的实现函数定义在<code>drivers/i2c/busses/i2c-rk3x.c</code>文件中，一般情况下只需使用<code>i2c_transfer</code> 函数间接调用即可。</p>
<h4 id="i2c-lock-bus-helper"><a href="#i2c-lock-bus-helper" class="headerlink" title="__i2c_lock_bus_helper"></a>__i2c_lock_bus_helper</h4><p><code>i2c_transfer</code>中调用实际执行传输的函数<code>__i2c_transfer</code>之前要调用<code>__i2c_lock_bus_helper</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We only allow atomic transfers for very late communication, e.g. to access a</span></span><br><span class="line"><span class="comment"> * PMIC when powering down. Atomic transfers are a corner case and not for</span></span><br><span class="line"><span class="comment"> * generic use!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">i2c_in_atomic_xfer_mode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> system_state &gt; SYSTEM_RUNNING &amp;&amp; irqs_disabled();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __i2c_lock_bus_helper(<span class="keyword">struct</span> i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i2c_in_atomic_xfer_mode()) &#123;</span><br><span class="line">		WARN(!adap-&gt;algo-&gt;master_xfer_atomic &amp;&amp; !adap-&gt;algo-&gt;smbus_xfer_atomic,</span><br><span class="line">		     <span class="string">&quot;No atomic I2C transfer handler for &#x27;%s&#x27;\n&quot;</span>, dev_name(&amp;adap-&gt;dev));</span><br><span class="line">		ret = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT) ? <span class="number">0</span> : -EAGAIN;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i2c_lock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的目的是在保证系统的稳定性的前提下,通过适当的锁定机制来管理对 I2C 总线的访问,防止多个操作之间的竞争条件.</p>
<ul>
<li>如果<strong>当前处于原子上下文或者中断被禁用</strong>, 在这两种情况下,<strong>内核通常不允许执行可能导致上下文切换的操作</strong>。</li>
</ul>
<p>代码使用<code>i2c_trylock_bus()</code> 函数来尝试获取 I2C总线的锁定。<code>I2C_LOCK_SEGMENT</code> 是用于指定锁定标志的。如果<code>i2c_trylock_bus()</code> 返回失败(返回值为 false),表示 I2C 总线上正在进行活动,此时函数返回错误码 -EAGAIN,表示暂时无法获取锁。</p>
<ul>
<li>如果不处于原子上下文或者中断被禁用</li>
</ul>
<p>代码直接调用 i2c_lock_bus() 函数来获取 I2C 总线的锁,而不进行条件检查。这是因为在这种情况下,系统允许执行可能导致上下文切换的操作。</p>
<h4 id="i2c-transfer-1"><a href="#i2c-transfer-1" class="headerlink" title="__i2c_transfer"></a>__i2c_transfer</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __i2c_transfer - unlocked flavor of i2c_transfer</span></span><br><span class="line"><span class="comment"> * @adap: Handle to I2C bus</span></span><br><span class="line"><span class="comment"> * @msgs: One or more messages to execute before STOP is issued to</span></span><br><span class="line"><span class="comment"> *	terminate the operation; each message begins with a START.</span></span><br><span class="line"><span class="comment"> * @num: Number of messages to be executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, else the number of messages executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adapter lock must be held when calling this function. No debug logging</span></span><br><span class="line"><span class="comment"> * takes place. adap-&gt;algo-&gt;master_xfer existence isn&#x27;t checked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __i2c_transfer(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> orig_jiffies;<span class="comment">// 记录初始的 jiffies 值</span></span><br><span class="line">	<span class="type">int</span> ret, try;<span class="comment">// 返回值和重试次数</span></span><br><span class="line">	<span class="comment">// 如果 msgs 为空或 num 小于 1,返回无效参数错误</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!msgs || num &lt; <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	ret = __i2c_check_suspended(adap);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">// 如果适配器有特殊需求,检查是否支持当前的 I2C 消息</span></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;quirks &amp;&amp; i2c_check_for_quirks(adap, msgs, num))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * i2c_trace_msg_key gets enabled when tracepoint i2c_transfer gets</span></span><br><span class="line"><span class="comment">	 * enabled.  This is an efficient way of keeping the for-loop from</span></span><br><span class="line"><span class="comment">	 * being executed when not needed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 如果启用了 i2c_trace_msg_key 这个分支点(用于跟踪 I2C 传输消息),</span></span><br><span class="line"><span class="comment">	* 则遍历所有消息,分别记录读操作和写操作的跟踪信息</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;i2c_trace_msg_key)) &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">			<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">				trace_i2c_read(adap, &amp;msgs[i], i);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				trace_i2c_write(adap, &amp;msgs[i], i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retry automatically on arbitration loss */</span> <span class="comment">// 自动重试仲裁丢失错误</span></span><br><span class="line">	orig_jiffies = jiffies;</span><br><span class="line">	<span class="keyword">for</span> (ret = <span class="number">0</span>, try = <span class="number">0</span>; try &lt;= adap-&gt;retries; try++) &#123;</span><br><span class="line">        <span class="comment">// 调用适配器的 master_xfer 函数完成 I2C 传输</span></span><br><span class="line">		<span class="keyword">if</span> (i2c_in_atomic_xfer_mode() &amp;&amp; adap-&gt;algo-&gt;master_xfer_atomic)</span><br><span class="line">			ret = adap-&gt;algo-&gt;master_xfer_atomic(adap, msgs, num);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret != -EAGAIN)<span class="comment">// 如果不是仲裁丢失错误,退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (time_after(jiffies, orig_jiffies + adap-&gt;timeout))<span class="comment">// 如果超时,退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果启用了 i2c_trace_msg_key 这个分支点,记录 I2C 传输的结果</span></span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;i2c_trace_msg_key)) &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++)</span><br><span class="line">			<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">				trace_i2c_reply(adap, &amp;msgs[i], i);</span><br><span class="line">		trace_i2c_result(adap, num, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__i2c_transfer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__i2c_transfer</code>中会 记 录 当 前 的 时 间 戳 <code>orig_jiffies</code>, 并 循 环 最多 <code>adap-&gt;retries</code> 次重试。在每次重试时,调用适配器的 <code>master_xfer</code> 函数完成 I2C 传输。如果返回值不是 <code>-EAGAIN</code>(表示仲裁丢失错误),或者已经超时,则退出循环。</p>
<h2 id="I2C-驱动"><a href="#I2C-驱动" class="headerlink" title="I2C 驱动"></a>I2C 驱动</h2><h3 id="i2c-add-driver"><a href="#i2c-add-driver" class="headerlink" title="i2c_add_driver()"></a>i2c_add_driver()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i2c_add_driver(driver) \</span></span><br><span class="line"><span class="meta">	i2c_register_driver(THIS_MODULE, driver)</span></span><br></pre></td></tr></table></figure>



<p>具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/i2c/i2c-core-base.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An i2c_driver is used with one or more i2c_client (device) nodes to access</span></span><br><span class="line"><span class="comment"> * i2c slave chips, on a bus instance associated with some i2c_adapter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!is_registered))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* add the driver to the list of i2c drivers in the driver core */</span></span><br><span class="line">	driver-&gt;driver.owner = owner;</span><br><span class="line">	driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line">	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment">	 * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = driver_register(&amp;driver-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;driver [%s] registered\n&quot;</span>, driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Walk the adapters that are already present */</span></span><br><span class="line">	i2c_for_each_dev(driver, __process_new_driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_register_driver);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数的主要作用是将 I2C 设备驱动程序注册到驱动核心中,并初始化相关数据结构,这里传入的数据结构类型为 <code>i2c_driver</code>，需要我们在驱动程序编写的时候进行填充，该结构体定义在<code>include/linux/i2c.h</code>头文件中，具体内容如下所示：</p>
<h3 id="struct-i2c-driver"><a href="#struct-i2c-driver" class="headerlink" title="struct i2c_driver"></a>struct i2c_driver</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_driver - represent an I2C device driver</span></span><br><span class="line"><span class="comment"> * @class: What kind of i2c device we instantiate (for detect)</span></span><br><span class="line"><span class="comment"> * @probe: Callback for device binding - soon to be deprecated</span></span><br><span class="line"><span class="comment"> * @probe_new: New callback for device binding</span></span><br><span class="line"><span class="comment"> * @remove: Callback for device unbinding</span></span><br><span class="line"><span class="comment"> * @shutdown: Callback for device shutdown</span></span><br><span class="line"><span class="comment"> * @alert: Alert callback, for example for the SMBus alert protocol</span></span><br><span class="line"><span class="comment"> * @command: Callback for bus-wide signaling (optional)</span></span><br><span class="line"><span class="comment"> * @driver: Device driver model driver</span></span><br><span class="line"><span class="comment"> * @id_table: List of I2C devices supported by this driver</span></span><br><span class="line"><span class="comment"> * @detect: Callback for device detection</span></span><br><span class="line"><span class="comment"> * @address_list: The I2C addresses to probe (for detect)</span></span><br><span class="line"><span class="comment"> * @clients: List of detected clients we created (for i2c-core use only)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The driver.owner field should be set to the module owner of this driver.</span></span><br><span class="line"><span class="comment"> * The driver.name field should be set to the name of this driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For automatic device detection, both @detect and @address_list must</span></span><br><span class="line"><span class="comment"> * be defined. @class should also be set, otherwise only devices forced</span></span><br><span class="line"><span class="comment"> * with module parameters will be created. The detect function must</span></span><br><span class="line"><span class="comment"> * fill at least the name field of the i2c_board_info structure it is</span></span><br><span class="line"><span class="comment"> * handed upon successful detection, and possibly also the flags field.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @detect is missing, the driver will still work fine for enumerated</span></span><br><span class="line"><span class="comment"> * devices. Detected devices simply won&#x27;t be supported. This is expected</span></span><br><span class="line"><span class="comment"> * for the many I2C/SMBus devices which can&#x27;t be detected reliably, and</span></span><br><span class="line"><span class="comment"> * the ones which can always be enumerated in practice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The i2c_client structure which is handed to the @detect callback is</span></span><br><span class="line"><span class="comment"> * not a real i2c_client. It is initialized just enough so that you can</span></span><br><span class="line"><span class="comment"> * call i2c_smbus_read_byte_data and friends on it. Don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * else with it. In particular, calling dev_dbg and friends on it is</span></span><br><span class="line"><span class="comment"> * not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span> <span class="comment">// 驱动程序所属的设备类型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id);<span class="comment">// 探测并绑定设备的回调函数</span></span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *client);<span class="comment">// 从设备上解绑驱动程序的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()&#x27;s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*probe_new)(<span class="keyword">struct</span> i2c_client *client);<span class="comment">// 新的探测设备并绑定的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *client); <span class="comment">// 设备关闭时调用的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> data);<span class="comment">// 设备报警时调用的回调函数,格式和含义取决于所使用的协议</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span><span class="comment">// 设备驱动程序基础结构</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">// 与该驱动程序匹配的设备 ID 表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> i2c_board_info *info);<span class="comment">// 用于自动创建设备的探测回调函数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;<span class="comment">// 与该驱动程序匹配的设备地址列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span><span class="comment">// 与该驱动程序绑定的 I2C 设备列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在调用 <code>i2c_add_driver</code> 函数注册 I2C 设备之前，需要先填充 <code>i2c_driver</code> 结构体，然后实现的各种回调函数，跟前面讲解的平台总线内容相同</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个工作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WORK</span><span class="params">(ft5x06_work, ft5x06_func)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 ft5x06 设备的 GPIO 描述符</span></span><br><span class="line"><span class="comment">// 用于保存 reset 和 interrupt 引脚的 GPIO 描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">reset_gpio</span>, *<span class="title">irq_gpio</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 ft5x06 设备的 i2c 客户端对象指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">ft5x06_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 ft5x06 输入设备的dev指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">ft5x06_input_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 ft5x06 设备寄存器的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(u8 reg_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 data;</span><br><span class="line">    <span class="comment">// 定义两个 i2c_msg 结构体,分别表示写操作和读操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[2] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(reg_addr),</span><br><span class="line">            .buf = &amp;reg_addr,  <span class="comment">// 写入要读取的寄存器地址</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="number">1</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr,</span><br><span class="line">            .flags = I2C_M_RD, <span class="comment">// 读操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(data),</span><br><span class="line">            .buf = &amp;data,      <span class="comment">// 读取到的数据存储位置</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线读取操作</span></span><br><span class="line">   <span class="comment">// 如果读取失败,返回 -EIO 错误码</span></span><br><span class="line">   <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 返回读取到的寄存器值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 ft5x06 设备写入寄存器的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(u8 reg_addr, u8 *data, u16 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buff[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = len + <span class="number">1</span>,    <span class="comment">// 数据长度 + 寄存器地址长度</span></span><br><span class="line">            .buf = buff,       <span class="comment">// 数据缓冲区</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    buff[<span class="number">0</span>] = reg_addr;       <span class="comment">// 写入寄存器地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buff[<span class="number">1</span>], data, len); <span class="comment">// 写入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线写入操作</span></span><br><span class="line">    <span class="comment">// 如果写入失败,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 中断处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">ft5x06_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 ft5x06_work 工作结构体提交到工作队列中</span></span><br><span class="line">    schedule_work(&amp;ft5x06_work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示中断已经被处理</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> TOUCH1_XH, TOUCH1_XL, x;</span><br><span class="line">    <span class="type">int</span> TOUCH1_YH, TOUCH1_YL, y;</span><br><span class="line">    <span class="type">int</span> TD_STATUS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从寄存器中读取触摸坐标数据</span></span><br><span class="line">    TOUCH1_XH = ft5x06_read_reg(<span class="number">0x03</span>);</span><br><span class="line">    TOUCH1_XL = ft5x06_read_reg(<span class="number">0x04</span>);</span><br><span class="line">    x = ((TOUCH1_XH &lt;&lt; <span class="number">8</span>) | TOUCH1_XL) &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">    TOUCH1_YH = ft5x06_read_reg(<span class="number">0x05</span>);</span><br><span class="line">    TOUCH1_YL = ft5x06_read_reg(<span class="number">0x06</span>);</span><br><span class="line">    y = ((TOUCH1_YH &lt;&lt; <span class="number">8</span>) | TOUCH1_YL) &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取触摸状态寄存器</span></span><br><span class="line">    TD_STATUS = ft5x06_read_reg(<span class="number">0x02</span>);</span><br><span class="line">    TD_STATUS = TD_STATUS &amp; <span class="number">0xf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据触摸状态更新输入设备</span></span><br><span class="line">    <span class="keyword">if</span> (TD_STATUS == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 触摸释放</span></span><br><span class="line">        input_report_key(ft5x06_input_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(ft5x06_input_dev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 触摸按下</span></span><br><span class="line">        input_report_key(ft5x06_input_dev, BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">        input_report_abs(ft5x06_input_dev, ABS_X, x);</span><br><span class="line">        input_report_abs(ft5x06_input_dev, ABS_Y, y);</span><br><span class="line">        input_sync(ft5x06_input_dev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ft5x06 设备的初始化函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(<span class="string">&quot;This is ft5x06 probe\n&quot;</span>);</span><br><span class="line">    ft5x06_client = client; <span class="comment">// 保存 i2c 客户端对象指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 reset GPIO 描述符</span></span><br><span class="line">    <span class="comment">// gpiod_get_optional 函数尝试获取设备树中名为 &quot;reset&quot; 的 GPIO 描述符,</span></span><br><span class="line">    <span class="comment">// 如果获取失败则返回 NULL</span></span><br><span class="line">    reset_gpio = gpiod_get_optional(&amp;client-&gt;dev, <span class="string">&quot;reset&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reset_gpio) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpiod_get_optional reset gpio is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 irq GPIO 描述符</span></span><br><span class="line">    <span class="comment">// gpiod_get_optional 函数尝试获取设备树中名为 &quot;interrupts&quot; 的 GPIO 描述符,</span></span><br><span class="line">    <span class="comment">// 如果获取失败则返回 NULL</span></span><br><span class="line">    irq_gpio = gpiod_get_optional(&amp;client-&gt;dev, <span class="string">&quot;interrupts&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!irq_gpio) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpiod_get_optional irq gpio is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 reset GPIO 为输出,并拉低 5ms 后拉高</span></span><br><span class="line">    <span class="comment">// 这是一个复位操作,用于初始化 ft5x06 设备</span></span><br><span class="line">    gpiod_direction_output(reset_gpio, <span class="number">0</span>);</span><br><span class="line">    msleep(<span class="number">5</span>);</span><br><span class="line">    gpiod_direction_output(reset_gpio, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断,设置为下降沿触发,单次触发</span></span><br><span class="line">    <span class="comment">// 当 ft5x06 设备产生中断时,会调用 ft5x06_handler 函数处理</span></span><br><span class="line">    ret = request_irq(client-&gt;irq, ft5x06_handler,</span><br><span class="line">                     IRQ_TYPE_EDGE_FALLING | IRQF_ONESHOT, <span class="string">&quot;ft5x06 irq&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;request irq is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个 input 设备</span></span><br><span class="line">    ft5x06_input_dev = input_allocate_device();</span><br><span class="line">    <span class="keyword">if</span> (ft5x06_input_dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input allocate device is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 input 设备的名称</span></span><br><span class="line">    ft5x06_input_dev-&gt;name = <span class="string">&quot;ft5x06_dev&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 input 设备支持的事件类型和事件</span></span><br><span class="line">    set_bit(EV_KEY, ft5x06_input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, ft5x06_input_dev-&gt;keybit);</span><br><span class="line">    set_bit(EV_ABS, ft5x06_input_dev-&gt;evbit);</span><br><span class="line">    set_bit(ABS_X, ft5x06_input_dev-&gt;absbit);</span><br><span class="line">    set_bit(ABS_Y, ft5x06_input_dev-&gt;absbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 input 设备的绝对坐标范围</span></span><br><span class="line">    input_set_abs_params(ft5x06_input_dev, ABS_X, <span class="number">0</span>, <span class="number">800</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    input_set_abs_params(ft5x06_input_dev, ABS_Y, <span class="number">0</span>, <span class="number">1280</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 input 设备</span></span><br><span class="line">    ret = input_register_device(ft5x06_input_dev);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input register device is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error_0:</span><br><span class="line">    input_free_device(ft5x06_input_dev);</span><br><span class="line">    free_irq(client-&gt;irq, <span class="literal">NULL</span>);</span><br><span class="line">    gpiod_put(reset_gpio);</span><br><span class="line">    gpiod_put(irq_gpio);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 设备的移除函数</span></span><br><span class="line"><span class="comment">// 参数 client 是 i2c 客户端对象指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(client-&gt;irq, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 释放 GPIO 资源</span></span><br><span class="line">    gpiod_put(reset_gpio);</span><br><span class="line">    gpiod_put(irq_gpio);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_device_id 结构体数组,用于标识 ft5x06 设备</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ft5x06_id</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;my-ft5x06&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_driver 结构体,描述 ft5x06 设备驱动</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my-ft5x06&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = ft5x06_probe,</span><br><span class="line">    .remove = ft5x06_remove,</span><br><span class="line">    .id_table = ft5x06_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ft5x06_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 注册 I2C 设备驱动</span></span><br><span class="line">    ret = i2c_add_driver(&amp;ft5x06_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c_add_driver is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 释放中断 */</span></span><br><span class="line">    free_irq(ft5x06_client-&gt;irq, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注销输入设备 */</span></span><br><span class="line">    input_unregister_device(ft5x06_input_dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 GPIO */</span></span><br><span class="line">    gpiod_put(reset_gpio);</span><br><span class="line">    gpiod_put(irq_gpio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除 I2C 驱动 */</span></span><br><span class="line">    i2c_del_driver(&amp;ft5x06_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ft5x06_driver_init);</span><br><span class="line">module_exit(ft5x06_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="在应用程序中使用I2C"><a href="#在应用程序中使用I2C" class="headerlink" title="在应用程序中使用I2C"></a>在应用程序中使用I2C</h2><h3 id="ioctl-控制-I2C"><a href="#ioctl-控制-I2C" class="headerlink" title="ioctl 控制 I2C"></a>ioctl 控制 I2C</h3><p>ioctl 是设备驱动程序中用来控制设备的接口函数，可以在应用程序中通过 ioctl 控制 I2C控制器从而对 I2C 设备进行读写。RK3568 的 I2C 控制器节点如下所示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359881.png" alt="i2c控制器节点" loading="lazy"></p>
<p>对于 I2C 控制器的控制命令 CMD 定义在<code>include/uapi/linux/i2c-dev.h</code>文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /dev/i2c-X ioctl commands.  The ioctl&#x27;s parameter is always an</span></span><br><span class="line"><span class="comment"> * unsigned long, except for:</span></span><br><span class="line"><span class="comment"> *	- I2C_FUNCS, takes pointer to an unsigned long</span></span><br><span class="line"><span class="comment"> *	- I2C_RDWR, takes pointer to struct i2c_rdwr_ioctl_data</span></span><br><span class="line"><span class="comment"> *	- I2C_SMBUS, takes pointer to struct i2c_smbus_ioctl_data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置重试次数,即当从设备没有响应时要重新轮询的次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_RETRIES	0x0701	<span class="comment">/* number of times a device address should</span></span></span><br><span class="line"><span class="comment"><span class="meta">				   be polled when not acknowledging */</span></span></span><br><span class="line"><span class="comment">//设置超时时间,单位为 10 毫秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_TIMEOUT	0x0702	<span class="comment">/* set timeout in units of 10 ms */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span> Slave address is 7 or 10 bits, but 10-bit addresses</span></span><br><span class="line"><span class="comment"> * are NOT supported! (due to code brokenness)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用此从机地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SLAVE	0x0703	<span class="comment">/* Use this slave address */</span></span></span><br><span class="line"><span class="comment">//强制使用此从机地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SLAVE_FORCE	0x0706	<span class="comment">/* Use this slave address, even if it</span></span></span><br><span class="line"><span class="comment"><span class="meta">				   is already in use by a driver! */</span></span></span><br><span class="line"><span class="comment">//0 表示 7 位地址, 非 0 表示 10 位地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_TENBIT	0x0704	<span class="comment">/* 0 for 7 bit addrs, != 0 for 10 bit */</span></span></span><br><span class="line"><span class="comment">//获取适配器功能掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNCS	0x0705	<span class="comment">/* Get the adapter functionality mask */</span></span></span><br><span class="line"><span class="comment">//执行合并读写传输(只有一个 STOP 信号)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_RDWR	0x0707	<span class="comment">/* Combined R/W transfer (one STOP only) */</span></span></span><br><span class="line"><span class="comment">//使用 PEC(校验码)进行 SMBus 传输</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_PEC		0x0708	<span class="comment">/* != 0 to use PEC with SMBus */</span></span></span><br><span class="line"><span class="comment">//执行 SMBus 传输</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SMBUS	0x0720	<span class="comment">/* SMBus transfer */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the structure as used in the I2C_SMBUS ioctl call */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_smbus_ioctl_data</span> &#123;</span></span><br><span class="line">	__u8 read_write;</span><br><span class="line">	__u8 command;</span><br><span class="line">	__u32 size;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">i2c_smbus_data</span> __<span class="title">user</span> *<span class="title">data</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the structure as used in the I2C_RDWR ioctl call */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> __<span class="title">user</span> *<span class="title">msgs</span>;</span>	<span class="comment">/* pointers to i2c_msgs */</span></span><br><span class="line">	__u32 nmsgs;			<span class="comment">/* number of i2c_msgs */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  I2C_RDWR_IOCTL_MAX_MSGS	42</span></span><br><span class="line"><span class="comment">/* Originally defined with a typo, keep it for compatibility */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  I2C_RDRW_IOCTL_MAX_MSGS	I2C_RDWR_IOCTL_MAX_MSGS</span></span><br></pre></td></tr></table></figure>

<p><code>i2c_rdwr_ioctl_data</code>这 个 结 构 体 用 于 在<code>I2C_RDWR ioctl</code> 调 用 中 传 递I2C 消 息 。 其 中</p>
<ul>
<li><code>msgs</code> 是 一 个 指向 <code>i2c_msg</code> 结构体数组的指针,用于存储一个或多个 I2C 消息。</li>
<li><code>nmsgs</code> 是 <code>i2c_msg</code> 结构体数组的长度,即 I2C 消息的数量。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从 I2C 设备的寄存器中读取数据</span></span><br><span class="line"><span class="comment"> * @param fd 打开的 I2C 设备文件描述符</span></span><br><span class="line"><span class="comment"> * @param slave_addr I2C 设备的从机地址</span></span><br><span class="line"><span class="comment"> * @param reg_addr 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @return 寄存器的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">char</span> slave_addr, <span class="type">unsigned</span> <span class="type">char</span> reg_addr)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">i2c_msgs</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个 i2c_msg 结构体, 第一个用于写入寄存器地址, 第二个用于读取数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">dev_msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = slave_addr,</span><br><span class="line">            .flags = <span class="number">0</span>,</span><br><span class="line">            .len = <span class="keyword">sizeof</span>(reg_addr),</span><br><span class="line">            .buf = &amp;reg_addr,</span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="number">1</span>] = &#123;</span><br><span class="line">            .addr = slave_addr,</span><br><span class="line">            .flags = I2C_M_RD, <span class="comment">// 设置读取标志</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(data),</span><br><span class="line">            .buf = &amp;data,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    i2c_msgs.msgs = dev_msgs;</span><br><span class="line">    i2c_msgs.nmsgs = <span class="number">2</span>; <span class="comment">// 两个 i2c_msg 结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ioctl 函数执行读取操作</span></span><br><span class="line">    ret = ioctl(fd, I2C_RDWR, &amp;i2c_msgs);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向 I2C 设备的寄存器写入数据</span></span><br><span class="line"><span class="comment"> * @param fd 打开的 I2C 设备文件描述符</span></span><br><span class="line"><span class="comment"> * @param slave_addr I2C 设备的从机地址</span></span><br><span class="line"><span class="comment"> * @param reg_addr 要写入的寄存器地址</span></span><br><span class="line"><span class="comment"> * @param data 要写入的数据</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">char</span> slave_addr, <span class="type">unsigned</span> <span class="type">char</span> reg_addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">i2c_msgs</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 i2c_msg 结构体, 用于写入寄存器地址和数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">dev_msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = slave_addr,</span><br><span class="line">            .flags = <span class="number">0</span>,</span><br><span class="line">            .len = len + <span class="number">1</span>,</span><br><span class="line">            .buf = buff,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将寄存器地址和数据拷贝到 buff 数组中</span></span><br><span class="line">    buff[<span class="number">0</span>] = reg_addr;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buff[<span class="number">1</span>], data, len);</span><br><span class="line"></span><br><span class="line">    i2c_msgs.msgs = dev_msgs;</span><br><span class="line">    i2c_msgs.nmsgs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ioctl 函数执行写入操作</span></span><br><span class="line">    ret = ioctl(fd, I2C_RDWR, &amp;i2c_msgs);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> ID_G_THGROUP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 I2C 设备文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/i2c-1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 0x38 地址的寄存器 0x80 写入 0x55</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data = <span class="number">0x55</span>;</span><br><span class="line">    ft5x06_write_reg(fd, <span class="number">0x38</span>, <span class="number">0x80</span>, &amp;data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 0x38 地址的寄存器 0x80 读取数据</span></span><br><span class="line">    ID_G_THGROUP = ft5x06_read_reg(fd, <span class="number">0x38</span>, <span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID_G_THGROUP is 0x%02X\n&quot;</span>, ID_G_THGROUP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="通用I2C驱动"><a href="#通用I2C驱动" class="headerlink" title="通用I2C驱动"></a>通用I2C驱动</h2><p>通用 I2C 驱动文件为 <code>drivers/i2c/i2c-dev.c</code>，它为 I2C 外设提供了统一的驱动框架,分为 I2C客户端 (I2C client) 和 I2C 驱动 (I2C driver)。</p>
<p>它为上层应用程序提供了通用的设备节点 <code>/dev/i2c-X</code>(X 代表 I2C 总线号)。</p>
<p>应用程序可以直接通过打开这个设备节点 <code>/dev/i2c-X</code>，并使用标准的 I&#x2F;O 操作如 open()、ioctl()、read()、write() 等来与 I2C 从设备进行通信。</p>
<p>该驱动程序一般情况下都是默认使能的，具体路径如下所示：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">	I2C Support</span><br><span class="line">		I2C Device <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>

<h3 id="i2c-dev-init"><a href="#i2c-dev-init" class="headerlink" title="i2c_dev_init()"></a>i2c_dev_init()</h3><p>驱动初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	<span class="comment">// 打印内核日志,表示 i2c /dev 条目驱动已经初始化</span></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;i2c /dev entries driver\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 注册字符设备驱动,主设备号为 I2C_MAJOR,次设备号范围为 0 到 I2C_MINORS-1,设备名为&quot;i2c&quot;</span></span><br><span class="line">	res = register_chrdev_region(MKDEV(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">// 创建一个 class 对象,名称为 &quot;i2c-dev&quot;,用于在用户空间创建设备节点</span></span><br><span class="line">	i2c_dev_class = class_create(THIS_MODULE, <span class="string">&quot;i2c-dev&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_dev_class)) &#123;</span><br><span class="line">		res = PTR_ERR(i2c_dev_class);</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_chrdev;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将 i2c_groups 数组设置为该 class 的 dev_groups 属性</span></span><br><span class="line">	i2c_dev_class-&gt;dev_groups = i2c_groups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of adapters which will be added or removed later */</span></span><br><span class="line">    <span class="comment">// 注册一个总线通知函数 i2cdev_notifier,用于追踪 i2c 总线上新添加或删除的适配器</span></span><br><span class="line">	res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_class;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bind to already existing adapters right away */</span></span><br><span class="line">    <span class="comment">// 立即绑定已经存在的 i2c 适配器到 i2c 设备</span></span><br><span class="line">	i2c_for_each_dev(<span class="literal">NULL</span>, i2cdev_attach_adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">    <span class="comment">// 销毁创建的 class 对象</span></span><br><span class="line">	class_destroy(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">    <span class="comment">// 注销已注册的字符设备驱动</span></span><br><span class="line">	unregister_chrdev_region(MKDEV(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS);</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 打印初始化失败的内核日志</span></span><br><span class="line">	printk(KERN_ERR <span class="string">&quot;%s: Driver Initialisation failed\n&quot;</span>, __FILE__);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="i2c-dev-adapter"><a href="#i2c-dev-adapter" class="headerlink" title="i2c_dev_adapter()"></a>i2c_dev_adapter()</h3><p><code>i2c_dev_init()</code>函数中最后调用<code>i2cdev_attach_adapter()</code>函数来绑定已存在的i2c适配器到i2c设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2cdev_attach_adapter</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *dummy)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_dev</span> *<span class="title">i2c_dev</span>;</span></span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	<span class="comment">// 检查设备类型是否为 i2c_adapter_type,如果不是则返回</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	adap = to_i2c_adapter(dev);</span><br><span class="line">	<span class="comment">// 从 i2c_dev_list 中获取一个空闲的 i2c_dev 结构体</span></span><br><span class="line">	i2c_dev = get_free_i2c_dev(adap);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_dev))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(i2c_dev);</span><br><span class="line">	<span class="comment">// 初始化 i2c_dev 结构体中的 cdev 字段,设置文件操作函数为 i2cdev_fops</span></span><br><span class="line">	cdev_init(&amp;i2c_dev-&gt;cdev, &amp;i2cdev_fops);</span><br><span class="line">	i2c_dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">	<span class="comment">// 初始化设备对象 i2c_dev-&gt;dev</span></span><br><span class="line">	device_initialize(&amp;i2c_dev-&gt;dev);</span><br><span class="line">    <span class="comment">// 设置设备号为主设备号 I2C_MAJOR 和次设备号 adap-&gt;nr</span></span><br><span class="line">	i2c_dev-&gt;dev.devt = MKDEV(I2C_MAJOR, adap-&gt;nr);</span><br><span class="line">	i2c_dev-&gt;dev.class = i2c_dev_class;</span><br><span class="line">	i2c_dev-&gt;dev.parent = &amp;adap-&gt;dev;</span><br><span class="line">	i2c_dev-&gt;dev.release = i2cdev_dev_release;</span><br><span class="line">    <span class="comment">// 设置设备名称为 &quot;i2c-&#123;adap-&gt;nr&#125;&quot;</span></span><br><span class="line">	dev_set_name(&amp;i2c_dev-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	<span class="comment">// 将 i2c_dev 设备添加到设备树中</span></span><br><span class="line">	res = cdev_device_add(&amp;i2c_dev-&gt;cdev, &amp;i2c_dev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">// 如果添加失败,则释放 i2c_dev 结构体</span></span><br><span class="line">		put_i2c_dev(i2c_dev, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印调试信息,表示适配器 [adap-&gt;name] 已注册为次设备号 adap-&gt;nr</span></span><br><span class="line">	pr_debug(<span class="string">&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;</span>,</span><br><span class="line">		 adap-&gt;name, adap-&gt;nr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是在系统总线上发现新的 i2c 适配器时,为其创建对应的字符设备节点。</p>
<h3 id="struct-file-operations-i2cdev-fops"><a href="#struct-file-operations-i2cdev-fops" class="headerlink" title="struct file_operations i2cdev_fops"></a>struct file_operations i2cdev_fops</h3><p><code>i2c_dev</code> 结构体中的 cdev 字段指定的文件操作集结构体为 <code>i2cdev_fops</code>，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">i2cdev_fops</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read		= i2cdev_read,</span><br><span class="line">	.write		= i2cdev_write,</span><br><span class="line">	.unlocked_ioctl	= i2cdev_ioctl,</span><br><span class="line">	.compat_ioctl	= compat_i2cdev_ioctl,</span><br><span class="line">	.open		= i2cdev_open,</span><br><span class="line">	.release	= i2cdev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="i2cdev-open"><a href="#i2cdev-open" class="headerlink" title="i2cdev_open()"></a>i2cdev_open()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2cdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> minor = iminor(inode);<span class="comment">// 获取次设备号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span><span class="comment">// 声明 i2c_client 和 i2c_adapter 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span>;</span></span><br><span class="line">	<span class="comment">// 根据次设备号获取对应的 i2c_adapter</span></span><br><span class="line">	adap = i2c_get_adapter(minor);</span><br><span class="line">    <span class="comment">// 如果没有找到对应的 i2c_adapter，返回 -ENODEV 错误</span></span><br><span class="line">	<span class="keyword">if</span> (!adap)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This creates an anonymous i2c_client, which may later be</span></span><br><span class="line"><span class="comment">	 * pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This client is ** NEVER REGISTERED ** with the driver model</span></span><br><span class="line"><span class="comment">	 * or I2C core code!!  It just holds private copies of addressing</span></span><br><span class="line"><span class="comment">	 * information and maybe a PEC flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	client = kzalloc(<span class="keyword">sizeof</span>(*client), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client) &#123;<span class="comment">// 如果内存分配失败，释放 i2c_adapter 并返回 -ENOMEM 错误</span></span><br><span class="line">		i2c_put_adapter(adap);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置 i2c_client 的名称</span></span><br><span class="line">	<span class="built_in">snprintf</span>(client-&gt;name, I2C_NAME_SIZE, <span class="string">&quot;i2c-dev %d&quot;</span>, adap-&gt;nr);</span><br><span class="line"></span><br><span class="line">	client-&gt;adapter = adap;<span class="comment">// 将 i2c_adapter 赋值给 i2c_client 的 adapter 字段</span></span><br><span class="line">	file-&gt;private_data = client;<span class="comment">// 将 i2c_client 指针保存到 file 的 private_data 字段</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="i2cdev-read"><a href="#i2cdev-read" class="headerlink" title="i2cdev_read()"></a>i2cdev_read()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After opening an instance of this character special file, a file</span></span><br><span class="line"><span class="comment"> * descriptor starts out associated only with an i2c_adapter (and bus).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Using the I2C_RDWR ioctl(), you can then *immediately* issue i2c_msg</span></span><br><span class="line"><span class="comment"> * traffic to any devices on the bus used by that adapter.  That&#x27;s because</span></span><br><span class="line"><span class="comment"> * the i2c_msg vectors embed all the addressing information they need, and</span></span><br><span class="line"><span class="comment"> * are submitted directly to an i2c_adapter.  However, SMBus-only adapters</span></span><br><span class="line"><span class="comment"> * don&#x27;t support that interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To use read()/write() system calls on that file descriptor, or to use</span></span><br><span class="line"><span class="comment"> * SMBus interfaces (and work with SMBus-only hosts!), you must first issue</span></span><br><span class="line"><span class="comment"> * an I2C_SLAVE (or I2C_SLAVE_FORCE) ioctl.  That configures an anonymous</span></span><br><span class="line"><span class="comment"> * (never registered) i2c_client so it holds the addressing information</span></span><br><span class="line"><span class="comment"> * needed by those system calls and by this SMBus interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">i2cdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">		<span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *tmp;<span class="comment">// 声明一个临时缓冲区指针</span></span><br><span class="line">	<span class="type">int</span> ret;<span class="comment">// 保存 i2c_master_recv 的返回值</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 从 file 的 private_data 字段获取 i2c_client 指针</span></span><br><span class="line">	<span class="comment">// 限制最大读取字节数为 8192</span></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 分配临时缓冲区</span></span><br><span class="line">	tmp = kzalloc(count, GFP_KERNEL);</span><br><span class="line">    <span class="comment">// 如果内存分配失败,返回 -ENOMEM 错误</span></span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 打印调试信息</span></span><br><span class="line">	pr_debug(<span class="string">&quot;i2c-dev: i2c-%d reading %zu bytes.\n&quot;</span>,</span><br><span class="line">		iminor(file_inode(file)), count);</span><br><span class="line">	<span class="comment">// 使用 i2c_master_recv 函数从 i2c_client 设备读取数据</span></span><br><span class="line">	ret = i2c_master_recv(client, tmp, count);</span><br><span class="line">    <span class="comment">// 如果读取成功</span></span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(buf, tmp, ret))<span class="comment">// 将读取的数据拷贝到用户空间缓冲区</span></span><br><span class="line">			ret = -EFAULT;<span class="comment">// 如果拷贝失败,返回 -EFAULT 错误</span></span><br><span class="line">	kfree(tmp);<span class="comment">// 释放临时缓冲区</span></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">// 返回实际读取的字节数,或者错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="i2cdev-write"><a href="#i2cdev-write" class="headerlink" title="i2cdev_write()"></a>i2cdev_write()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">i2cdev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> count, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;<span class="comment">// 保存 i2c_master_send 的返回值</span></span><br><span class="line">	<span class="type">char</span> *tmp;<span class="comment">// 声明一个临时缓冲区指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 从 file 的 private_data 字段获取 i2c_client 指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)<span class="comment">// 限制最大写入字节数为 8192</span></span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 分配一个临时缓冲区,并从用户空间拷贝数据到该缓冲区</span></span><br><span class="line">	tmp = memdup_user(buf, count);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tmp))<span class="comment">// 如果内存拷贝失败,返回错误码</span></span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(tmp);</span><br><span class="line">	<span class="comment">// 打印调试信息</span></span><br><span class="line">	pr_debug(<span class="string">&quot;i2c-dev: i2c-%d writing %zu bytes.\n&quot;</span>,</span><br><span class="line">		iminor(file_inode(file)), count);</span><br><span class="line">	<span class="comment">// 使用 i2c_master_send 函数将数据写入 i2c_client 设备</span></span><br><span class="line">	ret = i2c_master_send(client, tmp, count);</span><br><span class="line">    <span class="comment">// 释放临时缓冲区</span></span><br><span class="line">	kfree(tmp);</span><br><span class="line">    <span class="comment">// 返回实际写入的字节数,或者错误码</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="i2cdev-ioctl"><a href="#i2cdev-ioctl" class="headerlink" title="i2cdev_ioctl()"></a>i2cdev_ioctl()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">i2cdev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 file 的 private_data 字段获取 i2c_client 指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 声明一个无符号长整型变量,用于保存设备功能</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> funcs;</span><br><span class="line">	<span class="comment">// 打印调试信息</span></span><br><span class="line">	dev_dbg(&amp;client-&gt;adapter-&gt;dev, <span class="string">&quot;ioctl, cmd=0x%02x, arg=0x%02lx\n&quot;</span>,</span><br><span class="line">		cmd, arg);</span><br><span class="line">	<span class="comment">// 根据不同的 ioctl 命令进行处理</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> I2C_SLAVE:</span><br><span class="line">	<span class="keyword">case</span> I2C_SLAVE_FORCE:</span><br><span class="line">        <span class="comment">// 检查从设备地址是否合法</span></span><br><span class="line">		<span class="keyword">if</span> ((arg &gt; <span class="number">0x3ff</span>) ||</span><br><span class="line">		    (((client-&gt;flags &amp; I2C_M_TEN) == <span class="number">0</span>) &amp;&amp; arg &gt; <span class="number">0x7f</span>))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="comment">// 如果是 I2C_SLAVE 命令,检查地址是否被占用</span></span><br><span class="line">		<span class="keyword">if</span> (cmd == I2C_SLAVE &amp;&amp; i2cdev_check_addr(client-&gt;adapter, arg))</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		<span class="comment">/* REVISIT: address could become busy later */</span></span><br><span class="line">        <span class="comment">// 设置从设备地址</span></span><br><span class="line">		client-&gt;addr = arg;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_TENBIT:</span><br><span class="line">		<span class="keyword">if</span> (arg)<span class="comment">// 设置 10 位地址模式</span></span><br><span class="line">			client-&gt;flags |= I2C_M_TEN;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			client-&gt;flags &amp;= ~I2C_M_TEN;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_PEC:<span class="comment">// 设置 PEC 标志</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setting the PEC flag here won&#x27;t affect kernel drivers,</span></span><br><span class="line"><span class="comment">		 * which will be using the i2c_client node registered with</span></span><br><span class="line"><span class="comment">		 * the driver model core.  Likewise, when that client has</span></span><br><span class="line"><span class="comment">		 * the PEC flag already set, the i2c-dev driver won&#x27;t see</span></span><br><span class="line"><span class="comment">		 * (or use) this setting.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (arg)</span><br><span class="line">			client-&gt;flags |= I2C_CLIENT_PEC;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			client-&gt;flags &amp;= ~I2C_CLIENT_PEC;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_FUNCS:</span><br><span class="line">		funcs = i2c_get_functionality(client-&gt;adapter);<span class="comment">// 获取 i2c 适配器的功能</span></span><br><span class="line">		<span class="keyword">return</span> put_user(funcs, (<span class="type">unsigned</span> <span class="type">long</span> __user *)arg);<span class="comment">// 将结果写入用户空间的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> I2C_RDWR: &#123;<span class="comment">// 处理 I2C_RDWR 命令</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">rdwr_arg</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> *<span class="title">rdwr_pa</span>;</span></span><br><span class="line">		<span class="comment">// 从用户空间拷贝参数结构体</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;rdwr_arg,</span><br><span class="line">				   (<span class="keyword">struct</span> i2c_rdwr_ioctl_data __user *)arg,</span><br><span class="line">				   <span class="keyword">sizeof</span>(rdwr_arg)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="comment">// 检查参数合法性</span></span><br><span class="line">		<span class="keyword">if</span> (!rdwr_arg.msgs || rdwr_arg.nmsgs == <span class="number">0</span>)<span class="comment">// 限制最大消息数为 I2C_RDWR_IOCTL_MAX_MSGS</span></span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Put an arbitrary limit on the number of messages that can</span></span><br><span class="line"><span class="comment">		 * be sent at once</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rdwr_arg.nmsgs &gt; I2C_RDWR_IOCTL_MAX_MSGS)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		rdwr_pa = memdup_user(rdwr_arg.msgs,</span><br><span class="line">				      rdwr_arg.nmsgs * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_msg));<span class="comment">// 将用户空间的消息数组复制到内核空间</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(rdwr_pa))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(rdwr_pa);</span><br><span class="line">		<span class="comment">// 调用 i2cdev_ioctl_rdwr 函数进行 i2c 读写操作</span></span><br><span class="line">		<span class="keyword">return</span> i2cdev_ioctl_rdwr(client, rdwr_arg.nmsgs, rdwr_pa);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS: &#123;<span class="comment">// 处理 I2C_SMBUS 命令</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">i2c_smbus_ioctl_data</span> <span class="title">data_arg</span>;</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;data_arg,</span><br><span class="line">				   (<span class="keyword">struct</span> i2c_smbus_ioctl_data __user *) arg,</span><br><span class="line">				   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_smbus_ioctl_data)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">return</span> i2cdev_ioctl_smbus(client, data_arg.read_write,</span><br><span class="line">					  data_arg.command,</span><br><span class="line">					  data_arg.size,</span><br><span class="line">					  data_arg.data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> I2C_RETRIES:<span class="comment">// 设置 i2c 适配器的重试次数</span></span><br><span class="line">		<span class="keyword">if</span> (arg &gt; INT_MAX)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		client-&gt;adapter-&gt;retries = arg;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_TIMEOUT:<span class="comment">// 设置 i2c 适配器的超时时间</span></span><br><span class="line">		<span class="keyword">if</span> (arg &gt; INT_MAX)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* For historical reasons, user-space sets the timeout</span></span><br><span class="line"><span class="comment">		 * value in units of 10 ms.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 用户空间设置的单位是 10 ms</span></span><br><span class="line">		client-&gt;adapter-&gt;timeout = msecs_to_jiffies(arg * <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:<span class="comment">// 不支持的 ioctl 命令</span></span><br><span class="line">		<span class="comment">/* <span class="doctag">NOTE:</span>  returning a fault code here could cause trouble</span></span><br><span class="line"><span class="comment">		 * in buggy userspace code.  Some old kernel bugs returned</span></span><br><span class="line"><span class="comment">		 * zero in this case, and userspace code might accidentally</span></span><br><span class="line"><span class="comment">		 * have depended on that bug.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="I2C-tools"><a href="#I2C-tools" class="headerlink" title="I2C_tools"></a>I2C_tools</h2><div class="tag link"><a class="link-card" title="I2C tools" target="_blank" rel="noopener" href="https://archive.kernel.org/oldwiki/i2c.wiki.kernel.org/index.php/I2C_Tools.html"><div class="left"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://archive.kernel.org/oldwiki/i2c.wiki.kernel.org/favicon.ico"/></div><div class="right"><p class="text">I2C tools</p><p class="url">https://archive.kernel.org/oldwiki/i2c.wiki.kernel.org/index.php/I2C_Tools.html</p></div></a></div>



<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make CC=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarc</span><br><span class="line">h64-linux-gnu/bin/aarch64-linux-gnu-gcc \</span><br><span class="line">AR=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-lin</span><br><span class="line">ux-gnu/bin/aarch64-linux-gnu-ar \</span><br><span class="line">USE_STATIC_LIB=1</span><br></pre></td></tr></table></figure>

<p>如果使用的是 ubuntu 或者 Debian 系统只需要使用命令<code>sudo apt install i2c-tools</code>进行安装即可</p>
<h3 id="i2cdetect"><a href="#i2cdetect" class="headerlink" title="i2cdetect"></a>i2cdetect</h3><p>i2cdetect 可以用来检测和探测 I2C 总线上连接的设备。</p>
<ul>
<li><code>i2cdetect -V</code>: <strong>输出版本信息</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359975.png" alt="i2cdetect -V" loading="lazy"></p>
<ul>
<li><code>i2cdetect -l</code>:<strong>列出所有的i2c总线</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359917.png" alt="i2cdetect -l" loading="lazy"></p>
<ul>
<li><code>i2cdetect -F</code> <strong>查询总线上设备支持的功能集</strong>，例如 <code>i2cdetect -F 1</code> 将列出总线 1 上设备支持的功能</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359947.png" alt="i2cdetect -F 1" loading="lazy"></p>
<ul>
<li><code>i2cdetect -a</code> 扫描总线上 0x00 到 0xFF 范围内的所有 I2C 设备地址。例如: <code>i2cdetect -a -y 1</code>将扫描 I2C1 总线上全部的 I2C 设备地址</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204407477.png" alt="image-20251228201405427" loading="lazy"></p>
<p>这里的 0x38 就是 FT5X06 触摸芯片的 I2C 设备地址</p>
<h3 id="i2cdump"><a href="#i2cdump" class="headerlink" title="i2cdump"></a>i2cdump</h3><p>i2cdump 可以读取设备上所有寄存器的值，具体用法如下：</p>
<ul>
<li><code>i2cdump -V</code> 查看版本号</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204410361.png" alt="i2cdump -V" loading="lazy"></p>
<ul>
<li><code>i2cdump -f -a</code>读取设备寄存器,使用 <code>i2cdump -f -a 1 0x38</code> 命令可以读取 I2C 设备地址为 0x38 的所有寄存<br>器值(从 0x00 到 0xFF)。<ul>
<li>-f 选项用于强制使用设备地址</li>
<li>-a 选项则是用于读取整个地址范围。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204410626.png" alt="i2cdump -f -a 1 0x38" loading="lazy"></p>
<ul>
<li><code>i2cdump -f -r</code>指定寄存器范围读取，使用 <code>i2cdump -f -r 0x80-0xff 1 0x38</code> 命令可以只读取 I2C 设备地址为0x38 的 0x80 到 0xff 范围内的寄存器值。-r 选项用于指定要读取的寄存器地址范围</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204415130.png" alt="i2cdump -f -r" loading="lazy"></p>
<h3 id="i2cset"><a href="#i2cset" class="headerlink" title="i2cset"></a>i2cset</h3><p>i2cset 命令用于向 I2C 设备的特定寄存器写入数据。它的用法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cset -f -r 1 0x38 0x80 0x11</span><br></pre></td></tr></table></figure>

<p>这条命令的意思是:</p>
<ul>
<li>强制使用 I2C 总线 1 上的设备地址 0x38</li>
<li>向该设备的寄存器地址 0x80 写入值 0x11</li>
</ul>
<p>写入完成后,该命令会返回一个确认信息,表示写入是否成功。如果写入失败,则会返回一个错误信息。</p>
<h3 id="i2cget"><a href="#i2cget" class="headerlink" title="i2cget"></a>i2cget</h3><p>i2cget 命令用于从 I2C 设备的指定寄存器中读取数据它的用法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cget -f 1 0x38 0x80</span><br></pre></td></tr></table></figure>

<p>这条命令的意思是:</p>
<ul>
<li>强制使用 I2C 总线 1 上的设备地址 0x38</li>
<li>从该设备的寄存器地址 0x80 读取数据</li>
</ul>
<p>该命令会返回寄存器 0x80 的值。读取成功后,会显示类似 0x11 的十六进制值。如果读取失败,则会返回一个错误信息。</p>
<h3 id="i2ctransfer"><a href="#i2ctransfer" class="headerlink" title="i2ctransfer"></a>i2ctransfer</h3><p>i2ctransfer 是一个更加强大和灵活的 I2C 操作工具,与之前介绍的 i2cset 和 i2cget 命令相比,它可以在单个命令中完成读写操作。具体用法如下所示：<br><strong>写操作</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2ctransfer 1 w2@0x38 0x80 0x22</span><br></pre></td></tr></table></figure>

<ul>
<li><code>1</code> 表示操作的 I2C 总线编号为 1</li>
<li><code>w2</code> 表示写入 2 个字节的数据</li>
<li><code>@0x38</code> 表示设备地址为 0x38</li>
<li><code>0x80</code> 表示要写入的寄存器地址为 0x80</li>
<li><code>0x22</code> 表示要写入寄存器的值为 0x22</li>
</ul>
<p><strong>读操作</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2ctransfer 1 w1@0x38 0x80 r1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>1</code> 表示操作的 I2C 总线编号为 1</li>
<li><code>w1</code> 表示写入 1 个字节的数据</li>
<li><code>@0x38</code> 表示设备地址为 0x38</li>
<li><code>0x80</code> 表示要写入的寄存器地址为 0x80</li>
<li><code>r1</code> 表示读取 1 个字节的数据</li>
</ul>
<h2 id="使用-GPIO-模拟-I2C-驱动"><a href="#使用-GPIO-模拟-I2C-驱动" class="headerlink" title="使用 GPIO 模拟 I2C 驱动"></a>使用 GPIO 模拟 I2C 驱动</h2><p>由于要使用软件 I2C，所以要取消掉在设备树中硬件 I2C1 的使能，要在设备树中把ft5x06和i2c1的status都设置为disabled。</p>
<p>此时 I2C1 的两个复用引脚 GPIO0 B3、GPIO0 B4 会设置为默认的 GPIO 功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 I2C 总线的时钟线和数据线对应的 GPIO 引脚编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SCL 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个 GPIO 描述符变量,用于保存 SCL 和 SDA 引脚的描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">i2c_scl_desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">i2c_sda_desc</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C 起始条件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 SCL 和 SDA 引脚设置为输出模式,并初始化为高电平</span></span><br><span class="line">    <span class="comment">// 这是 I2C 总线的空闲状态</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SDA 引脚设置为低电平,保持 SCL 为高电平</span></span><br><span class="line">    <span class="comment">// 这将产生 I2C 总线的起始条件</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SCL 引脚设置为低电平</span></span><br><span class="line">    <span class="comment">// 起始条件建立完成</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C 停止条件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 SCL 和 SDA 引脚设置为低电平</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SCL 引脚设置为高电平</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SDA 引脚设置为高电平</span></span><br><span class="line">    <span class="comment">// 这将产生 I2C 总线的停止条件</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_send_ack</span><span class="params">(<span class="type">int</span> ack)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置SDA线为输出模式</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        <span class="comment">// 发送ACK信号, SDA线拉低</span></span><br><span class="line">        gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送NACK信号, SDA线拉高</span></span><br><span class="line">        gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉高SCL线1ms,然后拉低</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收ACK信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_recv_ack</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置SDA线为输入模式</span></span><br><span class="line">    gpiod_direction_input(i2c_sda_desc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉高SCL线1ms</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取SDA线的电平状态</span></span><br><span class="line">    <span class="keyword">if</span> (gpiod_get_value(i2c_sda_desc)) &#123;</span><br><span class="line">        value = <span class="number">1</span>; <span class="comment">// 接收到NACK信号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="number">0</span>; <span class="comment">// 接收到ACK信号</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉低SCL线</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置SDA线为输出模式并拉高</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_send_data</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SCL线为输出模式并拉低</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送8位数据</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前位的值</span></span><br><span class="line">        value = (data &lt;&lt; i) &amp; <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据当前位的值设置SDA线</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拉高SCL线1ms,然后拉低</span></span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_recv_data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SDA线为输入模式</span></span><br><span class="line">    gpiod_direction_input(i2c_sda_desc);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收8位数据</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 拉低SCL线1ms</span></span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拉高SCL线1ms</span></span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取SDA线的电平状态</span></span><br><span class="line">        data = gpiod_get_value(i2c_sda_desc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据当前位的值更新接收数据</span></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            temp = (temp &lt;&lt; <span class="number">1</span>) | data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = (temp &lt;&lt; <span class="number">1</span>) &amp; ~data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拉低SCL线</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SDA线为输出模式并拉高</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 触摸屏写寄存器函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(<span class="type">int</span> addr, <span class="type">int</span> reg, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始 I2C 通信</span></span><br><span class="line">    i2c_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送触摸屏设备地址(写操作)</span></span><br><span class="line">    i2c_send_data(addr &lt;&lt; <span class="number">1</span> | <span class="number">0x00</span>);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send write + addr error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送寄存器地址</span></span><br><span class="line">    i2c_send_data(reg);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send reg error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送要写入的值</span></span><br><span class="line">    i2c_send_data(value);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send value error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 结束 I2C 通信</span></span><br><span class="line">    i2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  ft5x06 触摸屏读寄存器函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(<span class="type">int</span> addr, <span class="type">int</span> reg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ack;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始 I2C 通信</span></span><br><span class="line">    i2c_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送触摸屏设备地址(写操作)</span></span><br><span class="line">    i2c_send_data(addr &lt;&lt; <span class="number">1</span> | <span class="number">0x00</span>);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send write + addr error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送要读取的寄存器地址</span></span><br><span class="line">    i2c_send_data(reg);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send reg error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新开始 I2C 通信,发送读操作地址</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_send_data(addr &lt;&lt; <span class="number">1</span> | <span class="number">0x01</span>);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send read + addr error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取寄存器值</span></span><br><span class="line">    data = i2c_recv_data();</span><br><span class="line">    printk(<span class="string">&quot;data is %d\n&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 ACK 以结束读操作</span></span><br><span class="line">    i2c_send_ack(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 结束 I2C 通信</span></span><br><span class="line">    i2c_stop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 GPIO 编号转换为 GPIO 描述符</span></span><br><span class="line">    i2c_scl_desc = gpio_to_desc(I2C_SCL);</span><br><span class="line">    <span class="keyword">if</span> (i2c_scl_desc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpio_to_desc error for SCL pin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i2c_sda_desc = gpio_to_desc(I2C_SDA);</span><br><span class="line">    <span class="keyword">if</span> (i2c_sda_desc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpio_to_desc error for SDA pin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GPIO 引脚设置为输出模式,并初始化为高电平</span></span><br><span class="line">    <span class="comment">// 这是 I2C 总线的空闲状态</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ft5x06_write_reg(<span class="number">0x38</span>,<span class="number">0x80</span>,<span class="number">0x33</span>);</span><br><span class="line">	ft5x06_read_reg(<span class="number">0x38</span>,<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放 GPIO 描述符</span></span><br><span class="line">    gpiod_put(i2c_scl_desc);</span><br><span class="line">    gpiod_put(i2c_sda_desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册驱动初始化和退出函数</span></span><br><span class="line">module_init(ft5x06_driver_init);</span><br><span class="line">module_exit(ft5x06_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用Linux默认的模拟I2C程序"><a href="#使用Linux默认的模拟I2C程序" class="headerlink" title="使用Linux默认的模拟I2C程序"></a>使用Linux默认的模拟I2C程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line">make rockchip_linux_defconfig</span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line">&gt; Device Drivers</span><br><span class="line">	&gt; I2C support</span><br><span class="line">		&gt; I2C Hardware Bus support</span><br><span class="line">			&lt;*&gt; GPIO-based bitbanging I2C</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line"><span class="built_in">cp</span> .config <span class="built_in">arch</span>/arm64/configs/rockchip_linux_defconfig</span><br></pre></td></tr></table></figure>

<p>设备树修改</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i2c6:</span><span class="title class_">i2c6@gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;i2c-gpio&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	<span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpi00</span> RK PB4 GPIO ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">			<span class="params">&lt;<span class="variable">&amp;gpi00</span> RK PB3 GPIO ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">	i2<span class="attr">c-gpio,delay-us</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>对 I2C6 节点进行追加，最佳 FT5X06 触摸芯片相关的内容，添加内容如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;i2c6</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">	myft5x06:</span> <span class="title class_">my-ft5x06@38</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-ft5x06&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，由于之前编写的设备树节点名也叫 myft5x06，会产生命名冲突，所以需要将之前编写的 myft5x06 设备树节点注释掉</p>
</blockquote>
<p>编写驱动程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 ft5x06 设备的 i2c 客户端对象指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">ft5x06_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 ft5x06 设备寄存器的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(u8 reg_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 data;</span><br><span class="line">    <span class="comment">// 定义两个 i2c_msg 结构体,分别表示写操作和读操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[2] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(reg_addr),</span><br><span class="line">            .buf = &amp;reg_addr,  <span class="comment">// 写入要读取的寄存器地址</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="number">1</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr,</span><br><span class="line">            .flags = I2C_M_RD, <span class="comment">// 读操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(data),</span><br><span class="line">            .buf = &amp;data,      <span class="comment">// 读取到的数据存储位置</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线读取操作</span></span><br><span class="line">   <span class="comment">// 如果读取失败,返回 -EIO 错误码</span></span><br><span class="line">   <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 返回读取到的寄存器值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 ft5x06 设备写入寄存器的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(u8 reg_addr, u8 *data, u16 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buff[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = len + <span class="number">1</span>,    <span class="comment">// 数据长度 + 寄存器地址长度</span></span><br><span class="line">            .buf = buff,       <span class="comment">// 数据缓冲区</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    buff[<span class="number">0</span>] = reg_addr;       <span class="comment">// 写入寄存器地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buff[<span class="number">1</span>], data, len); <span class="comment">// 写入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线写入操作</span></span><br><span class="line">    <span class="comment">// 如果写入失败,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 设备的探测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    printk(<span class="string">&quot;This is ft5x06 probe\n&quot;</span>);</span><br><span class="line">    ft5x06_client = client; <span class="comment">// 保存 i2c 客户端对象指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写寄存器</span></span><br><span class="line">    ft5x06_write_reg(<span class="number">0x80</span>, &amp;(u8)&#123;<span class="number">0x4b</span>&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读寄存器</span></span><br><span class="line">    value = ft5x06_read_reg(<span class="number">0x80</span>);</span><br><span class="line">    printk(<span class="string">&quot;reg 0x80 is %x\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 设备的移除函数</span></span><br><span class="line"><span class="comment">// 参数 client 是 i2c 客户端对象指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_device_id 结构体数组,用于标识 ft5x06 设备</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ft5x06_id</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;my-ft5x06&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_driver 结构体,描述 ft5x06 设备驱动</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my-ft5x06&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = ft5x06_probe,</span><br><span class="line">    .remove = ft5x06_remove,</span><br><span class="line">    .id_table = ft5x06_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ft5x06_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 注册 I2C 设备驱动</span></span><br><span class="line">    ret = i2c_add_driver(&amp;ft5x06_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c_add_driver is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ft5x06_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销 I2C 设备驱动</span></span><br><span class="line">    i2c_del_driver(&amp;ft5x06_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ft5x06_driver_init);</span><br><span class="line">module_exit(ft5x06_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="SMBus总线"><a href="#SMBus总线" class="headerlink" title="SMBus总线"></a>SMBus总线</h2><p>SMBus(System Management Bus)是由 Intel 在 1995 年发布的一种基于 I2C 总线的串行总线协议。它最初被设计用于在电脑系统内部连接智能电池和其他系统管理设备。</p>
<p>SMBus 与 I2C 总线非常相似,它们都采用两线式串行通信。SMBus 使用 SMBDAT 和 SMBCLK 作为数据线和时钟线,与 I2C 的 SDA 和 SCL 很相似，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204416226.png" alt="SMBus" loading="lazy"></p>
<h3 id="SMBus特点"><a href="#SMBus特点" class="headerlink" title="SMBus特点"></a>SMBus特点</h3><p>SMBus 的主要特点如下所示：</p>
<p><strong>电气特性</strong>:</p>
<ul>
<li>采用开漏输出,需要外部上拉电阻</li>
<li>电压范围:0V 到 5.5V</li>
<li>最大时钟频率:100kHz</li>
</ul>
<p><strong>通信协议:</strong></p>
<ul>
<li>主从式通信,一个主设备控制多个从设备</li>
<li>地址空间:7 位或 10 位</li>
<li>支持读&#x2F;写操作</li>
<li>支持块传输和字节传输</li>
<li>支持多种事务类型,如快速命令、写字节、读字节等</li>
</ul>
<p><strong>功能特性:</strong></p>
<ul>
<li>简单、低成本、低功耗</li>
<li>面向系统管理应用,如电源管理、温度监控等</li>
<li>与 I2C 高度兼容,可以复用 I2C 硬件</li>
</ul>
<p><strong>时序特性</strong>:</p>
<ul>
<li>Start 和 Stop 条件与 I2C 相同</li>
<li>地址和数据传输时序也与 I2C 相似</li>
<li>但有一些特殊的时序,如快速命令、块传输等</li>
</ul>
<h3 id="SMBus-和-I2C-的区别"><a href="#SMBus-和-I2C-的区别" class="headerlink" title="SMBus 和 I2C 的区别"></a>SMBus 和 I2C 的区别</h3><ul>
<li><strong>速度范围</strong>:<br>I2C 支持从 10kHz 到 3.4MHz 不等的速度范围,覆盖了更广泛的应用场景。SMBus 则只支持 10kHz 到 100kHz 的速度范围,主要面向低速的系统管理应用场景。</li>
<li><strong>ACK 应答:</strong><br>I2C 不强制从机发送 ACK 应答,这样可以提高灵活性。但如果从机没有应答,主机可能会产生错误。SMBus 要求从机必须发送 ACK 应答,这可以确保主机能够检测到从机是否存在,避免误操作。</li>
<li><strong>时间限制</strong>:<br>SMBus 规定,从机不能将 SCL 线拉低超过 35ms,否则会复位正在进行的通信。I2C 没有这样的时间限制,主机和从机可以自主控制 SCL 线的状态。</li>
<li><strong>其他区别:</strong><br>SMBus 有一些专门为系统管理设计的命令和事务类型,如快速命令、块传输等。SMBus 的地址空间相比 I2C 更小,只支持 7 位或 10 位地址。SMBus 在电气特性上也有一些差异,如电压范围等</li>
</ul>
<h3 id="SMBus-总线软件实现"><a href="#SMBus-总线软件实现" class="headerlink" title="SMBus 总线软件实现"></a>SMBus 总线软件实现</h3><p>在 Linux 内核中,<strong>I2C 和 SMBus 是共用的总线架构</strong>,<strong>通过 i2c-core 子系统进行管理和抽象</strong>，在 <code>i2c.h</code> 头文件中定义了<code> i2c_algorithm</code> 结构体中，具体内容如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_algorithm - represent I2C transfer method</span></span><br><span class="line"><span class="comment"> * @master_xfer: Issue a set of i2c transactions to the given I2C adapter</span></span><br><span class="line"><span class="comment"> *   defined by the msgs array, with num messages available to transfer via</span></span><br><span class="line"><span class="comment"> *   the adapter specified by adap.</span></span><br><span class="line"><span class="comment"> * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this</span></span><br><span class="line"><span class="comment"> *   is not present, then the bus layer will try and convert the SMBus calls</span></span><br><span class="line"><span class="comment"> *   into I2C transfers instead.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @functionality: Return the flags that this algorithm/adapter pair supports</span></span><br><span class="line"><span class="comment"> *   from the ``I2C_FUNC_*`` flags.</span></span><br><span class="line"><span class="comment"> * @reg_slave: Register given client to I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> * @unreg_slave: Unregister given client from I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following structs are for those who like to implement new bus drivers:</span></span><br><span class="line"><span class="comment"> * i2c_algorithm is the interface to a class of hardware solutions which can</span></span><br><span class="line"><span class="comment"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span></span><br><span class="line"><span class="comment"> * to name two of the most common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return codes from the ``master_xfer&#123;_atomic&#125;`` fields should indicate the</span></span><br><span class="line"><span class="comment"> * type of error code that occurred during the transfer, as documented in the</span></span><br><span class="line"><span class="comment"> * Kernel Documentation file Documentation/i2c/fault-codes.rst.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	 * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	 * using common I2C messages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	 * processed, or a negative value on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">				   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">				 <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">				 u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">	<span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 smbus_xfer 函数用于实现 SMBus 特有的一些操作,如快速命令、写字节、读字节等。</p>
<p><strong>当 I2C 控制器工作在 SMBus 模式时,会通过 smbus_xfer 函数来执行 SMBus 的特殊事务。</strong></p>
<h3 id="SMBus-总线-API-函数"><a href="#SMBus-总线-API-函数" class="headerlink" title="SMBus 总线 API 函数"></a>SMBus 总线 API 函数</h3><ol>
<li><strong><code>i2c_smbus_read_byte(const struct i2c_client *client)</code></strong><ul>
<li>发送 <strong>SMBus Read Byte</strong> 协议。</li>
<li>不发送寄存器地址，直接读取设备当前指向的数据字节。</li>
<li>适用于：设备支持自动递增地址（如某些 EEPROM 连续读），或之前已通过其他方式设置好地址指针。</li>
<li>⚠️ 大多数现代 I2C 设备<strong>不支持</strong>这种无地址读取，因此<strong>较少使用</strong>。</li>
</ul>
</li>
<li><strong><code>i2c_smbus_write_byte(const struct i2c_client *client, u8 value)</code></strong><ul>
<li>发送 <strong>SMBus Send Byte</strong> 协议。</li>
<li>仅发送一个字节（<code>value</code> 作为命令），<strong>不带数据阶段</strong>。</li>
<li>注意：这里的 <code>value</code> 被当作 <strong>command</strong>，而不是写入的数据！</li>
<li>常用于触发设备动作（如复位、启动转换），<strong>不是写寄存器值</strong>。</li>
<li>❗容易误解！若想“向寄存器写值”，应使用 <code>i2c_smbus_write_byte_data</code>。</li>
</ul>
</li>
<li><strong><code>i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)</code></strong><ul>
<li>发送 <strong>SMBus Read Byte Data</strong> 协议。</li>
<li>先发送 <code>command</code>（寄存器地址），再读回 1 字节数据。</li>
<li>✅ <strong>最常用的读寄存器方式</strong>。</li>
</ul>
</li>
<li><strong><code>i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command, u8 value)</code></strong><ul>
<li>发送 <strong>SMBus Write Byte Data</strong> 协议。</li>
<li>发送 <code>command</code>（寄存器地址） + <code>value</code>（要写入的数据）。</li>
<li>✅ <strong>最常用的写寄存器方式</strong>。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/2512283/">https://even629.com/posts/2512283/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><div class="post-share"><div class="social-share" data-image="/images/linux_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center liquidGlass-wrapper" id="my-custom-card-author"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status">🐟<span>认真摸鱼中</span></div></div></div><div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" target="_blank" title="github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" target="_blank" title="email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com/519280138" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="rss"><i class="fas fa-rss" style="color: #000000;"></i></a></div></div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"> <div class="newYear-slider"> <div class="swiper-wrapper"> <div class="swiper-slide" style="background-image:url(/img/happy_new_year1.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year2.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year3.webp)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year4.gif)"></div> </div> </div> <div id="newYear-main"> <div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div> </div></div><div class="sticky_layout"><div class="card-widget liquidGlass-wrapper" id="card-toc"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#I2C%E7%AE%80%E4%BB%8B"><span class="toc-text">I2C简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RK3568-%E4%B8%8A%E7%9A%84I2C"><span class="toc-text">RK3568 上的I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6I2C%E4%B8%8E%E8%BD%AF%E4%BB%B6I2C"><span class="toc-text">硬件I2C与软件I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-I2C"><span class="toc-text">硬件 I2C</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6-I2C"><span class="toc-text">软件 I2C</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E7%9A%84%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB"><span class="toc-text">I2C的上拉电阻</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">接上拉电阻的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E9%98%BB%E5%80%BC%E8%AE%A1%E7%AE%97"><span class="toc-text">I2C上拉电阻阻值计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E9%80%89%E6%8B%A9"><span class="toc-text">具体选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E9%80%9A%E4%BF%A1%E6%97%B6%E5%BA%8F"><span class="toc-text">I2C通信时序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-text">起始信号与终止信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7%E5%92%8C%E9%9D%9E%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7"><span class="toc-text">应答信号和非应答信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%B9%E5%90%91"><span class="toc-text">读写方向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E6%B3%A2%E5%BD%A2"><span class="toc-text">I2C波形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-text">读操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-text">I2C子系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">分层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%B1%82"><span class="toc-text">I2C设备驱动层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C-%E6%A0%B8%E5%BF%83%E5%B1%82"><span class="toc-text">I2C 核心层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E9%80%82%E9%85%8D%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%B1%82"><span class="toc-text">I2C适配器驱动层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C-client-%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99-%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">I2C client 代码编写(设备树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">设备树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88rk3568%E5%8E%9F%E6%9C%AC%E7%9A%84%E9%A9%B1%E5%8A%A8"><span class="toc-text">取消rk3568原本的驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FT5X06-Client%E7%BC%96%E5%86%99"><span class="toc-text">FT5X06 Client编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-i2c-client"><span class="toc-text">struct i2c_client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8C%E7%BC%96%E5%86%99I2C-Client"><span class="toc-text">用C编写I2C Client</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#i2c-get-adapter"><span class="toc-text">i2c_get_adapter()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i2c-put-adapter"><span class="toc-text">i2c_put_adapter()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-i2c-adaper"><span class="toc-text">struct i2c_adaper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i2c-new-client-device"><span class="toc-text">i2c_new_client_device()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#i2c-bus-probe"><span class="toc-text">i2c_bus_probe()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-i2c-board-info"><span class="toc-text">struct i2c_board_info</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B1%82-I2C-%E9%80%9A%E4%BF%A1"><span class="toc-text">核心层 I2C 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c-master-recv"><span class="toc-text">i2c_master_recv()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c-master-send"><span class="toc-text">i2c_master_send()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c-transfer-buffer-flags"><span class="toc-text">i2c_transfer_buffer_flags()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c-transfer"><span class="toc-text">i2c_transfer()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-i2c-msg"><span class="toc-text">struct i2c_msg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-i2c-algorithm"><span class="toc-text">struct i2c_algorithm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i2c-lock-bus-helper"><span class="toc-text">__i2c_lock_bus_helper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i2c-transfer-1"><span class="toc-text">__i2c_transfer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C-%E9%A9%B1%E5%8A%A8"><span class="toc-text">I2C 驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c-add-driver"><span class="toc-text">i2c_add_driver()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-i2c-driver"><span class="toc-text">struct i2c_driver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8I2C"><span class="toc-text">在应用程序中使用I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ioctl-%E6%8E%A7%E5%88%B6-I2C"><span class="toc-text">ioctl 控制 I2C</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8I2C%E9%A9%B1%E5%8A%A8"><span class="toc-text">通用I2C驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c-dev-init"><span class="toc-text">i2c_dev_init()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c-dev-adapter"><span class="toc-text">i2c_dev_adapter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-file-operations-i2cdev-fops"><span class="toc-text">struct file_operations i2cdev_fops</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#i2cdev-open"><span class="toc-text">i2cdev_open()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i2cdev-read"><span class="toc-text">i2cdev_read()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i2cdev-write"><span class="toc-text">i2cdev_write()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i2cdev-ioctl"><span class="toc-text">i2cdev_ioctl()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C-tools"><span class="toc-text">I2C_tools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i2cdetect"><span class="toc-text">i2cdetect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2cdump"><span class="toc-text">i2cdump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2cset"><span class="toc-text">i2cset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2cget"><span class="toc-text">i2cget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2ctransfer"><span class="toc-text">i2ctransfer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-GPIO-%E6%A8%A1%E6%8B%9F-I2C-%E9%A9%B1%E5%8A%A8"><span class="toc-text">使用 GPIO 模拟 I2C 驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Linux%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A8%A1%E6%8B%9FI2C%E7%A8%8B%E5%BA%8F"><span class="toc-text">使用Linux默认的模拟I2C程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMBus%E6%80%BB%E7%BA%BF"><span class="toc-text">SMBus总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SMBus%E7%89%B9%E7%82%B9"><span class="toc-text">SMBus特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMBus-%E5%92%8C-I2C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">SMBus 和 I2C 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMBus-%E6%80%BB%E7%BA%BF%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-text">SMBus 总线软件实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMBus-%E6%80%BB%E7%BA%BF-API-%E5%87%BD%E6%95%B0"><span class="toc-text">SMBus 总线 API 函数</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post liquidGlass-wrapper"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2601261/" title="io_uring"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="io_uring"/></a><div class="content"><a class="title" href="/posts/2601261/" title="io_uring">io_uring</a><time datetime="2026-01-26T07:25:13.000Z" title="发表于 2026-01-26 15:25:13">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601133/" title="Linux 网络设备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux 网络设备"/></a><div class="content"><a class="title" href="/posts/2601133/" title="Linux 网络设备">Linux 网络设备</a><time datetime="2026-01-13T14:00:00.000Z" title="发表于 2026-01-13 22:00:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601143/" title="Linux ADC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux ADC"/></a><div class="content"><a class="title" href="/posts/2601143/" title="Linux ADC">Linux ADC</a><time datetime="2026-01-13T13:18:00.000Z" title="发表于 2026-01-13 21:18:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601093/" title="Linux CAN"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux CAN"/></a><div class="content"><a class="title" href="/posts/2601093/" title="Linux CAN">Linux CAN</a><time datetime="2026-01-09T07:56:00.000Z" title="发表于 2026-01-09 15:56:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601063/" title="Linux Watchdog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux Watchdog"/></a><div class="content"><a class="title" href="/posts/2601063/" title="Linux Watchdog">Linux Watchdog</a><time datetime="2026-01-06T05:09:00.000Z" title="发表于 2026-01-06 13:09:00">2026-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601053/" title="Linux RTC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux RTC"/></a><div class="content"><a class="title" href="/posts/2601053/" title="Linux RTC">Linux RTC</a><time datetime="2026-01-05T14:09:00.000Z" title="发表于 2026-01-05 22:09:00">2026-01-05</time></div></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a target="_blank" rel="noopener" href="https://github.com/even629" title="github"><i class="fab fa-github"></i></a><a href="/img/qq.jpg" title="qq"><i class="fa-brands fa-qq"></i></a><a href="mailto:zhaohang731005515@proton.me" title="email"><i class="fas fa-envelope"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/519280138" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a href="/atom.xml" title="rss"><i class="fas fa-rss"></i></a></div><div class="copyright">&copy;2024 - 2026 By even629</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Frame-Hexo-blue.svg" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Theme-Butterfly.svg" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Source-Github.svg" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Copyright-BY--NC--SA.4.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"> </span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.stopSakura();"><i class="fa-solid fa-feather"></i><span data-zh="樱花特效" data-en="toggle sakura"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '35472001a4d12789bc1bbff2eedf1065'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.js"></script><script src="/js/sakura.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/solarlunar.js"></script><script src="/js/newYear.js"></script><script src="/js/pop-up-window.js"></script><script data-pjax src="/js/nav.js"></script><script data-pjax src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><svg style="display: none">
<filter
  id="glass-distortion"
  x="0%"
  y="0%"
  width="100%"
  height="100%"
  filterUnits="objectBoundingBox"
>
  <feTurbulence
    type="fractalNoise"
    baseFrequency="0.01 0.01"
    numOctaves="1"
    seed="5"
    result="turbulence"
  />
  <!-- Seeds: 14, 17,  -->

  <feComponentTransfer in="turbulence" result="mapped">
    <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
    <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
    <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
  </feComponentTransfer>

  <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />

  <feSpecularLighting
    in="softMap"
    surfaceScale="5"
    specularConstant="1"
    specularExponent="100"
    lighting-color="white"
    result="specLight"
  >
    <fePointLight x="-200" y="-200" z="300" />
  </feSpecularLighting>

  <feComposite
    in="specLight"
    operator="arithmetic"
    k1="0"
    k2="1"
    k3="1"
    k4="0"
    result="litImage"
  />

  <feDisplacementMap
    in="SourceGraphic"
    in2="softMap"
    scale="150"
    xChannelSelector="R"
    yChannelSelector="G"
  />
  </filter>
</svg>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr class="custom-hr"/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4847823_upluhme7cv.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><!-- hexo injector body_end end --></body></html>